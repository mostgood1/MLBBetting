<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pitcher Props</title>
  <!-- Prefetch home and quick snapshot so returning is instant, even on Render cold starts -->
  <link rel="prefetch" href="/">
  <link rel="prefetch" href="/api/today-games/quick?no_network=1">
  <link rel="stylesheet" href="/static/css/utilities.css" />
  <style>
    body { font-family: Segoe UI, Arial, sans-serif; background: #0b1220; color: #eaf4ff; margin: 0; }
    .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
    .toolbar { display: flex; gap: 10px; align-items: center; margin-bottom: 16px; flex-wrap: wrap; }
    input, button { padding: 9px 12px; border-radius: 8px; border: 1px solid #35507a; background: #0e192b; color: #eaf4ff; }
    input::placeholder { color: #b8c7dd; }
    input:focus, button:focus { outline: 2px solid #4fd1c7; outline-offset: 1px; }
    button { background: #18b7a0; border-color: #18b7a0; cursor: pointer; font-weight: 700; color: #0a141f; }
    button:hover { background: #10a38e; }
    /* Utilities moved to utilities.css */
    .legend { font-size:12px; line-height:1.5; margin:-4px 0 12px; background:rgba(255,255,255,0.06); padding:10px 12px; border:1px solid rgba(255,255,255,0.18); border-radius:8px; color:#eaf4ff; }
    .grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 18px; }
    @media (max-width: 760px){ .grid { grid-template-columns: 1fr; gap: 12px; } }
    .card { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.22); border-radius: 12px; padding: 12px; }
    .card-header { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
    .team-logo { width: 28px; height: 28px; object-fit: contain; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.28); border-radius: 6px; padding: 2px; box-shadow: 0 1px 2px rgba(0,0,0,0.35); }
    .pitcher-headshot { width: 38px; height: 38px; border-radius: 50%; object-fit: cover; border: 1px solid rgba(255,255,255,0.35); }
    .pitcher-name { font-weight: 900; color:#ffffff; }
    .muted { opacity: 0.92; font-size: 0.9rem; color:#cfe2ff; }
    .muted img { opacity: 1; }
    .tag { display: inline-block; padding: 2px 8px; border-radius: 999px; background: rgba(255,255,255,0.10); border: 1px solid rgba(255,255,255,0.28); font-size: 0.78rem; margin-left: 6px; color:#eaf4ff; }
    .rows { display: grid; gap: 6px; }
    .row { display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); align-items: center; gap: 6px; padding: 8px 10px; border-radius: 8px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.18); }
    .row > div { text-align: center; }
    .row .label { font-weight: 800; color:#ffffff; }
    .row .proj { opacity: 0.98; color:#eaf4ff; }
    .row .line { opacity: 0.98; color:#eaf4ff; }
    .row .live { font-weight: 800; color:#ffffff; }
    .row .odds { font-size: 0.86rem; opacity: 0.95; color:#d6e6ff; }
    /* Live vs projection highlighting */
    .live.delta-up { color: #27d17c; }
    .live.delta-down { color: #ff6464; }
    .live.delta-strong { text-shadow: 0 0 6px rgba(255,255,255,0.16); }
    .live.delta-weak { opacity: 0.98; }
    .edge { margin-left: 6px; font-weight: 900; }
    .edge-strong { color: #22c55e; }
    .edge-medium { color: #f59e0b; }
    .edge-small { color: #60a5fa; }
    .status-dot { width: 10px; height: 10px; border-radius: 50%; background: #c8d1dc; box-shadow: 0 0 0 2px #0b1220, 0 0 0 3px rgba(0,0,0,0.2); }
    .proj-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 8px; margin: 8px 0 10px; overflow: visible; }
    .live-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; box-shadow: 0 0 0 2px rgba(255,255,255,0.25); }
    .live-dot.ok { background: #00d161; }
    .live-dot.bad { background: #9aa7b5; }
    .stat-box { flex: 1 1 0%; min-width: 0; display: grid; grid-template-columns: 1fr auto; gap: 4px; align-items: baseline; padding: 6px 8px; border-radius: 8px; border: 1.5px solid rgba(255,255,255,0.28); background: rgba(255,255,255,0.06); }
    .stat-box .label { font-size: 0.72rem; opacity: 0.95; font-weight: 800; color:#eaf4ff; white-space: normal; overflow: visible; text-overflow: clip; min-width: 0; }
    .stat-box .value { font-size: 0.92rem; font-weight: 900; color:#ffffff; white-space: nowrap; overflow: visible; text-overflow: clip; }
    @media (max-width: 380px){
      .stat-box { padding: 4px 6px; gap: 3px; }
      .stat-box .label { font-size: 0.68rem; }
      .stat-box .value { font-size: 0.86rem; }
    }
    .stat-box.edge-strong { border-color: #22c55e; }
    .stat-box.edge-medium { border-color: #f59e0b; }
    .stat-box.edge-small { border-color: #60a5fa; }
    .play-badge { display: inline-block; margin-left: 6px; padding: 0 4px; border-radius: 4px; font-size: 0.82rem; font-weight: 900; line-height: 1; border: 0; }
    .play-badge.over { color: #22c55e; }
    .play-badge.under { color: #ef4444; }
    .live-pc { margin-left: auto; margin-right: 2px; padding: 3px 8px; border-radius: 999px; background: rgba(24,183,160,0.18); border: 1px solid rgba(24,183,160,0.42); font-size: 0.78rem; font-weight: 900; color: #c3f0e7; }
    .card-header { position: relative; }
    .live-pc.bad { background: rgba(239,68,68,0.15); border-color: rgba(239,68,68,0.38); color: #ffd1d1; }
    /* Deep link focus styles */
    .card.focus-ring { box-shadow: 0 0 0 2px rgba(79,209,199,0.9), 0 0 0 5px rgba(79,209,199,0.25); }
    .row.row-focus { outline: 2px solid #4fd1c7; outline-offset: 2px; }
    /* Focus banner */
    .focus-banner { display: none; margin-top:-4px; margin-bottom:8px; padding:8px 10px; border:1px solid rgba(255,255,255,0.22); border-radius:8px; background:rgba(255,255,255,0.06); }
    .focus-banner.show { display: block; }
    .btn-clear-focus { margin-left:10px; padding:4px 8px; border-radius:6px; border:1px solid #cfe1f8; background: transparent; color:#eaf4ff; cursor:pointer; }
  </style>
</head>
<body>
  <div class="container">
    <div class="toolbar">
      <a href="/" onclick="if(history.length>1){history.back();return false;}" class="link-back">← Back</a>
      <h1 class="h1-tight">Pitcher Props</h1>
      <div class="status-dot" id="sseDot" title="Props stream status"></div>
    </div>
    <div class="toolbar">
      <label>Date <input type="date" id="date" value="{{ date }}" /></label>
      <button type="button" id="refreshBtn">Refresh</button>
      <button type="button" id="forceRefreshBtn" class="btn-blue">Force Lines Refresh</button>
      <span id="refreshStatus" class="muted minw-140"></span>
    </div>
    <div class="toolbar wrap gap-12 items-center" id="progressBar">
      <div class="muted" id="propsProgress">Props coverage: —%</div>
      <div class="muted" id="propsNextEta"></div>
      <div class="muted" id="propsUpdatedAt"></div>
    </div>
    <div id="meta" class="muted mb-8">Loading...</div>
    <div id="focusBanner" class="muted focus-banner">
      <span id="focusText"></span>
      <button id="clearFocusBtn" type="button" class="btn-clear-focus">Clear focus</button>
    </div>
    <div class="muted legend">
      <strong>Legend:</strong> Edge color (green &gt;=1.0, amber &gt;=0.6, blue &gt;=0.3). ▲ / ▼ arrow shows model lean (over/under). <span class="fw-700">stale</span> badge = line carried from earlier snapshot. Kelly = recommended stake % of bankroll (raw Kelly, un-capped). EV = expected value of selected side. Live deltas color green when the live stat favors the recommended side.
    </div>
    <div id="grid" class="grid"></div>
    <div id="modelBanner" class="muted model-banner">
      <span id="modelInfo">Model: —</span>
      <span id="modelWhen"></span>
      <span id="linesFeed" title="Count of line/odds change events captured today"></span>
  <span class="live-dot" id="liveStatsDot" title="Live stats polling health"></span>
  <span id="liveStatsStatus"></span>
    </div>
  </div>

  <script>
    // Register service worker for improved cold-start navigation
    try { if ('serviceWorker' in navigator) { navigator.serviceWorker.register('/sw.js').catch(()=>{}); } } catch(_){}
    // Proactively warm the home quick snapshot so Back is instant
    try {
      window.addEventListener('DOMContentLoaded', () => {
        try { fetch(`/api/today-games/quick?no_network=1&t=${Date.now()}`, { keepalive: true, credentials: 'same-origin' }).catch(()=>{}); } catch(_){}
      });
    } catch(_){}
    const norm = s => (s||'').normalize('NFKD').replace(/[\u0300-\u036f]/g,'').toLowerCase().trim();
    let __DEEPLINK_TARGET = null; // { pid?:string, player?:string, market?:string }
    function parseDeepLink(){
      try{
        const sp = new URLSearchParams(location.search||'');
        const pid = sp.get('pid');
        const player = sp.get('player');
        const market = sp.get('market');
        const t = {};
        if(pid) t.pid = String(pid);
        if(player) t.player = String(player);
        if(market) t.market = String(market);
        __DEEPLINK_TARGET = (Object.keys(t).length? t : null);
      }catch(_){ __DEEPLINK_TARGET = null; }
    }
    function scrollToTargetIfAny(){
      try{
        if(!__DEEPLINK_TARGET) return;
        let card = null;
        if(__DEEPLINK_TARGET.pid){
          card = document.querySelector(`.card[data-pid="${CSS.escape(String(__DEEPLINK_TARGET.pid))}"]`);
        }
        if(!card && __DEEPLINK_TARGET.player){
          const key = norm(__DEEPLINK_TARGET.player);
          card = document.querySelector(`.card[data-pitcher="${CSS.escape(key)}"]`);
        }
        if(!card) return;
        card.scrollIntoView({behavior:'smooth', block:'start'});
        card.classList.add('focus-ring');
        setTimeout(()=> card.classList.remove('focus-ring'), 2000);
        if(__DEEPLINK_TARGET.market){
          const row = card.querySelector(`.row[data-market="${CSS.escape(__DEEPLINK_TARGET.market)}"]`);
          if(row){ row.classList.add('row-focus'); setTimeout(()=> row.classList.remove('row-focus'), 3000); }
        }
        // Show focus banner
        try{
          const ft = document.getElementById('focusText');
          const bn = document.getElementById('focusBanner');
          const nameTxt = (card.querySelector('.pitcher-name')?.textContent||'').trim();
          const mk = __DEEPLINK_TARGET.market || '';
          if(ft && bn){
            ft.textContent = `Focused: ${nameTxt}${mk?` — ${mk}`:''}`;
            bn.classList.add('show');
          }
        }catch(_){ }
      }catch(_){ /* noop */ }
    }
    const PC_BAD_THRESHOLD = 95;
    function updatePcBadge(el, v){
      if(!el) return;
      if (typeof v === 'number') {
        el.textContent = `PC ${v}`;
        el.classList.toggle('bad', v >= PC_BAD_THRESHOLD);
      } else {
        el.textContent = 'PC —';
        el.classList.remove('bad');
      }
    }

    function initialsAvatar(name){
      const initials = (name||'').split(' ').map(p=>p[0]).join('').toUpperCase();
      const bg = '1f2937';
      const fg = 'e5e7eb';
      return `https://ui-avatars.com/api/?name=${encodeURIComponent(initials)}&background=${bg}&color=${fg}`;
    }

    function toTitleCase(name){
      if(!name) return '';
      return name.split(' ').map(w => w.length<=2 ? w.toUpperCase() : (w[0].toUpperCase()+w.slice(1).toLowerCase())).join(' ');
    }

    function classifyEdge(edge){
      const a = Math.abs(Number(edge)||0);
      if(a >= 1.0) return 'edge-strong';
      if(a >= 0.6) return 'edge-medium';
      if(a >= 0.3) return 'edge-small';
      return '';
    }

  function renderCards(data){
      const grid = document.getElementById('grid');
      grid.innerHTML = '';
      const isLight = !!((data && data.meta && data.meta.light_mode));
      const pitchers = Object.entries(data.data || {}).sort((a,b)=>{
        const ea = (a[1].plays && a[1].plays.edge) ? Math.abs(a[1].plays.edge) : 0;
        const eb = (b[1].plays && b[1].plays.edge) ? Math.abs(b[1].plays.edge) : 0;
        return eb - ea;
      });
      const meta = data.meta || {};
  document.getElementById('meta').textContent = `${meta.pitchers||0} pitchers • source: ${meta.source_date||data.date}`;

      for(const [key, bundle] of pitchers){
  const name = bundle.display_name || bundle.raw_key || key;
  const team = bundle.team || '';
        const opp = bundle.opponent || '';
        const proj = bundle.simple_projection || {};
        const markets = bundle.markets || {};
        const plays = bundle.plays || {};
  const edge = typeof plays.edge === 'number' ? plays.edge : null;
  const logo = bundle.team_logo || null;
  const oppLogo = bundle.opponent_logo || null;
  const headshot = bundle.headshot_url || null;

        // Choose a primary market to surface edge; otherwise fall back to Ks if present
        const primary = plays.market || (markets.strikeouts ? 'strikeouts' : Object.keys(markets)[0]);
        const m = markets[primary] || {};
        const line = m.line;
        const overOdds = m.over_odds; const underOdds = m.under_odds;
        const oddsTxt = (overOdds!=null || underOdds!=null) ? `O ${overOdds??''} / U ${underOdds??''}` : '';
        const projVal = (typeof m.proj === 'number') ? m.proj : (typeof proj[primary] === 'number' ? proj[primary] : null);
        const edgeTxt = projVal!=null && line!=null ? ` (${(projVal - line).toFixed(1)})` : '';

        const card = document.createElement('div');
        card.className = 'card';
  card.setAttribute('data-pitcher', norm(key));
  const pid = bundle.mlb_player_id || bundle.player_id;
  if (pid) { card.setAttribute('data-pid', String(pid)); }
        // Build header
        // Build recommendation + odds summary and stale flag
        let recSummary = '';
        if (plays && plays.market && plays.side){
          const labelMap = {strikeouts:'K', outs:'Outs', hits_allowed:'Hits', walks:'BB', earned_runs:'ER'};
          const mkp = plays.market; const lbl = labelMap[mkp] || mkp;
          recSummary = `${plays.side} ${lbl}`;
          if (typeof plays.line === 'number') recSummary += ` @ ${plays.line}`;
          if (typeof plays.edge === 'number') recSummary += ` (edge ${Number(plays.edge).toFixed(2)})`;
        }
        const kInfo = markets.strikeouts || markets.k || null;
        let oddsBadge = '';
        if (kInfo && (kInfo.over_odds!=null || kInfo.under_odds!=null)){
          const oo = kInfo.over_odds!=null ? (kInfo.over_odds>0?`+${kInfo.over_odds}`:kInfo.over_odds) : '';
          const uo = kInfo.under_odds!=null ? (kInfo.under_odds>0?`+${kInfo.under_odds}`:kInfo.under_odds) : '';
          oddsBadge = `K O ${oo} / U ${uo}`;
        }
        // Add Kelly fraction (%) and EV (selected_ev) if available in plays
        let kellyTxt = '';
        if (plays && typeof plays.kelly_fraction === 'number') {
          const kf = plays.kelly_fraction * 100;
          if (isFinite(kf) && kf > 0) kellyTxt = `Kelly ${(kf).toFixed(1)}%`;
        }
        let evTxt = '';
        if (plays && typeof plays.selected_ev === 'number') {
          const evp = plays.selected_ev * 100; // assuming EV is stored as probability delta (already fraction)
          if (isFinite(evp)) evTxt = `EV ${evp.toFixed(1)}%`;
        }
        let extra = [kellyTxt, evTxt].filter(Boolean).join(' • ');
        let subLine = '';
        const baseCombo = recSummary && oddsBadge ? `${recSummary} • ${oddsBadge}` : (recSummary || oddsBadge || '');
        if (baseCombo && extra) subLine = `${baseCombo} • ${extra}`; else subLine = baseCombo || extra;
        const stale = Object.values(bundle.lines||{}).some(v => v && v._stale);
        const loadingBadge = isLight ? `<span class="tag" title="Full details loading…">loading…</span>` : '';
        card.innerHTML = `
          <div class="card-header">
            ${logo?`<img class="team-logo" src="${logo}" alt="${team}" />`:''}
            <img class="pitcher-headshot" src="${headshot || initialsAvatar(name)}" alt="${name}" onerror="this.onerror=null; this.src='${initialsAvatar(name)}'" />
            <div style="display:flex; flex-direction:column; gap:2px;">
              <div class="pitcher-name">${toTitleCase(name)}${edge!=null?` <span class=\"tag ${classifyEdge(edge)}\">edge ${edge.toFixed(2)}</span>`:''}${stale?` <span class=\"tag edge-small\" title=\"Contains stale (earlier snapshot) line(s)\">stale</span>`:''} ${loadingBadge}</div>
              <div style="display:flex; align-items:center; gap:6px; flex-wrap:wrap;" class="muted">
                ${logo?`<img class="team-logo" src="${logo}" alt="${team}" title="${team}" />`:''}
                <span style="font-weight:700;">vs</span>
                ${oppLogo?`<img class="team-logo" src="${oppLogo}" alt="${opp}" title="${opp}" />`:''}
              </div>
              ${subLine?`<div class=\"muted\" style=\"font-size:11px;\">${subLine}</div>`:''}
            </div>
            <div class="live-pc" title="Live pitch count" data-live-pc>PC —</div>
          </div>
          <div class="proj-stats" data-proj-stats></div>
          <div class="rows" data-market-rows></div>
        `;

        // Populate projection stat boxes with edge-colored outlines when a market line exists
        const projWrap = card.querySelector('[data-proj-stats]');
        const getProj = (mk) => {
          const info = markets[mk] || {};
          if (typeof info.proj === 'number') return info.proj;
          if (typeof proj[mk] === 'number') return proj[mk];
          return null;
        };
        const edgeClassFor = (mk) => {
          const p = getProj(mk);
          const l = (markets[mk] || {}).line;
          if (p != null && l != null) return classifyEdge(p - l);
          return '';
        };
        const fmt = (v) => (typeof v === 'number' ? v.toFixed(1) : '—');
  // Primary play (still used for sorting/tag), but arrows are derived per-stat from proj vs line
  const playMarket = (plays && plays.market) ? String(plays.market) : null;
  const playSide = (plays && plays.side) ? String(plays.side).toUpperCase() : null;
        const deriveSide = (mk) => {
          const p = getProj(mk); const l = (markets[mk]||{}).line;
          if (p==null || l==null) return null;
          const d = p - l;
          if (Math.abs(d) < 0.05) return null;
          return d > 0 ? 'OVER' : 'UNDER';
        };
        const addBox = (label, value, cls, mk) => {
          const div = document.createElement('div');
          div.className = `stat-box ${cls||''}`.trim();
          if (mk) div.setAttribute('data-market', mk);
          let badge = '';
          // Derive an arrow for each stat that has both a projection and a line
          if (mk) {
            const side = deriveSide(mk) || (playMarket===mk ? playSide : null);
            if (side) {
              const arrow = side === 'OVER' ? '▲' : '▼';
              badge = `<span class="play-badge ${side.toLowerCase()}" title="${side}">${arrow}</span>`;
            }
          }
          div.innerHTML = `<div class="label">${label}${badge}</div><div class="value">${fmt(value)}</div>`;
          projWrap.appendChild(div);
        };
        addBox('PC', proj.pitch_count ?? null, '', null);
        // Initialize live pitch badge if available
        const livePcEl = card.querySelector('[data-live-pc]');
        const lp = bundle.live_pitches;
  if (livePcEl) updatePcBadge(livePcEl, lp);
        addBox('K', getProj('strikeouts'), edgeClassFor('strikeouts'), 'strikeouts');
        addBox('Outs', getProj('outs'), edgeClassFor('outs'), 'outs');
        addBox('ER', getProj('earned_runs'), edgeClassFor('earned_runs'), 'earned_runs');
        addBox('Hits', getProj('hits_allowed'), edgeClassFor('hits_allowed'), 'hits_allowed');
        addBox('BB', getProj('walks'), edgeClassFor('walks'), 'walks');
        const rows = card.querySelector('[data-market-rows]');
        const order = ['strikeouts','outs','earned_runs','hits_allowed','walks'];
        for(const mk of order){
          if(!(mk in markets)) continue;
          const info = markets[mk] || {}; const lineV = info.line; const over = info.over_odds; const under = info.under_odds;
          const projV = getProj(mk);
          const label = mk==='strikeouts'?'K': mk==='hits_allowed'?'Hits Allowed': mk==='earned_runs'?'Earned Runs': mk==='walks'?'Walks':'Outs';
          const row = document.createElement('div');
          row.className = 'row';
          row.setAttribute('data-market', mk);
          if (projV != null && !Number.isNaN(projV)) row.setAttribute('data-proj', String(projV));
          if (lineV != null && !Number.isNaN(lineV)) row.setAttribute('data-line', String(lineV));
          // Prefer explicit play side for the selected market; otherwise derive from proj vs line
          const sideDirect = (playMarket===mk && playSide) ? String(playSide).toUpperCase() : null;
          if (sideDirect) {
            row.setAttribute('data-side', sideDirect);
          } else if (projV!=null && lineV!=null && !Number.isNaN(projV) && !Number.isNaN(lineV)){
            const d = projV - lineV; if (Math.abs(d) >= 0.05) row.setAttribute('data-side', d>0?'OVER':'UNDER');
          }
          row.innerHTML = `
            <div class="label">${label}</div>
            <div class="line">Line ${lineV!=null?lineV.toFixed?.(1) ?? lineV:'—'}</div>
            <div class="live" data-live="${mk}">Live: —</div>
            <div class="odds">${over!=null||under!=null?`O ${over??''} / U ${under??''}`:''}</div>
          `;
          rows.appendChild(row);
        }
        grid.appendChild(card);
      }
      // After DOM is built, perform deep link scroll/highlight once
      scrollToTargetIfAny();
    }

    // Recompute projection box border class and arrow when line moves
    function updateProjectionBox(card, mk, newLine){
      try{
        const box = card.querySelector(`.stat-box[data-market="${mk}"]`);
        if(!box) return;
        const marketRows = card.querySelector(`.row[data-market="${mk}"]`);
        // establish current projection
        let proj = null;
        if (marketRows){
          const pAttr = marketRows.getAttribute('data-proj');
          if (pAttr!=null && pAttr!=='') proj = Number(pAttr);
        }
        if (proj==null || Number.isNaN(proj) || typeof newLine !== 'number'){
          // near tie or missing -> clear badge and edge classes
          const lbl = box.querySelector('.label');
          if (lbl){
            const text = lbl.textContent ? lbl.textContent.replace(/[▲▼]/g,'').trim() : '';
            lbl.innerHTML = text; // remove badge
          }
          box.classList.remove('edge-strong','edge-medium','edge-small');
          return;
        }
        const d = proj - newLine;
        // update edge intensity class
        box.classList.remove('edge-strong','edge-medium','edge-small');
        const cls = classifyEdge(d);
        if (cls) box.classList.add(cls);
        // update badge arrow by side
        const side = Math.abs(d) < 0.05 ? null : (d > 0 ? 'OVER' : 'UNDER');
        const lbl = box.querySelector('.label');
        if (lbl){
          // extract plain label text (strip any prior badge)
          const raw = lbl.textContent || '';
          // The label contains e.g., 'K▲' or 'K'; rebuild cleanly from market key
          const label = (mk==='strikeouts'?'K': mk==='hits_allowed'?'Hits' : mk==='earned_runs'?'ER' : mk==='walks'?'BB':'Outs');
          let badge = '';
          if (side){
            const arrow = side === 'OVER' ? '▲' : '▼';
            badge = `<span class="play-badge ${side.toLowerCase()}" title="${side}">${arrow}</span>`;
          }
          lbl.innerHTML = `${label}${badge}`;
        }
      }catch(_){ }
    }

    async function loadUnified(full=false, noCache=false){
      const date = document.getElementById('date').value;
      const bust = `t=${Date.now()}`;
      const params = new URLSearchParams();
      if(date) params.set('date', date);
      params.set('t', Date.now());
      if(noCache) params.set('nocache','1');
      if(!full) params.set('light','1');
      // include timings only on first (light) load
      if(!full) params.set('timings','1');
      const url = `/api/pitcher-props/unified?${params.toString()}`;
      const started = performance.now();
      const resp = await fetch(url);
      const metaEl = document.getElementById('meta');
      if(!resp.ok){ if(metaEl) metaEl.textContent = 'Failed to load unified props.'; return; }
      const data = await resp.json();
      if(!data.success){ if(metaEl) metaEl.textContent = 'No data'; return; }
      if(!full){
        // First paint (light)
        window.__UNIFIED_LIGHT = data;
        renderCards(data);
        if(metaEl){
          const total = (data.meta && data.meta.timings && data.meta.timings.total) || ((performance.now()-started)/1000).toFixed(2);
          const marketsTotal = (data.meta && typeof data.meta.markets_total === 'number') ? data.meta.markets_total : null;
          let msg = `Loaded ${data.meta.pitchers||0} pitchers (light) in ${total}s`;
          if (marketsTotal === 0) {
            msg += ' • No odds yet — use "Force Lines Refresh" to fetch live odds';
          }
          metaEl.textContent = msg;
        }
        // Kick off background full load (propagate noCache)
        loadUnified(true, noCache).catch(()=>{});
      } else {
        // Merge full data and fully re-render so markets, projections, and odds appear
        window.__UNIFIED = data;
        renderCards(data);
        if(metaEl){ metaEl.textContent += ' • Full data ready'; }
      }
    }

    async function loadDiagnostics(){
      try{
        const date = document.getElementById('date').value;
        const r = await fetch(`/api/pitcher-props/model-diagnostics?date=${encodeURIComponent(date)}&t=${Date.now()}`);
        if(!r.ok) return;
        const d = await r.json();
        if(!d.success) return;
        const model = d.model || {};
        const ver = model.version || 'n/a';
        const when = model.promoted_at || model.created_at || '';
        const modelInfo = document.getElementById('modelInfo');
        const modelWhen = document.getElementById('modelWhen');
        const linesFeed = document.getElementById('linesFeed');
        if(modelInfo) modelInfo.textContent = `Model: ${ver}`;
        if(modelWhen) modelWhen.textContent = when ? `• Promoted: ${when}` : '';
        if(linesFeed) linesFeed.textContent = typeof d.line_event_count === 'number' ? `• Lines feed events: ${d.line_event_count}` : '';
      }catch(_){ }
    }

    async function pollPropsProgress(){
      try{
        const resp = await fetch(`/api/props/progress?t=${Date.now()}`);
        if(!resp.ok) return;
        const payload = await resp.json();
        if(!payload || !payload.success) return;
        const d = payload.data || {};
        const pct = (typeof d.coverage_percent === 'number') ? d.coverage_percent.toFixed(1) : '—';
        const normZ = (s) => {
          try{
            if(!s) return null;
            const t = String(s);
            // If already has timezone designator, use as-is
            if(/Z$|[+\-]\d{2}:?\d{2}$/.test(t)) return t;
            return t + 'Z';
          }catch(_){ return s; }
        };
        const eta = d.next_run_eta ? new Date(normZ(d.next_run_eta)).toLocaleTimeString() : '';
        const upd = d.updated_at ? new Date(normZ(d.updated_at)).toLocaleTimeString() : '';
        const covEl = document.getElementById('propsProgress');
        const etaEl = document.getElementById('propsNextEta');
        const updEl = document.getElementById('propsUpdatedAt');
        if(covEl){
          const covered = d.covered_pitchers ?? '—';
          const total = d.total_pitchers ?? '—';
          covEl.textContent = `Props coverage: ${pct}% (${covered}/${total})`;
        }
        if(etaEl){ etaEl.textContent = eta ? `Next run ~ ${eta}` : ''; }
        if(updEl){ updEl.textContent = upd ? `Updated ${upd}` : ''; }
      }catch(_){ }
    }

    function classifyDelta(mk, delta, side){
      const abs = Math.abs(Number(delta) || 0);
      // Market-specific sensitivity (in stat units)
      const thr = { strikeouts: 0.5, outs: 1.0, earned_runs: 0.5, hits_allowed: 1.0, walks: 0.5 };
      const t = thr[mk] || 0.7;
      const cls = [];
      // side-based goodness: OVER good when live > line; UNDER good when live < line
      if (side === 'OVER' && delta > 0) cls.push('delta-up');
      else if (side === 'UNDER' && delta < 0) cls.push('delta-up');
      else if (side === 'OVER' && delta < 0) cls.push('delta-down');
      else if (side === 'UNDER' && delta > 0) cls.push('delta-down');
      if (cls.length) cls.push(abs >= t ? 'delta-strong' : 'delta-weak');
      return cls.join(' ');
    }

    function applyLiveToRow(card, mk, value){
      const row = card.querySelector(`.row[data-market="${mk}"]`);
      if(!row) return;
      const liveEl = row.querySelector('.live');
      if(liveEl){
        liveEl.textContent = `Live: ${value}`;
        // compute delta vs betting line; color by play side (OVER/UNDER)
        const lineAttr = row.getAttribute('data-line');
        const line = lineAttr!=null && lineAttr!=='' ? Number(lineAttr) : null;
        // Always derive side from current proj vs line when possible; fallback to stored data-side
        const projAttr = row.getAttribute('data-proj');
        const proj = projAttr!=null && projAttr!=='' ? Number(projAttr) : null;
        let side = null;
        if (proj!=null && line!=null && !Number.isNaN(proj) && !Number.isNaN(line)){
          const d = proj - line; if (Math.abs(d) >= 0.05) side = d > 0 ? 'OVER' : 'UNDER';
        }
        if (!side) side = (row.getAttribute('data-side') || '').toUpperCase() || null;
        liveEl.classList.remove('delta-up','delta-down','delta-strong','delta-weak');
        if (line!=null && !Number.isNaN(line) && side){
          const delta = Number(value) - line;
          const cls = classifyDelta(mk, delta, side);
          cls.split(' ').forEach(c=>{ if(c) liveEl.classList.add(c); });
          liveEl.title = `${side}: Δ ${delta>=0?'+':''}${delta.toFixed(1)} vs line ${line.toFixed(1)}`;
        } else {
          // no line -> leave white and clear tooltip
          liveEl.removeAttribute('title');
        }
      }
    }

    function updateLive(ev){
      try{
        const pk = norm(ev.pitcher || ev.pitcher_name || ev.key || '');
        if(!pk) return;
        const el = document.querySelector(`.card[data-pitcher="${pk}"]`);
        if(!el) return;
    const mk = ev.market;
    // Support both initial and move events
    const line = (typeof ev.line === 'number') ? ev.line : (typeof ev.new_line === 'number' ? ev.new_line : undefined);
        let row = el.querySelector(`.row[data-market="${mk}"]`);
        if(!row && mk){
          // Create a new row dynamically if this market appeared after initial render
          const label = mk==='strikeouts'?'K': mk==='hits_allowed'?'Hits Allowed': mk==='earned_runs'?'Earned Runs': mk==='walks'?'Walks':'Outs';
          const rowsWrap = el.querySelector('[data-market-rows]');
          if(rowsWrap){
            row = document.createElement('div');
            row.className = 'row';
            row.setAttribute('data-market', mk);
            row.innerHTML = `
              <div class="label">${label}</div>
              <div class="line">Line —</div>
              <div class="live" data-live="${mk}">Live: —</div>
              <div class="odds"></div>
            `;
            // Attempt to backfill line/proj/side from current unified payload if available
            try{
              if (window.__UNIFIED && window.__UNIFIED.data){
                const bundle = window.__UNIFIED.data[pk];
                if (bundle){
                  const markets = bundle.markets || {};
                  const info = markets[mk] || {};
                  const lineV = info.line;
                  if (typeof lineV === 'number'){ row.setAttribute('data-line', String(lineV)); row.querySelector('.line').textContent = `Line ${lineV.toFixed(1)}`; }
                  const proj = (typeof info.proj === 'number') ? info.proj : ((bundle.simple_projection||{})[mk]);
                  if (typeof proj === 'number'){ row.setAttribute('data-proj', String(proj)); }
                  const plays = bundle.plays || {}; const pM = (plays && plays.market) ? String(plays.market) : null; const pS = (plays && plays.side) ? String(plays.side).toUpperCase() : null;
                  if (pM===mk && pS){ row.setAttribute('data-side', pS); }
                  else if (typeof proj === 'number' && typeof lineV === 'number'){
                    const d = proj - lineV; if (Math.abs(d) >= 0.05) row.setAttribute('data-side', d>0?'OVER':'UNDER');
                  }
                }
              }
            }catch(_){ }
            rowsWrap.appendChild(row);
          }
        }
  if(row){
          if(typeof line === 'number'){
            const l = row.querySelector('.line'); if(l) l.textContent = `Line ${line.toFixed(1)}`;
            row.setAttribute('data-line', String(line));
            // Recompute and persist side: OVER/UNDER or clear when near tie
            try{
              const projAttr = row.getAttribute('data-proj');
              const proj = projAttr!=null && projAttr!=='' ? Number(projAttr) : null;
              if (proj!=null && !Number.isNaN(proj)){
                const d = proj - line; if (Math.abs(d) >= 0.05) row.setAttribute('data-side', d>0?'OVER':'UNDER'); else row.removeAttribute('data-side');
              }
            }catch(_){ }
            // Update projection box visuals for this market
            updateProjectionBox(el, mk, line);
          }
          const odds = row.querySelector('.odds');
          if(odds){
      const oo = (ev.over_odds != null) ? ev.over_odds : (ev.new_over_odds != null ? ev.new_over_odds : '');
      const uo = (ev.under_odds != null) ? ev.under_odds : (ev.new_under_odds != null ? ev.new_under_odds : '');
            if(oo!=='' || uo!=='') odds.textContent = `O ${oo} / U ${uo}`;
          }
        }
        // Optionally support pitch count events if provided
        if (typeof ev.live_pitches === 'number'){
          const pcEl = el.querySelector('[data-live-pc]');
          if (pcEl) updatePcBadge(pcEl, ev.live_pitches);
        }
      }catch(e){ console.warn('live update failed', e); }
    }

    // Gentle polling for live pitch counts to supplement SSE
    async function pollLivePitches(){
      try{
        const date = document.getElementById('date').value;
        const r = await fetch(`/api/pitcher-props/live-pitches?date=${encodeURIComponent(date)}&t=${Date.now()}`);
        if(!r.ok) return;
        const data = await r.json();
        if(!data.success) return;
        const map = data.live_pitches || {};
        for(const [k,v] of Object.entries(map)){
          const el = document.querySelector(`.card[data-pitcher="${norm(k)}"] [data-live-pc]`);
          if(el){ updatePcBadge(el, v); }
        }
      }catch(_){}
    }

    // Poll live per-pitcher stats and update the 'Live:' cells in market rows
  async function pollLiveStats(){
      try{
        const date = document.getElementById('date').value;
        const r = await fetch(`/api/pitcher-props/live-stats?date=${encodeURIComponent(date)}&t=${Date.now()}`);
  const status = document.getElementById('liveStatsStatus');
  const dot = document.getElementById('liveStatsDot');
  if(!r.ok){ if(status) status.textContent = '• Live stats: error'; if(dot){ dot.classList.remove('ok'); dot.classList.add('bad'); } return; }
        const data = await r.json();
  if(!data.success){ if(status) status.textContent = '• Live stats: error'; if(dot){ dot.classList.remove('ok'); dot.classList.add('bad'); } return; }
        const stats = data.live_stats || {};
        const statsById = data.live_stats_by_id || {};
  if(status) status.textContent = `• Live stats: ${Object.keys(stats).length}`;
  if(dot){ dot.classList.remove('bad'); dot.classList.add('ok'); }
        for(const [k, st] of Object.entries(stats)){
          const card = document.querySelector(`.card[data-pitcher="${norm(k)}"]`);
          if(!card) continue;
      if(typeof st.strikeouts === 'number') applyLiveToRow(card, 'strikeouts', st.strikeouts);
      if(typeof st.outs === 'number') applyLiveToRow(card, 'outs', st.outs);
      if(typeof st.earned_runs === 'number') applyLiveToRow(card, 'earned_runs', st.earned_runs);
      if(typeof st.hits_allowed === 'number') applyLiveToRow(card, 'hits_allowed', st.hits_allowed);
      if(typeof st.walks === 'number') applyLiveToRow(card, 'walks', st.walks);
          // also keep pitch count badge aligned if present
          const pcEl = card.querySelector('[data-live-pc]');
          if(pcEl && typeof st.pitches === 'number'){ updatePcBadge(pcEl, st.pitches); }
        }
        // Second pass: fill by player_id for cases where name keys don't match
        for(const [pid, st] of Object.entries(statsById)){
          const card = document.querySelector(`.card[data-pid="${String(pid)}"]`);
          if(!card) continue;
      if(typeof st.strikeouts === 'number') applyLiveToRow(card, 'strikeouts', st.strikeouts);
      if(typeof st.outs === 'number') applyLiveToRow(card, 'outs', st.outs);
      if(typeof st.earned_runs === 'number') applyLiveToRow(card, 'earned_runs', st.earned_runs);
      if(typeof st.hits_allowed === 'number') applyLiveToRow(card, 'hits_allowed', st.hits_allowed);
      if(typeof st.walks === 'number') applyLiveToRow(card, 'walks', st.walks);
          const pcEl = card.querySelector('[data-live-pc]');
          if(pcEl && typeof st.pitches === 'number'){ updatePcBadge(pcEl, st.pitches); }
        }
      }catch(_){ }
    }

    let es;
    function startSSE(){
      try {
  es = new EventSource('/api/pitcher-props/stream');
  es.onopen = ()=>{ document.getElementById('sseDot').style.background = '#00c853'; };
        es.onmessage = (msg)=>{ if(!msg.data) return; try { const ev = JSON.parse(msg.data); if(ev && ev.type) updateLive(ev); } catch(e){} };
        es.onerror = ()=>{ try{ es.close(); }catch(_){}; document.getElementById('sseDot').style.background = '#bbb'; setTimeout(startSSE, 10000); };
      } catch(e){ setTimeout(startSSE, 15000); }
    }

    let _pcTimer;
  window.addEventListener('DOMContentLoaded', ()=>{
  // parse deep link early
  parseDeepLink();
  // initial load
  loadUnified(); loadDiagnostics(); startSSE();
  // wire refresh after DOM is ready
  try{
    const btn = document.getElementById('refreshBtn');
    const date = document.getElementById('date');
    const doRefresh = ()=>{
      if(btn){ btn.disabled = true; const prev = btn.textContent; btn.textContent = 'Refreshing…'; setTimeout(()=>{ try{ btn.disabled=false; btn.textContent=prev; }catch(_){ } }, 1200); }
      // Bypass server cache on manual refresh for immediate rebuild
      loadUnified(false, true); loadDiagnostics(); setTimeout(()=>{ pollLivePitches(); pollLiveStats(); }, 200);
    };
    if(btn){ btn.addEventListener('click', doRefresh); }
    if(date){ date.addEventListener('change', doRefresh); }
  }catch(_){ }
      // Poll every 20s for live pitch counts
      try{ if(_pcTimer) clearInterval(_pcTimer); }catch(_){}
      _pcTimer = setInterval(pollLivePitches, 20000);
      setTimeout(pollLivePitches, 1500);
  // Poll live stats every 15s
  try{ if(window._lsTimer) clearInterval(window._lsTimer); }catch(_){ }
  window._lsTimer = setInterval(pollLiveStats, 15000);
  setTimeout(pollLiveStats, 1200);
  // Progress polling every 25s
  try{ if(window._ppTimer) clearInterval(window._ppTimer); }catch(_){ }
  window._ppTimer = setInterval(pollPropsProgress, 25000);
  setTimeout(pollPropsProgress, 800);
  // Force refresh button logic
  try{
    const fBtn = document.getElementById('forceRefreshBtn');
    const statusEl = document.getElementById('refreshStatus');
    async function doForce(){
      if(!fBtn) return; const prev = fBtn.textContent; fBtn.disabled=true; fBtn.textContent='Refreshing…'; statusEl.textContent='';
      try{
        const date = document.getElementById('date').value;
  const r = await fetch('/api/pitcher-props/refresh', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({date, push:true})});
        const js = await r.json().catch(()=>({}));
        if (r.ok && js.success){ statusEl.textContent='Refreshed'; await loadUnified(false, true); }
        else statusEl.textContent = 'Refresh failed';
      }catch(e){ statusEl.textContent='Error'; }
      finally { fBtn.disabled=false; fBtn.textContent=prev; setTimeout(()=>{ statusEl.textContent=''; }, 5000); }
    }
    if(fBtn) fBtn.addEventListener('click', doForce);
  }catch(_){ }

  // Auto-refresh odds while markets are empty (gentle backoff, capped)
  (function setupAutoLinesRefresh(){
    let lastTry = 0;
    let tries = 0;
    const MAX_TRIES = 6;          // at most 6 auto refresh attempts
    const BASE_MS = 60000;        // 1 min base
    async function maybeAutoRefresh(){
      try{
        const meta = (window.__UNIFIED && window.__UNIFIED.meta) || (window.__UNIFIED_LIGHT && window.__UNIFIED_LIGHT.meta) || {};
        const total = Number(meta.markets_total || 0);
        const pitchers = Number(meta.pitchers || 0);
        // only try if we have pitchers rendered but no odds yet
        if(pitchers>0 && total===0 && tries<MAX_TRIES){
          const now = Date.now();
          const gap = BASE_MS * Math.min(1 + tries, 5); // backoff: 1m,2m,3m,4m,5m
          if(now - lastTry >= gap){
            lastTry = now; tries += 1;
            const date = document.getElementById('date').value;
            try {
              const r = await fetch('/api/pitcher-props/refresh', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({date, push:true})});
              if(r.ok){
                try { await loadUnified(true); } catch(_){ }
              }
            } catch(_){ }
          }
        }
      }catch(_){ }
    }
    try{ if(window._autoLinesTimer) clearInterval(window._autoLinesTimer); }catch(_){}
    window._autoLinesTimer = setInterval(maybeAutoRefresh, 30000); // check every 30s
    setTimeout(maybeAutoRefresh, 5000);
  })();
  // Clear focus behavior
  try{
    const btn = document.getElementById('clearFocusBtn');
    if(btn){
      btn.addEventListener('click', ()=>{
        try{
          // Hide banner
          const bn = document.getElementById('focusBanner'); if(bn) bn.classList.remove('show');
          __DEEPLINK_TARGET = null;
          // Remove any temporary highlights if present
          document.querySelectorAll('.card.focus-ring').forEach(el=> el.classList.remove('focus-ring'));
          document.querySelectorAll('.row.row-focus').forEach(el=> el.classList.remove('row-focus'));
          // Clean URL (remove query params) without reload
          const url = new URL(window.location.href);
          url.searchParams.delete('player');
          url.searchParams.delete('pid');
          url.searchParams.delete('market');
          window.history.replaceState({}, '', url.pathname + (url.searchParams.toString()?('?'+url.searchParams.toString()):''));
        }catch(_){ }
      });
    }
  }catch(_){ }
    });
  </script>
</body>
</html>
