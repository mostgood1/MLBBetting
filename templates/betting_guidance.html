<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Betting Guidance - Kelly Recommendations</title>
  <link rel="icon" href="/static/favicon.ico" />
  <link rel="stylesheet" href="/static/css/utilities.css" />
  <style>
    /* Base layout */
    body { font-family: Inter, Segoe UI, Arial, sans-serif; background:#0b1e39; color:#e5e7eb; margin:0; }
    .container { max-width:1200px; margin:0 auto; padding:24px; }
  /* card style comes from utilities.css when used as a light card; keeping here for this page layout specifics only if needed */
    h1 { color:#163a6b; }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(260px,1fr)); gap:16px; }
    /* Stat tiles sit on light background, enforce dark text for contrast */
    .stat { background:#f8fbff; color:#163a6b; border:1px solid #e2ecf7; border-radius:12px; padding:16px; text-align:center; }
    .stat .num { font-size:28px; font-weight:700; color:#163a6b; }
    /* badge/button/muted now come from utilities.css */
  .input { padding:8px 10px; border-radius:8px; border:1px solid #cfe1f8; }
  /* table styles are consolidated into utilities.css */
  /* utilities are provided by utilities.css */
    /* Responsive enhancements */
    @media (max-width: 700px){
      body { font-size:14px; }
      .container { padding:16px; }
      h1 { font-size:22px; }
      h2 { font-size:18px; }
      .grid { grid-template-columns: repeat(auto-fit, minmax(160px,1fr)); gap:12px; }
      .stat { padding:12px; }
      .stat .num { font-size:22px; }
      .btn { padding:8px 12px; font-size:13px; }
      .input { padding:6px 8px; font-size:13px; }
      .table th, .table td { padding:6px 8px; font-size:12px; }
      #roi-metrics-card .grid { grid-template-columns: repeat(auto-fit, minmax(140px,1fr)); }
      .card { padding:16px; }
      .muted { font-size:12px; }
    }
    /* Very small screens */
    @media (max-width:480px){
      h1 { font-size:19px; }
      .grid { grid-template-columns: repeat(auto-fit, minmax(140px,1fr)); }
      .stat .num { font-size:20px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <div class="row-between">
        <h1>ðŸŽ¯ Betting Guidance (Kelly-Based)</h1>
        <a class="btn secondary" href="/">â¬… Back to Main</a>
      </div>
      <div class="muted">Todayâ€™s opportunities and historical performance by bet type.</div>
      <div class="mt-10">
        <a class="btn" href="/kelly-guidance">Open Kelly Guidance Page â†’</a>
      </div>
    </div>

  <div class="grid" id="perf"></div>

  <div class="card mt-18" id="roi-metrics-card">
    <h2>Recent ROI & Efficiency</h2>
    <div class="muted mb-8" id="roi-subtitle">Rolling last 7 days (excl. today). Efficiency = profit / sqrt(total stake). Kelly comparison shown when available.</div>
    <div class="muted" id="roi-window-note"></div>
    <div id="roi-metrics-content" class="grid"></div>
  </div>

  <div class="card mt-18" id="roi-diagnostics">
    <h2>ROI Data Diagnostics</h2>
    <div class="muted mb-8">Quick server-side checks to verify required files are available.</div>
    <div id="roi-diag-status" class="muted">Running diagnosticsâ€¦</div>
  </div>

    <div class="card mt-18" id="top-picks-card">
      <h2>Top Picks Today</h2>
      <div class="muted mb-8">Highest confidence and EV at a glance.</div>
      <div id="top-picks-note" class="muted"></div>
      <div id="top-picks"></div>
    </div>


    <div class="card mt-18" id="props-spotlight-card">
      <div class="row-between">
        <h2>Pitcher Props Spotlight</h2>
        <div class="muted" id="props-coverage">Props coverage: â€”</div>
      </div>
      <div class="muted mb-8">Top edges and Kelly sizing from todayâ€™s props (lightweight view). For full details, see the <a href="/pitcher-props">Pitcher Props</a> page.</div>
      <div id="props-spotlight"></div>
    </div>


    <div class="card">
      <h2>Todayâ€™s Recommendations (All)</h2>
      <div class="muted mb-8">Sorted by confidence, then EV. EV shown as percentage.</div>
      <div id="today-note" class="muted"></div>
      <div id="today"></div>
      <div class="mt-16">
        <h3 class="heading-tight">Today Recap</h3>
        <div class="grid" id="today-kpis"></div>
      </div>
      <!-- Day selector toolbar (added) -->
      <div class="toolbar wrap mt-16">
        <label for="hist-day" class="muted">Select day:</label>
        <select id="hist-day" class="input"></select>
        <button class="btn" onclick="loadDayPerformance()">Load Day</button>
      </div>

      <div class="muted mt-8 mb-4">By Confidence (variable stake)</div>
  <div class="grid" id="day-level-grid"></div>
      <div class="mt-16">
        <h3 class="heading-tight">Recommendations for Selected Day</h3>
        <div id="day-recs"></div>
      </div>
    </div>

  <div class="card">
      <div class="muted mb-8">Select a window to see cumulative performance over time.</div>
      <div class="toolbar wrap">
        <label for="range-start" class="muted">Start date:</label>
        <select id="range-start" class="input"></select>
        <label for="range-end" class="muted">End date:</label>
        <select id="range-end" class="input"></select>
        <button class="btn" onclick="loadRangePerformance()">Load Range</button>
      </div>
      <div class="grid" id="range-grid"></div>
  <div class="muted mt-8 mb-4">By Confidence (variable stake)</div>
  <div class="grid" id="range-level-grid"></div>
      <div class="mt-16">
        <h3 class="heading-tight">Recommendations for Selected Range</h3>
        <div id="range-recs"></div>
      </div>
    </div>
          
  </div>

  <script>
    // --- Lightweight fetch with timeout to prevent hangs ---
    async function fetchWithTimeout(url, options = {}, timeoutMs = 12000) {
      const controller = new AbortController();
      const id = setTimeout(() => { try { controller.abort('timeout'); } catch(_) { controller.abort(); } }, timeoutMs);
      const bust = url.includes('?') ? `&_=${Date.now()}` : `?_=${Date.now()}`;
      try{
        return await fetch(url + bust, { ...options, signal: controller.signal });
      } finally {
        clearTimeout(id);
      }
    }
  // Pitcher props code removed to speed up page load
    function fmtPct(n){ return (Number(n)||0).toFixed(1) + '%'; }
    function fmtEV(n){ const v=Number(n); if(!isFinite(v)) return '-'; return (v*100).toFixed(1)+'%'; }
    const confOrder = c => ({'HIGH':3,'MEDIUM':2,'LOW':1}[String(c||'').toUpperCase()]||0);
  const checkIcon = ok => ok===true ? 'âœ…' : ok===false ? 'âŒ' : (ok==='PUSH' ? 'âž–' : '');
    function parseAmericanOdds(od){
      try{
        if(od===null || od===undefined) return -110;
        if(typeof od==='number') return Math.trunc(od);
        let s=String(od).trim();
        if(!s || s.toUpperCase()==='N/A') return -110;
        s=s.replace('âˆ’','-');
        if(s.startsWith('+')) s=s.slice(1);
        return Math.trunc(parseFloat(s));
      }catch(_){ return -110; }
    }
    function parseSideLine(rec){
      if(!rec) return { side:null, line:null };
      const txt = String(rec).trim().toLowerCase();
      let side = null; let line = null;
      // Prefer explicit words
      if(/\bover\b/.test(txt)) side = 'OVER';
      else if(/\bunder\b/.test(txt)) side = 'UNDER';
      // Compact formats like "O9", "O 9", "U8.5", "U 8.5"
      if(!side){
        const mo = txt.match(/(^|[^a-z])o\s*(\d+(?:\.\d+)?)/i);
        if(mo){ side='OVER'; line = Number(mo[2]); }
      }
      if(!side){
        const mu = txt.match(/(^|[^a-z])u\s*(\d+(?:\.\d+)?)/i);
        if(mu){ side='UNDER'; line = Number(mu[2]); }
      }
      // If line still missing, grab the first number
      if(line==null){ const m = txt.match(/(\d+\.?\d*)/); if(m) line = Number(m[1]); }
      return { side, line };
    }
    function normalizeTeamName(s){
      return String(s||'').toLowerCase().replace(/[^a-z0-9]/g,'');
    }
    // Canonicalize common aliases to improve cross-source matching
    function canonTeam(s){
      const t = normalizeTeamName(s);
      const m = {
        // LA teams
        'laangels':'losangelesangels','losangelesangels':'losangelesangels','anaheimangels':'losangelesangels','laa':'losangelesangels',
        'ladodgers':'losangelesdodgers','losangelesdodgers':'losangelesdodgers','lad':'losangelesdodgers',
        // NY teams
        'nyyankees':'newyorkyankees','newyorkyankees':'newyorkyankees','nyy':'newyorkyankees',
        'nymets':'newyorkmets','newyorkmets':'newyorkmets','nym':'newyorkmets',
        // Chicago
        'chiwhitesox':'chicagowhitesox','chicagowhitesox':'chicagowhitesox','chw':'chicagowhitesox','cws':'chicagowhitesox',
        'chicubs':'chicagocubs','chicagocubs':'chicagocubs','chc':'chicagocubs',
        // St. Louis
        'stlouiscardinals':'stlouiscardinals','saintlouiscardinals':'stlouiscardinals','stl':'stlouiscardinals',
        // Boston
        'bostonredsox':'bostonredsox','redsox':'bostonredsox','bos':'bostonredsox',
        // Toronto
        'torontobluejays':'torontobluejays','bluejays':'torontobluejays','tor':'torontobluejays','tbj':'torontobluejays',
        // Tampa Bay
        'tampabayrays':'tampabayrays','rays':'tampabayrays','tampabaydevilrays':'tampabayrays','tb':'tampabayrays','tbr':'tampabayrays',
        // Baltimore
        'baltimoreorioles':'baltimoreorioles','orioles':'baltimoreorioles','bal':'baltimoreorioles',
        // Cleveland
        'clevelandguardians':'clevelandguardians','guardians':'clevelandguardians','clevelandindians':'clevelandguardians','cle':'clevelandguardians','clg':'clevelandguardians',
        // Detroit
        'detroittigers':'detroittigers','tigers':'detroittigers','det':'detroittigers',
        // Kansas City
        'kansascityroyals':'kansascityroyals','royals':'kansascityroyals','kc':'kansascityroyals','kcr':'kansascityroyals',
        // Minnesota
        'minnesotatwins':'minnesotatwins','twins':'minnesotatwins','min':'minnesotatwins',
        // Houston
        'houstonastros':'houstonastros','astros':'houstonastros','hou':'houstonastros',
        // Seattle
        'seattlemariners':'seattlemariners','mariners':'seattlemariners','sea':'seattlemariners',
        // Texas
        'texasrangers':'texasrangers','rangers':'texasrangers','tex':'texasrangers',
        // Atlanta
        'atlantabraves':'atlantabraves','braves':'atlantabraves','atl':'atlantabraves',
        // Miami
        'miamimarlins':'miamimarlins','floridamarlins':'miamimarlins','marlins':'miamimarlins','mia':'miamimarlins','fla':'miamimarlins',
        // Philadelphia
        'philadelphiaphillies':'philadelphiaphillies','phillies':'philadelphiaphillies','phi':'philadelphiaphillies',
        // Washington
        'washingtonnationals':'washingtonnationals','nationals':'washingtonnationals','was':'washingtonnationals','wsn':'washingtonnationals',
        // Arizona
        'arizonadiamondbacks':'arizonadiamondbacks','diamondbacks':'arizonadiamondbacks','ari':'arizonadiamondbacks','az':'arizonadiamondbacks',
        // Colorado
        'coloradorockies':'coloradorockies','rockies':'coloradorockies','col':'coloradorockies',
        // San Diego
        'sandiegopadres':'sandiegopadres','padres':'sandiegopadres','sd':'sandiegopadres','sdp':'sandiegopadres',
        // San Francisco
        'sanfranciscogiants':'sanfranciscogiants','giants':'sanfranciscogiants','sf':'sanfranciscogiants','sfg':'sanfranciscogiants',
        // Milwaukee
        'milwaukeebrewers':'milwaukeebrewers','brewers':'milwaukeebrewers','mil':'milwaukeebrewers',
        // Cincinnati
        'cincinnatireds':'cincinnatireds','reds':'cincinnatireds','cin':'cincinnatireds',
        // Pittsburgh
        'pittsburghpirates':'pittsburghpirates','pirates':'pittsburghpirates','pit':'pittsburghpirates',
  // Oakland
  'oaklandathletics':'oaklandathletics','athletics':'oaklandathletics','oak':'oaklandathletics','as':'oaklandathletics','oaklandas':'oaklandathletics'
      };
      return m[t] || t;
    }
    function normGameKey(game){
      const raw = String(game||'');
      if(raw.includes('@')){
        const parts = raw.split('@');
        return `${canonTeam(parts[0])}@${canonTeam(parts[1])}`;
      }
      return normalizeTeamName(raw);
    }
    function parseMoneylineTeam(pick){
      if(!pick) return null;
      let t = String(pick).replace(/ml$/i,'').replace(/moneyline/i,'').trim();
      return t;
    }
    function gameKey(away, home){ return `${away} @ ${home}`; }
    async function loadPerformance(){
      let data = {};
      try{
        const res=await fetchWithTimeout('/api/betting-guidance/performance', {}, 12000);
        if(!res.ok) throw new Error('HTTP '+res.status);
        data=await res.json();
      }catch(e){ console.warn('performance load error', e); data={}; }
      const perf=data.performance_by_bet_type||{};
      const grid=document.getElementById('perf');
      grid.innerHTML='';
      Object.entries(perf).forEach(([type,stats])=>{
        const div=document.createElement('div'); div.className='stat';
        div.innerHTML=`<div class='num'>${fmtPct(stats.accuracy)}</div><div class='muted'>${type.replace('_',' ').toUpperCase()}</div><div class='muted'>ROI: ${stats.roi?.toFixed(1)||0}% | Profit: $${stats.net_profit?.toFixed(2)||0}</div><div class='muted'>${stats.total_bets} bets (${stats.correct_bets} wins)</div>`;
        grid.appendChild(div);
      });
      loadROIMetricsPanel();
    }

    async function loadROIMetricsPanel(){
      const cont = document.getElementById('roi-metrics-content');
      const sub = document.getElementById('roi-subtitle');
      const note = document.getElementById('roi-window-note');
      try{
        // Try rolling endpoint first (fresh 7-day), exclude today for stability
        let res;
        try{
          res = await fetchWithTimeout('/api/optimization/roi-metrics/rolling?days=7&include_today=false', {}, 15000);
        }catch(e){
          if(e && (e.name === 'AbortError' || String(e).includes('aborted'))){
            res = await fetchWithTimeout('/api/optimization/roi-metrics/rolling?days=7&include_today=false', {}, 15000);
          } else { throw e; }
        }
        let data = await res.json();
        // Fall back to snapshot if rolling missing
        if(!data || !data.roi_metrics){
          const snapRes = await fetchWithTimeout('/api/optimization/roi-metrics', {}, 12000);
          if(snapRes.ok){ data = await snapRes.json(); }
        }
        cont.innerHTML='';
        if(!data || !data.roi_metrics){ cont.innerHTML='<div class="muted">No ROI metrics available yet.</div>'; return; }
        // Update subtitle and window note based on source
        const isRolling = (data && (data.source === 'rolling' || data.window));
        if(sub){ sub.textContent = isRolling ? 'Rolling last 7 days (excl. today). Efficiency = profit / sqrt(total stake). Kelly comparison shown when available.' : 'Weekly snapshot from latest retune. Efficiency = profit / sqrt(total stake).'; }
        if(note){
          if(isRolling && data.window && Array.isArray(data.window.dates_used) && data.window.dates_used.length){
            const ds = data.window.dates_used; note.textContent = `Window: ${ds[0]} â†’ ${ds[ds.length-1]}`;
          } else if(data.latest_weekly_comparison && data.latest_weekly_comparison.window){
            const w = data.latest_weekly_comparison.window; if(w.start && w.end){ note.textContent = `Snapshot window: ${w.start} â†’ ${w.end}`; } else { note.textContent = ''; }
          } else { note.textContent = ''; }
        }
        const rm = data.roi_metrics;
        const confMap = rm.by_confidence || {};
        Object.entries(confMap).forEach(([conf,vals])=>{
          const stake = Number(vals.total_stake||0);
          const profit = Number(vals.total_profit||0);
          const roi = stake>0 ? (profit/stake) : (Number(vals.roi)||0);
          const eff = stake>0 ? (profit/Math.sqrt(stake)) : 0;
          const div=document.createElement('div'); div.className='stat';
          div.innerHTML = `<div class='num'>${(roi*100).toFixed(1)}%</div>
            <div class='muted'>${String(conf).toUpperCase()} ROI</div>
            <div class='muted'>Profit $${profit.toFixed(2)} / Stake $${stake.toFixed(0)}</div>
            <div class='muted'>Eff: ${eff.toFixed(3)} | W:${vals.wins||0} L:${vals.losses||0} P:${vals.pushes||0}</div>`;
          cont.appendChild(div);
        });
        // Kelly vs Fixed Stake summary if present
        if(rm.kelly_comparison){
          const kc = rm.kelly_comparison;
          const div=document.createElement('div'); div.className='stat';
          div.style.background='#eef7ff';
          const kROI = Number(kc.kelly_roi||0), fROI = Number(kc.fixed_roi||0);
          const kP = Number(kc.kelly_profit||0), fP = Number(kc.fixed_profit||0);
          div.innerHTML = `<div class='num'>Kelly vs Fixed</div>
            <div class='muted'>Kelly ROI: ${(kROI*100).toFixed(1)}% ($${kP.toFixed(2)})</div>
            <div class='muted'>Fixed ROI: ${(fROI*100).toFixed(1)}% ($${fP.toFixed(2)})</div>
            <div class='muted'>Edge: ${((kROI - fROI)*100).toFixed(1)} pts</div>`;
          cont.appendChild(div);
        }
      }catch(e){
        console.error('ROI metrics panel error', e);
        if(cont && (!cont.innerHTML || !cont.innerHTML.trim())){
          cont.innerHTML = '<div class="muted">ROI metrics failed to load. Check /api/optimization/roi-metrics/rolling and /api/debug-data-files.</div>';
        }
      }
    }

    // --- ROI diagnostics panel ---
    async function loadRoiDiagnostics(){
      const el = document.getElementById('roi-diag-status');
      if(!el) return;
      try{
        // Fetch rolling ROI to see dates used
        const r = await fetchWithTimeout('/api/optimization/roi-metrics/rolling?days=7&include_today=false', {}, 12000);
        const rolling = r.ok ? await r.json() : null;
        const datesUsed = rolling && rolling.window && Array.isArray(rolling.window.dates_used) ? rolling.window.dates_used : [];
        const latestEnd = rolling && rolling.window ? rolling.window.end_date : null;
        const hasMetrics = !!(rolling && rolling.roi_metrics);
        // Fetch debug-data-files to confirm presence of required files
        const d = await fetchWithTimeout('/api/debug-data-files', {}, 12000);
        const dbg = d.ok ? await d.json() : null;
        const files = (dbg && Array.isArray(dbg.files)) ? dbg.files : [];
        const hasAnyRecs = files.some(f => typeof f.name === 'string' && f.name.startsWith('betting_recommendations_'));
        const hasAnyFinals = files.some(f => typeof f.name === 'string' && f.name.startsWith('final_scores_'));
        // Build concise status
        const parts = [];
        parts.push(`Rolling ROI: ${hasMetrics ? 'OK' : 'Missing'}`);
        if(datesUsed && datesUsed.length){ parts.push(`Dates used: ${datesUsed[0]} â†’ ${datesUsed[datesUsed.length-1]}`); }
        if(latestEnd){ parts.push(`End date: ${latestEnd}`); }
        parts.push(`Files: recs ${hasAnyRecs ? 'present' : 'missing'}, finals ${hasAnyFinals ? 'present' : 'missing'}`);
        el.textContent = parts.join(' | ');
      }catch(e){
        el.textContent = 'Diagnostics failed to run';
      }
    }
    async function loadToday(){
      // Fetch recommendations for today or fallback to latest available date
      const noteEl = document.getElementById('today-note');
      if(noteEl) noteEl.textContent = '';
      const { dateUsed, data } = await fetchRecsForDateOrFallback();
      if(noteEl && dateUsed !== todayISO()){
        noteEl.textContent = `Using latest available date: ${dateUsed}`;
      }
      const div = document.getElementById('today');
      const recs = data.recommendations || [];
      if(!recs.length){ div.innerHTML='<div class="muted">No recommendations available.</div>'; return; }

      // Helper to normalize type and build a clean bet label
      const buildBet = (r)=>{
        let type = String(r.type||'').toLowerCase();
        if(type==='over/under' || type.startsWith('total')) type='total';
        if(type==='ml' || type.startsWith('moneyline')) type='moneyline';
        if(type.startsWith('run')) type='run_line';

        const pickRaw = (r.recommendation!=null && String(r.recommendation).trim()!=='' ? r.recommendation : (r.pick!=null ? r.pick : r.side)) || '';
        const typeLabel = String(type||'').replace('_',' ').toUpperCase();

        if(type==='total'){
          // Parse side and line from recommendation and fallbacks
          let side=null, line=null;
          const p1 = parseSideLine(String(pickRaw)); if(p1.side) side=p1.side; if(p1.line!=null) line=Number(p1.line);
          if(line==null && r.betting_line!=null) line = Number(r.betting_line);
          if(line==null && r.line!=null) line = Number(r.line);
          if(line==null && r.total_line!=null) line = Number(r.total_line);
          if(!side){
            const p2 = parseSideLine(String(r.side||r.pick||''));
            if(p2.side) side=p2.side;
            if(p2.line!=null && line==null) line=Number(p2.line);
          }
          const parts = [typeLabel, side||'', (line!=null && !Number.isNaN(Number(line))) ? String(line) : ''];
          return parts.join(' ').trim().replace(/\s+/g,' ');
        }
        if(type==='moneyline'){
          const pickTxt = String(pickRaw||'').trim();
          return (typeLabel + (pickTxt ? (' ' + pickTxt) : '')).trim();
        }
        // Default fallback
        const pickTxt = String(pickRaw||'').trim();
        return (typeLabel + (pickTxt ? (' ' + pickTxt) : '')).trim();
      };

      // Filter out NONE / no-recommendation entries and build rows
  const rows = recs
        .filter(r=>{
          const txt = String(r.recommendation||r.pick||r.side||'').toLowerCase();
          const t = String(r.type||'').toLowerCase();
          if(t==='none') return false;
          if(!txt) return false;
          if(txt==='none' || txt.includes('no recommendation')) return false;
          return true;
        })
        .map(r=>{
          const oddsVal = r.american_odds ?? r.odds;
          return {
            game: r.game || `${r.away_team||''} @ ${r.home_team||''}`,
            bet: buildBet(r),
            odds: (oddsVal===null || oddsVal===undefined || oddsVal==='') ? 'â€”' : oddsVal,
            conf: String(r.confidence||'').toUpperCase(),
    ev: r.expected_value,
    _orig: r
          };
        });
      rows.sort((a,b)=> confOrder(b.conf)-confOrder(a.conf) || (Number(b.ev||0)-Number(a.ev||0)));
      div.innerHTML = '<div class="table-wrap"><table class="table"><thead><tr><th>Game</th><th>Bet</th><th>Odds</th><th>Conf</th><th>EV</th></tr></thead><tbody>' +
        rows.map(r=>`<tr><td>${r.game}</td><td>${r.bet}</td><td>${r.odds}</td><td><span class="badge ${r.conf}">${r.conf}</span></td><td>${fmtEV(r.ev)}</td></tr>`).join('') +
      '</tbody></table></div>';

    // Build Today Recap KPIs based on THESE recs only (so counts match what you see) and the date used
  await loadTodayRecap(rows.map(r=> r._orig), dateUsed);
    }

    async function loadTopPicksToday(){
      const cont = document.getElementById('top-picks');
      const noteEl = document.getElementById('top-picks-note');
      if(cont && (!cont.innerHTML || !cont.innerHTML.trim())){
        cont.innerHTML = '<div class="muted">Loading top picksâ€¦</div>';
      }
      try{
        const { dateUsed, data } = await fetchRecsForDateOrFallback();
        if(noteEl){ noteEl.textContent = (dateUsed !== todayISO()) ? (`Using latest available date: ${dateUsed}`) : ''; }
        const recs = data.recommendations || [];
        const confOrder = c => ({'HIGH':3,'MEDIUM':2,'LOW':1}[String(c||'').toUpperCase()]||0);
        const buildBet = (r)=>{
          let type = String(r.type||'').toLowerCase();
          if(type==='over/under' || type.startsWith('total')) type='total';
          if(type==='ml' || type.startsWith('moneyline')) type='moneyline';
          if(type.startsWith('run')) type='run_line';
          const pickRaw = (r.recommendation!=null && String(r.recommendation).trim()!=='' ? r.recommendation : (r.pick!=null ? r.pick : r.side)) || '';
          const typeLabel = String(type||'').replace('_',' ').toUpperCase();
          if(type==='total'){
            let side=null, line=null;
            const p1 = parseSideLine(String(pickRaw)); if(p1.side) side=p1.side; if(p1.line!=null) line=Number(p1.line);
            if(line==null && r.betting_line!=null) line = Number(r.betting_line);
            if(line==null && r.line!=null) line = Number(r.line);
            if(line==null && r.total_line!=null) line = Number(r.total_line);
            if(!side){ const p2 = parseSideLine(String(r.side||r.pick||'')); if(p2.side) side=p2.side; if(p2.line!=null && line==null) line=Number(p2.line); }
            return `${typeLabel} ${side||''} ${line!=null? String(line): ''}`.trim().replace(/\s+/g,' ');
          }
          if(type==='moneyline'){
            const pickTxt = String(pickRaw||'').trim();
            return (typeLabel + (pickTxt ? (' ' + pickTxt) : '')).trim();
          }
          const pickTxt = String(pickRaw||'').trim();
          return (typeLabel + (pickTxt ? (' ' + pickTxt) : '')).trim();
        };
        const rows = recs
          .filter(r=>{ const t=String(r.type||'').toLowerCase(); const txt=String(r.recommendation||r.pick||r.side||'').toLowerCase(); if(t==='none') return false; if(!txt) return false; if(txt==='none' || txt.includes('no recommendation')) return false; return true; })
          .map(r=>({
            game: r.game || `${r.away_team||''} @ ${r.home_team||''}`,
            bet: buildBet(r),
            odds: (r.american_odds ?? r.odds),
            conf: String(r.confidence||'').toUpperCase(),
            ev: r.expected_value
          }));
        rows.sort((a,b)=> confOrder(b.conf)-confOrder(a.conf) || (Number(b.ev||0)-Number(a.ev||0)));
        const top = rows.slice(0,5);
        if(!top.length){ cont.innerHTML = '<div class="muted">No picks available.</div>'; return; }
        cont.innerHTML = '<div class="table-wrap"><table class="table compact">'
          + '<thead><tr><th>Game</th><th>Bet</th><th>Odds</th><th>Conf</th><th>EV</th></tr></thead><tbody>'
          + top.map(r=>`<tr><td>${r.game}</td><td>${r.bet}</td><td>${r.odds ?? ''}</td><td><span class="badge ${r.conf}">${r.conf}</span></td><td>${fmtEV(r.ev)}</td></tr>`).join('')
          + '</tbody></table></div>';
      }catch(_){ if(cont) cont.innerHTML = '<div class="muted">Unable to load top picks.</div>'; }
    }

    // --- Props Spotlight (lightweight) ---
    async function loadPropsCoverageChip(){
      try{
        const res = await fetchWithTimeout('/api/props/progress', {}, 8000);
        if(!res.ok) return;
        const j = await res.json();
        const d = (j && j.data) || {};
        const pct = (Number(d.coverage_percent)||0).toFixed(0);
        const el = document.getElementById('props-coverage');
        if(el){
          const normZ = (s)=>{ try{ if(!s) return null; const t=String(s); if(/Z$|[+\-]\d{2}:?\d{2}$/.test(t)) return t; return t+'Z'; }catch(_){ return s; } };
          let txt = `Props coverage: ${pct}%`;
          if(d.all_games_started) txt += ' â€¢ all games started';
          const upd = d.updated_at ? new Date(normZ(d.updated_at)).toLocaleTimeString() : '';
          if(upd) txt += ` â€¢ Updated ${upd}`;
          el.textContent = txt;
        }
      }catch(_){ /* ignore */ }
    }

    async function loadPropsSpotlight(){
      const cont = document.getElementById('props-spotlight');
      if(cont && (!cont.innerHTML || !cont.innerHTML.trim())){
        cont.innerHTML = '<div class="muted">Loading propsâ€¦</div>';
      }
      // Helper to build table HTML from unified props payload
      const buildRows = (j)=>{
        const dataObj = (j && j.data && typeof j.data==='object') ? j.data : {};
        const vals = Array.isArray(j?.items) ? j.items : Object.values(dataObj || {});
        const rows = [];
        for(const v of vals){
          try{
            // Prefer explicit primary play; else synthesize from markets (highest Kelly)
            let p = v && v.plays ? v.plays : null;
            const markets = (v && v.markets && typeof v.markets==='object') ? v.markets : null;
            if(!p && markets){
              let best = null;
              for(const [mkKey, info] of Object.entries(markets)){
                if(!info || typeof info!=='object') continue;
                const ko = Number(info.kelly_over||0);
                const ku = Number(info.kelly_under||0);
                const sideSynth = (ko>=ku) ? 'OVER' : 'UNDER';
                const kSynth = Math.max(ko, ku);
                const lineSynth = (info.line!=null ? info.line : null);
                const edgeSynth = (Number.isFinite(info.edge) ? Number(info.edge) : null);
                const cand = {market: mkKey, side: sideSynth, kelly_fraction: kSynth, line: lineSynth, edge: edgeSynth, over_odds: info.over_odds, under_odds: info.under_odds};
                if(!best || (kSynth > (best.kelly_fraction||0)) || (kSynth===(best.kelly_fraction||0) && Math.abs(edgeSynth||0) > Math.abs(best.edge||0))){
                  best = cand;
                }
              }
              if(best){ p = best; }
            }
            if(!p) continue;
            const side = String(p.side||'').toUpperCase();
            const mk = p.market;
            let odds = null, line = null;
            const mkObj = (markets && mk && markets[mk]) ? markets[mk] : null;
            if(side==='OVER') odds = (p.over_odds!=null ? p.over_odds : (mkObj ? mkObj.over_odds : null));
            else if(side==='UNDER') odds = (p.under_odds!=null ? p.under_odds : (mkObj ? mkObj.under_odds : null));
            line = (p.line!=null ? p.line : (mkObj ? mkObj.line : null));
            const kelly = Number(p.kelly_fraction||0);
            const edge = Number(p.edge||0);
            rows.push({
              name: (v && (v.display_name||v.raw_key)) || 'Pitcher',
              team: (v && v.team) || '',
              opp: (v && v.opponent) || '',
              market: mk,
              side,
              line,
              edge,
              kelly,
              odds
            });
          }catch(_){ /* ignore row errors */ }
        }
        rows.sort((a,b)=> (Number(b.kelly)-Number(a.kelly)) || (Math.abs(Number(b.edge))-Math.abs(Number(a.edge))));
        return rows;
      };
      try{
        let res = await fetchWithTimeout('/api/pitcher-props/unified?light=1', {}, 15000);
        if(!res.ok){
          res = await fetchWithTimeout('/api/pitcher-props/unified?light=1&allow_fallback=1', {}, 15000);
        }
        let j = null;
        try { j = await res.json(); } catch(_){ j = null; }
        let meta = (j && typeof j.meta==='object') ? j.meta : {};
        let rows = j ? buildRows(j) : [];
        if(!rows.length){
          try{
            const fres = await fetchWithTimeout('/api/pitcher-props/unified?light=1&allow_fallback=1', {}, 15000);
            if(fres.ok){ const fj = await fres.json(); meta = (fj && typeof fj.meta==='object') ? fj.meta : {}; rows = buildRows(fj); }
          }catch(_){ /* ignore */ }
        }
        if(!rows.length){
          try{
            const fullRes = await fetchWithTimeout('/api/pitcher-props/unified', {}, 20000);
            if(fullRes.ok){ const fullJ = await fullRes.json(); meta = (fullJ && typeof fullJ.meta==='object') ? fullJ.meta : meta; rows = buildRows(fullJ); }
          }catch(_){ /* ignore */ }
        }
        const top = rows.slice(0, 10);
        if(!top.length){ cont.innerHTML = '<div class="muted">No standout props at the moment.</div>'; return; }
        // Helper to annotate synthesized and stale
        const isSynth = !!(meta && (meta.synthesized===true));
        const staleFor = (r)=>{
          try{
            const lines = (j && j.data && j.data[r.name?.toLowerCase?.()]) ? j.data[r.name.toLowerCase()] : null;
            const mkey = r.market;
            // Prefer explicit stale flag from lines map when available
            const ln = (lines && lines.lines && mkey && lines.lines[mkey]) ? lines.lines[mkey] : null;
            return !!(ln && ln._stale===true);
          }catch(_){ return false; }
        };
        let html = '<div class="table-wrap"><table class="table">'
          + '<thead><tr><th>Pitcher</th><th>Matchup</th><th>Market</th><th>Side</th><th>Line</th><th>Edge</th><th>Kelly</th><th>Odds</th><th></th><th></th></tr></thead><tbody>'
          + top.map(r=>{
              const badges = [];
              if(isSynth) badges.push('<span class="badge muted">SYNTH</span>');
              if(staleFor(r)) badges.push('<span class="badge muted">STALE</span>');
              const q = new URLSearchParams({ player: r.name||'', market: r.market||'' }).toString();
              return `<tr>
                <td>${r.name}</td>
                <td>${r.team ? r.team : ''}${r.opp ? (' vs ' + r.opp) : ''}</td>
                <td>${r.market||''}</td>
                <td>${r.side||''}</td>
                <td>${r.line!=null ? r.line : ''}</td>
                <td>${(Number.isFinite(r.edge)? r.edge.toFixed(2) : '')}</td>
                <td>${(Number.isFinite(r.kelly)? (r.kelly*100).toFixed(1)+'%' : '')}</td>
                <td>${r.odds!=null ? r.odds : ''}</td>
                <td>${badges.join(' ')}</td>
                <td><a class="btn-link" href="/pitcher-props?${q}" title="Open in Props">Open</a></td>
              </tr>`;
            }).join('')
          + '</tbody></table></div>';
        if(meta && (meta.synthesized || (meta.source_date && meta.requested_date && meta.source_date!==meta.requested_date))){
          const src = meta.source_date||meta.requested_date||'';
          html += `<div class="muted mt-6">Using fallback data${src?` â€¢ source date ${src}`:''}</div>`;
        }
        cont.innerHTML = html;
      }catch(_e){ if(cont) cont.innerHTML = '<div class="muted">Failed to load props spotlight.</div>'; }
    }
    async function loadAvailableDates(){
      try{
        const res=await fetchWithTimeout('/api/historical-analysis/available-dates', {}, 12000);
        const data=await res.json();
        const sel=document.getElementById('hist-day');
        // Historical proxy returns { dates: [...] }
        const dates = (data.dates || data.available_dates || []);
        // Sort dates ascending to keep behavior stable, then select the latest
        dates.sort();
        if(sel){
          sel.innerHTML='';
          dates.forEach(dt=>{ const o=document.createElement('option'); o.value=dt; o.textContent=dt; sel.appendChild(o); });
          // Auto-select previous day by default when available (avoid showing "today" settlements early)
          if(dates.length){
            const todayS = todayISO();
            let def = dates[dates.length-1];
            for(let i=dates.length-1;i>=0;i--){ if(dates[i] < todayS){ def = dates[i]; break; } }
            sel.value = def;
          }
        }

  // Populate range selectors
  const rs = document.getElementById('range-start');
  const re = document.getElementById('range-end');
  rs.innerHTML = ''; re.innerHTML = '';
  dates.forEach(dt=>{
    const o1=document.createElement('option'); o1.value=dt; o1.textContent=dt; rs.appendChild(o1);
    const o2=document.createElement('option'); o2.value=dt; o2.textContent=dt; re.appendChild(o2);
  });
  if(dates.length){
    // Default to current month range, but end at previous day when available
    const now = new Date();
    const z = n=>String(n).padStart(2,'0');
    const prefix = `${now.getFullYear()}-${z(now.getMonth()+1)}-`;
    const monthDates = dates.filter(d=> d.startsWith(prefix));
    const todayS = todayISO();
    const lastBeforeToday = (arr)=>{
      for(let i=arr.length-1;i>=0;i--){ if(arr[i] < todayS) return arr[i]; }
      return arr.length ? arr[arr.length-1] : null;
    };
    if(monthDates.length){
      rs.value = monthDates[0];
      re.value = lastBeforeToday(monthDates) || monthDates[monthDates.length-1];
    } else {
      // Fallback to full available range
      rs.value = dates[0];
      re.value = lastBeforeToday(dates) || dates[dates.length-1];
    }
  }

  // Auto-load Day and Range sections now that selectors are populated
  try { await loadDayPerformance(); } catch(_) {}
  try { await loadRangePerformance(); } catch(_) {}
  try { await loadRoiDiagnostics(); } catch(_) {}
  // Also show spotlight health
  try {
    const sh = await fetchWithTimeout('/api/props/spotlight-health', {}, 6000);
    if(sh.ok){
      const sj = await sh.json();
      const el = document.getElementById('roi-diag-status');
      if(el){
        const prev = el.innerHTML || el.textContent || '';
        if(sj.available){
          const syn = sj.synthesized ? 'yes' : 'no';
          el.innerHTML = `${prev}<br/><span class="muted">Spotlight rows: ${sj.pitchers ?? '?'} â€¢ synthesized: ${syn}${sj.source_date && sj.requested_date && sj.source_date!==sj.requested_date ? (' â€¢ source ' + sj.source_date) : ''}</span>`;
        } else {
          el.innerHTML = `${prev}<br/><span class="muted">Spotlight cache: not yet built</span>`;
        }
      }
    }
  } catch(_) {}
      }catch(e){ console.warn('Failed to load available dates', e); }
    }
    function todayISO(){ const d=new Date(); const z=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}`; }
  function yesterdayISO(){ const d=new Date(); d.setDate(d.getDate()-1); const z=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}`; }
  // Helper: fetch today's recommendations or fallback to latest available historical date
  async function fetchRecsForDateOrFallback(){
    const today = todayISO();
    // Try today first
    try{
      const res = await fetchWithTimeout(`/api/betting-recommendations/date/${today}`, {}, 12000);
      if(res.ok){
        const j = await res.json();
        if(Array.isArray(j.recommendations) && j.recommendations.length){
          return { dateUsed: today, data: j, fallback: false };
        }
      }
    }catch(_){ /* ignore and fallback */ }
    // Fallback to the latest available recommendations directly from disk
    try{
      const r2 = await fetchWithTimeout('/api/betting-recommendations/latest', {}, 12000);
      if(r2.ok){
        const j2 = await r2.json();
        const used = j2.date_used || today;
        return { dateUsed: used, data: { recommendations: j2.recommendations || [] }, fallback: used !== today };
      }
    }catch(_){ /* ignore */ }
    return { dateUsed: today, data: { recommendations: [] }, fallback: true };
  }
  // Kelly details now live on the dedicated page via link above
  async function loadTodayRecap(recs, dateForRecap){
      const grid = document.getElementById('today-kpis'); grid.innerHTML='';
      try{
        // Pull historical analysis for today to evaluate correctness using final scores (and evaluated maps)
  const res = await fetchWithTimeout(`/api/historical-analysis/date/${(dateForRecap || todayISO())}`, {}, 10000);
        if(!res.ok){
          // If historical API not available for today yet, show neutral tiles based on rec count only
          const tiles=[
            {label:'Rec Accuracy', val:'0.0%'},
            {label:'Total Recs', val: (recs?.length||0)},
            {label:'ROI %', val:'0.0%'},
            {label:'Net Profit', val:'$0.00'}
          ];
          tiles.forEach(t=>{ const d=document.createElement('div'); d.className='stat'; d.innerHTML=`<div class='num'>${t.val}</div><div class='muted'>${t.label}</div>`; grid.appendChild(d); });
          return;
        }
        const raw = await res.json();
        const data = raw && raw.data ? raw.data : raw;

        // Build evaluated correctness maps (type+side+line) and fallback final scores from ROI game results
        const evalCorrectness = new Map();
        const evalSideOnly = new Map();
        const evals = (data.betting_recommendations && data.betting_recommendations.recommendations_evaluated) || [];
        evals.forEach(e=>{
          try{
            const game = `${e.away_team} @ ${e.home_team}`;
            let type = String(e.bet_type||'').toLowerCase();
            if(type.startsWith('total')) type='total';
            if(type.startsWith('moneyline')||type==='ml') type='moneyline';
            if(type.startsWith('run')) type='run_line';
            const recTxt = String(e.recommendation||'').trim();
            let sideBase=null, lineVal=null;
            if(type==='total'){
              const parsed = parseSideLine(recTxt); sideBase=parsed.side; lineVal=parsed.line;
            } else if(type==='moneyline'){
              const teamPick = parseMoneylineTeam(recTxt);
              const tp = canonTeam(teamPick);
              if(tp){
                if(tp===canonTeam(e.away_team)) sideBase='AWAY';
                else if(tp===canonTeam(e.home_team)) sideBase='HOME';
              }
            }
            const key = `${game}|${type}|${(sideBase||'').toUpperCase()}|${lineVal!=null? Number(lineVal): ''}`;
            if(sideBase && (lineVal!=null || type!=='total')) evalCorrectness.set(key, !!e.bet_won);
            const skey = `${game}|${type}|${(sideBase||'').toUpperCase()}|*`; if(sideBase) evalSideOnly.set(skey, !!e.bet_won);
          }catch(_){ /* ignore */ }
        });

        const finalScores = new Map();
        const gr = (data.roi_analysis && data.roi_analysis.game_results) || [];
        gr.forEach(g=>{
          const gname = `${g.away_team} @ ${g.home_team}`;
          let away=0, home=0; if(g.final_score){ const p=String(g.final_score).split('-'); if(p.length===2){ away=Number(p[0]); home=Number(p[1]); } }
          finalScores.set(gname, {away_team:g.away_team, home_team:g.home_team, away_score:away, home_score:home});
        });

        // Evaluate only the recs shown today
        const unit=100;
        let resolved=0, wins=0, profit=0;
        recs.forEach(r=>{
          const game = r.game || `${r.away_team||''} @ ${r.home_team||''}`;
          let type = String(r.type||'').toLowerCase();
          if(type==='over/under' || type.startsWith('total')) type='total';
          if(type==='ml' || type.startsWith('moneyline')) type='moneyline';
          if(type.startsWith('run')) type='run_line';
          const pick = r.recommendation || '';
          let side=null, line=null;
          if(type==='total'){
            const parsed = parseSideLine(pick); side=parsed.side; line = parsed.line ?? (r.betting_line!=null? Number(r.betting_line): null);
          } else if(type==='moneyline'){
            const teamPick = parseMoneylineTeam(pick);
            if(teamPick){
              const tp = canonTeam(teamPick);
              const awayName = r.away_team ? canonTeam(r.away_team) : null;
              const homeName = r.home_team ? canonTeam(r.home_team) : null;
              if(awayName && tp===awayName) side='AWAY'; else if(homeName && tp===homeName) side='HOME';
            }
          }
          const sideKey=(side||'').toUpperCase();
          const key = `${game}|${type}|${sideKey}|${line!=null? Number(line): ''}`;
          let correct = evalCorrectness.has(key) ? evalCorrectness.get(key) : undefined;
          if(correct===undefined && type==='total'){ const wkey = `${game}|${type}|${sideKey}|*`; if(evalSideOnly.has(wkey)) correct = evalSideOnly.get(wkey); }
          if(correct===undefined && finalScores.has(game)){
            const fs = finalScores.get(game);
            if(type==='total' && sideKey && (line!=null)){
              const total = Number(fs.away_score)+Number(fs.home_score);
              if(!isNaN(total)){
                const ln = Number(line);
                if(total===ln) correct = 'PUSH'; else correct = sideKey==='OVER' ? (total>ln) : (total<ln);
              }
            } else if(type==='moneyline'){ const winner = (Number(fs.away_score) > Number(fs.home_score)) ? 'AWAY' : 'HOME'; if(sideKey==='AWAY'||sideKey==='HOME') correct = (sideKey===winner); }
          }
          if(correct!==undefined){
            if(correct!=='PUSH'){ resolved += 1; if(correct===true) wins += 1; }
            const odds = parseAmericanOdds(r.american_odds ?? r.odds);
            if(correct===true){ profit += odds>0 ? (unit * odds/100) : (unit * 100/Math.abs(odds)); }
            else if (correct===false) { profit -= unit; }
          }
        });

        const accPct = resolved ? (wins/resolved*100) : 0;
        const totalBet = resolved * 100;
        const roiPct = totalBet ? (profit/totalBet*100) : 0;
        const tiles=[
          {label:'Rec Accuracy', val: accPct.toFixed(1)+'%'},
          {label:'Total Recs', val: (recs?.length||0)},
          {label:'ROI %', val: roiPct.toFixed(1)+'%'},
          {label:'Net Profit', val: '$'+profit.toFixed(2)}
        ];
        tiles.forEach(t=>{ const d=document.createElement('div'); d.className='stat'; d.innerHTML=`<div class='num'>${t.val}</div><div class='muted'>${t.label}</div>`; grid.appendChild(d); });
      }catch(e){ console.warn('Failed to load today recap', e); }
    }
    async function loadDayPerformance(){
      const day=document.getElementById('hist-day').value; if(!day) return;
      const res=await fetchWithTimeout(`/api/historical-analysis/date/${day}`, {}, 15000);
      let data = {};
      if(res.ok){
        const raw=await res.json();
        data = raw && raw.data ? raw.data : raw;
      } else {
        // Proceed with minimal data; we'll rely on per-day recs and final-scores route if present
        data = {};
      }
  const grid=document.getElementById('day-grid'); grid.innerHTML='';
      // Ensure the recommendations container shows a loading state immediately
      // Build recommendations table pulling directly from the per-day betting recommendations file
      const recDiv = document.getElementById('day-recs');
      if(recDiv && (!recDiv.innerHTML || !recDiv.innerHTML.trim())){
        recDiv.innerHTML = '<div class="muted">Loading recommendationsâ€¦</div>';
      }
      try{
        // 1) Primary source: evaluated recommendations from historical API
        // Build correctness map from data.betting_recommendations.recommendations_evaluated
        const evalCorrectness = new Map();
        const evalSideOnly = new Map(); // key = game|type|SIDE|*
        const evals = (data.betting_recommendations && data.betting_recommendations.recommendations_evaluated) || [];
        evals.forEach(e=>{
          try{
            const game = `${e.away_team} @ ${e.home_team}`;
            // Normalize type
            let type = String(e.bet_type||'').toLowerCase();
            if(type.startsWith('total')) type = 'total';
            if(type.startsWith('moneyline') || type==='ml') type = 'moneyline';
            if(type.startsWith('run')) type = 'run_line';
            const recTxt = String(e.recommendation||'').trim();
            let sideBase=null, lineVal=null;
            if(type==='total'){
              const parsed = parseSideLine(recTxt);
              sideBase = parsed.side; lineVal = parsed.line;
            } else if(type==='moneyline'){
              const teamPick = parseMoneylineTeam(recTxt);
              const tp = canonTeam(teamPick);
              if(tp){
                if(tp===canonTeam(e.away_team)) sideBase='AWAY';
                else if(tp===canonTeam(e.home_team)) sideBase='HOME';
              }
            }
            const key = `${game}|${type}|${(sideBase||'').toUpperCase()}|${lineVal!=null? Number(lineVal): ''}`;
            const nkey = `${normGameKey(game)}|${type}|${(sideBase||'').toUpperCase()}|${lineVal!=null? Number(lineVal): ''}`;
            if(sideBase && (lineVal!=null || type!=='total')){
              evalCorrectness.set(key, !!e.bet_won);
              evalCorrectness.set(nkey, !!e.bet_won);
            }
            const skey = `${game}|${type}|${(sideBase||'').toUpperCase()}|*`;
            const nskey = `${normGameKey(game)}|${type}|${(sideBase||'').toUpperCase()}|*`;
            if(sideBase){ evalSideOnly.set(skey, !!e.bet_won); evalSideOnly.set(nskey, !!e.bet_won); }
          }catch(_){/* ignore single eval parse errors */}
        });

        // 2) Secondary source: game cards recommendations map
        // Build correctness map from historical cards: key = game|type|SIDE|line and side-only wildcard
        const correctness = new Map();
        const sideOnlyCorrectness = new Map(); // key = game|type|SIDE|*
        const cards = data.game_cards || [];
        cards.forEach(card=>{
          const g = gameKey(card.away_team, card.home_team);
          const ng = normGameKey(g);
          (card.recommendations||[]).forEach(r=>{
            // Normalize type
            let type = String(r.type||'').toLowerCase();
            if(type.startsWith('total')) type = 'total';
            if(type.startsWith('moneyline')) type = 'moneyline';
            if(type.startsWith('run')) type = 'run_line';

            // Normalize side and line from historical card
      const rawSide = String((r.side!=null && r.side!=='') ? r.side : (r.pick!=null ? r.pick : r.recommendation||'')).trim();
            let sideBase = null;
            let lineVal = null;
            // Try to parse totals
            const parsed = parseSideLine(rawSide);
            if(parsed.side){ sideBase = parsed.side; }
            if(parsed.line != null){ lineVal = Number(parsed.line); }
            // If still missing, use fields
            if((lineVal==null || isNaN(lineVal)) && (r.line!=null && r.line!=='')) lineVal = Number(r.line);
            // Moneyline: map team text to HOME/AWAY if present
            if(type==='moneyline' && !sideBase){
              const rsn = normalizeTeamName(rawSide);
              if(rsn){
                if(rsn === normalizeTeamName(card.away_team)) sideBase = 'AWAY';
                else if(rsn === normalizeTeamName(card.home_team)) sideBase = 'HOME';
              }
              // Also accept explicit keywords
              const low = rawSide.toLowerCase();
              if(!sideBase && low.includes('away')) sideBase = 'AWAY';
              if(!sideBase && low.includes('home')) sideBase = 'HOME';
            }

  const key = `${g}|${type}|${(sideBase||'').toUpperCase()}|${lineVal}`;
  const nkey = `${ng}|${type}|${(sideBase||'').toUpperCase()}|${lineVal}`;
  const hasLine = (lineVal!==null && !Number.isNaN(Number(lineVal)));
  if(hasLine){ correctness.set(key, r.is_correct); correctness.set(nkey, r.is_correct); }
    const skey = `${g}|${type}|${(sideBase||'').toUpperCase()}|*`;
    const nskey = `${ng}|${type}|${(sideBase||'').toUpperCase()}|*`;
  sideOnlyCorrectness.set(skey, r.is_correct);
  sideOnlyCorrectness.set(nskey, r.is_correct);
          });
        });

  const recRes = await fetchWithTimeout(`/api/betting-recommendations/date/${day}`, {}, 10000);
  if (recRes.ok) {
          const recData = await recRes.json();
          const recs = recData.recommendations || [];
          // Build final scores map (prefer direct API, fallback to ROI game results and game cards)
          const finalScores = new Map();
          try{
            // Fetch same-day final scores
            const fsRes = await fetchWithTimeout(`/api/historical-analysis/final-scores/${day}`, {}, 8000);
            if(fsRes.ok){
              const fsData = await fsRes.json();
              const fs = fsData.final_scores || {};
              Object.values(fs).forEach(s=>{
                const awayName = s.away_team_display || s.away_team;
                const homeName = s.home_team_display || s.home_team;
                if(!awayName || !homeName) return;
                const gname = gameKey(awayName, homeName);
                const a = Number(s.away_score), h = Number(s.home_score);
                if(!isNaN(a) && !isNaN(h)){
                  finalScores.set(gname, {away_team:awayName, home_team:homeName, away_score:a, home_score:h});
                  finalScores.set(normGameKey(gname), {away_team:awayName, home_team:homeName, away_score:a, home_score:h});
                }
              });
            }
            // Merge next-day finals first (common for late games saved under next calendar date)
            const d0 = new Date(day + 'T00:00:00Z');
            const z = n=> String(n).padStart(2,'0');
            const next = new Date(d0.getTime() + 24*60*60*1000);
            const nextStr = `${next.getUTCFullYear()}-${z(next.getUTCMonth()+1)}-${z(next.getUTCDate())}`;
            const fsResNext = await fetchWithTimeout(`/api/historical-analysis/final-scores/${nextStr}`, {}, 8000);
            if(fsResNext.ok){
              const fsDataN = await fsResNext.json();
              const fsN = fsDataN.final_scores || {};
              Object.values(fsN).forEach(s=>{
                const awayName = s.away_team_display || s.away_team;
                const homeName = s.home_team_display || s.home_team;
                if(!awayName || !homeName) return;
                const gname = gameKey(awayName, homeName);
                const a = Number(s.away_score), h = Number(s.home_score);
                if(!isNaN(a) && !isNaN(h)){
                  if(!finalScores.has(gname) && !finalScores.has(normGameKey(gname))){
                    finalScores.set(gname, {away_team:awayName, home_team:homeName, away_score:a, home_score:h});
                    finalScores.set(normGameKey(gname), {away_team:awayName, home_team:homeName, away_score:a, home_score:h});
                  }
                }
              });
            }

            // Then merge previous-day finals
            const prev = new Date(d0.getTime() - 24*60*60*1000);
            const prevStr = `${prev.getUTCFullYear()}-${z(prev.getUTCMonth()+1)}-${z(prev.getUTCDate())}`;
            const fsResPrev = await fetchWithTimeout(`/api/historical-analysis/final-scores/${prevStr}`, {}, 8000);
            if(fsResPrev.ok){
              const fsDataP = await fsResPrev.json();
              const fsP = fsDataP.final_scores || {};
              Object.values(fsP).forEach(s=>{
                const awayName = s.away_team_display || s.away_team;
                const homeName = s.home_team_display || s.home_team;
                if(!awayName || !homeName) return;
                const gname = gameKey(awayName, homeName);
                const a = Number(s.away_score), h = Number(s.home_score);
                if(!isNaN(a) && !isNaN(h)){
                  if(!finalScores.has(gname) && !finalScores.has(normGameKey(gname))){
                    finalScores.set(gname, {away_team:awayName, home_team:homeName, away_score:a, home_score:h});
                    finalScores.set(normGameKey(gname), {away_team:awayName, home_team:homeName, away_score:a, home_score:h});
                  }
                }
              });
            }
          }catch(_){ /* ignore and use fallbacks below */ }
          const gr = (data.roi_analysis && data.roi_analysis.game_results) || [];
          gr.forEach(g=>{
            const gname = gameKey(g.away_team, g.home_team);
            let away=0, home=0;
            if (g.final_score) {
              const parts = String(g.final_score).split('-');
              if(parts.length===2){ away = Number(parts[0]); home = Number(parts[1]); }
            }
            if(!finalScores.has(gname)){
              finalScores.set(gname, {away_team:g.away_team, home_team:g.home_team, away_score:away, home_score:home});
              finalScores.set(normGameKey(gname), {away_team:g.away_team, home_team:g.home_team, away_score:away, home_score:home});
            }
          });
          const cardsFs = data.game_cards || [];
          cardsFs.forEach(card=>{
            const fs = card.final_scores || {};
            const a = Number(fs.away_score), h = Number(fs.home_score);
            if(!isNaN(a) && !isNaN(h)){
              const gname = gameKey(card.away_team, card.home_team);
              if(!finalScores.has(gname)){
                finalScores.set(gname, {away_team:card.away_team, home_team:card.home_team, away_score:a, home_score:h});
                finalScores.set(normGameKey(gname), {away_team:card.away_team, home_team:card.home_team, away_score:a, home_score:h});
              }
              // Also add a '@'-key for compatibility with rec.game format
              const compatKey = `${card.away_team} @ ${card.home_team}`;
              if(!finalScores.has(compatKey)){
                finalScores.set(compatKey, {away_team:card.away_team, home_team:card.home_team, away_score:a, home_score:h});
                finalScores.set(normGameKey(compatKey), {away_team:card.away_team, home_team:card.home_team, away_score:a, home_score:h});
              }
            }
          });

          const rows = recs.map(r=>{
            const game = r.game || `${r.away_team||''} @ ${r.home_team||''}`;
            const ngame = normGameKey(game);
            let type = String(r.type||'').toLowerCase();
            if(type==='over/under' || type.startsWith('total')) type='total';
            if(type==='ml' || type.startsWith('moneyline')) type='moneyline';
            if(type.startsWith('run')) type='run_line';
            const pick = r.recommendation || '';
            let side=null, line=null;
            if(type==='total'){
              // Primary parse from recommendation
              const parsed = parseSideLine(pick);
              side = parsed.side; line = parsed.line;
              // Supplemental: common fields from rec object
              if(!side && r.side){ const ps = parseSideLine(String(r.side)); if(ps.side) side = ps.side; if(ps.line!=null && line==null) line = Number(ps.line); }
              if(!side && r.pick){ const ps = parseSideLine(String(r.pick)); if(ps.side) side = ps.side; if(ps.line!=null && line==null) line = Number(ps.line); }
              if(line==null && r.betting_line!=null) line = Number(r.betting_line);
              if(line==null && r.line!=null) line = Number(r.line);
              if(line==null && r.total_line!=null) line = Number(r.total_line);
              // Last resort: infer side from bet text itself (e.g., "TOTAL Under 9.0" style already handled), else from fields casing
              if(!side){
                const betTxt = String(r.type||'') + ' ' + String(r.recommendation||'') + ' ' + String(r.side||'') + ' ' + String(r.pick||'');
                const low = betTxt.toLowerCase();
                if(low.includes(' under ')) side = 'UNDER';
                else if(low.includes(' over ')) side = 'OVER';
              }
            } else if(type==='moneyline'){
              // Derive HOME/AWAY from team name match
              const teamPick = parseMoneylineTeam(pick);
              const fs = finalScores.get(game) || finalScores.get(ngame);
              if(teamPick){
                const tp = normalizeTeamName(teamPick);
                // Prefer comparing to known away/home from rec when available
                const awayName = r.away_team ? normalizeTeamName(r.away_team) : null;
                const homeName = r.home_team ? normalizeTeamName(r.home_team) : null;
                if(awayName && tp===awayName) side='AWAY';
                else if(homeName && tp===homeName) side='HOME';
                // Otherwise compare using finalScores mapping if present
                if(!side && fs){
                  const isAway = tp === normalizeTeamName(fs.away_team);
                  const isHome = tp === normalizeTeamName(fs.home_team);
                  if(isAway) side = 'AWAY'; else if(isHome) side = 'HOME';
                }
                // Last resort: parse from the game string
                if(!side && game.includes('@')){
                  const parts = game.split('@');
                  const gAway = normalizeTeamName(parts[0].trim());
                  const gHome = normalizeTeamName(parts[1].trim());
                  if(tp===gAway) side='AWAY'; else if(tp===gHome) side='HOME';
                }
              }
            }
            const sideKey = (side||'').toUpperCase();
            const key = `${game}|${type}|${sideKey}|${line!=null? Number(line): ''}`;
            const nkey = `${ngame}|${type}|${sideKey}|${line!=null? Number(line): ''}`;
            // Priority 1: evaluated recs
            let correct = evalCorrectness.has(key) ? evalCorrectness.get(key) : (evalCorrectness.has(nkey) ? evalCorrectness.get(nkey) : undefined);
            if(correct === undefined && type==='total'){
              const wkey = `${game}|${type}|${sideKey}|*`;
              const nwkey = `${ngame}|${type}|${sideKey}|*`;
              if(evalSideOnly.has(wkey)) correct = evalSideOnly.get(wkey); else if(evalSideOnly.has(nwkey)) correct = evalSideOnly.get(nwkey);
            }
            // Priority 2: cards (only accept boolean or 'PUSH'; ignore null to allow fallback)
            if(correct === undefined){
              let v = correctness.has(key) ? correctness.get(key) : (correctness.has(nkey) ? correctness.get(nkey) : undefined);
              if(v === true || v === false || v === 'PUSH') correct = v;
            }
            if(correct === undefined && type==='total'){
              const wkey = `${game}|${type}|${sideKey}|*`;
              const nwkey = `${ngame}|${type}|${sideKey}|*`;
              let v = sideOnlyCorrectness.has(wkey) ? sideOnlyCorrectness.get(wkey) : (sideOnlyCorrectness.has(nwkey) ? sideOnlyCorrectness.get(nwkey) : undefined);
              if(v === true || v === false || v === 'PUSH') correct = v;
            }
            // Fallback correctness computation from final score when available
            let fs = finalScores.get(game) || finalScores.get(ngame);
            // If not found, try building an alternate key from rec away/home when present
            if(!fs){
              const parts = game.includes('@') ? game.split('@') : [];
              const altAway = (r.away_team || (parts[0] ? parts[0].trim() : null));
              const altHome = (r.home_team || (parts[1] ? parts[1].trim() : null));
              if(altAway && altHome){
                const altKey = `${altAway} @ ${altHome}`;
                fs = finalScores.get(altKey) || finalScores.get(normGameKey(altKey));
              }
            }
            // Last resort: scan the map for normalized away/home match
            if(!fs && game.includes('@')){
              const parts = game.split('@');
              const wantAway = normalizeTeamName(parts[0].trim());
              const wantHome = normalizeTeamName(parts[1].trim());
              for(const v of finalScores.values()){
                if(v && normalizeTeamName(v.away_team||'')===wantAway && normalizeTeamName(v.home_team||'')===wantHome){ fs = v; break; }
              }
            }
            if(correct === undefined && fs){
              if(type==='total' && sideKey && (line!=null)){
                const total = Number(fs.away_score) + Number(fs.home_score);
                const ln = Number(line);
                if(!isNaN(total) && !isNaN(ln)){
                  if(total===ln) correct = 'PUSH';
                  else correct = sideKey==='OVER' ? (total>ln) : (total<ln);
                }
              } else if(type==='moneyline'){
                const winner = (Number(fs.away_score) > Number(fs.home_score)) ? 'AWAY' : 'HOME';
                if(sideKey==='AWAY' || sideKey==='HOME') correct = (sideKey === winner);
              }
            }
            // Debug aid: surface unresolved totals to console
            if(correct === undefined && type==='total'){
              const sideKeyDbg = (side||'').toUpperCase();
              // eslint-disable-next-line no-console
              console.debug('Unresolved total rec', { game, side: sideKeyDbg, line, hasFS: !!fs });
            }
            return {
              game,
              bet: `${String(r.type||'').replace('_',' ').toUpperCase()} ${pick}`.trim(),
              odds: r.american_odds ?? r.odds,
              conf: String(r.confidence||'').toUpperCase(),
              ev: r.expected_value,
              correct
            };
          });
          rows.sort((a,b)=> confOrder(b.conf)-confOrder(a.conf) || (Number(b.ev||0)-Number(a.ev||0)));
          recDiv.innerHTML = rows.length ? ('<div class="table-wrap"><table class="table"><thead><tr><th>Game</th><th>Bet</th><th>Odds</th><th>Conf</th><th>EV</th><th>Correct</th></tr></thead><tbody>' +
            rows.map(r=>`<tr><td>${r.game}</td><td>${r.bet}</td><td>${r.odds}</td><td><span class="badge ${r.conf}">${r.conf}</span></td><td>${fmtEV(r.ev)}</td><td>${checkIcon(r.correct)}</td></tr>`).join('') +
          '</tbody></table></div>') : '<div class="muted">No recommendations found for this date.</div>';

          // Build recap tiles using variable stake by confidence
          const stakeByConf = { HIGH: 100, MEDIUM: 50, LOW: 25 };
          let resolved=0, wins=0, totalStake=0, profit=0;
          const level = {
            HIGH: { resolved:0, wins:0, stake:0, profit:0 },
            MEDIUM: { resolved:0, wins:0, stake:0, profit:0 },
            LOW: { resolved:0, wins:0, stake:0, profit:0 }
          };
          rows.forEach(r=>{
            if(r.correct===undefined || r.correct==='PUSH') return;
            const stake = stakeByConf[r.conf] ?? 0;
            const odds = parseAmericanOdds(r.odds);
            resolved += 1; wins += (r.correct===true ? 1 : 0); totalStake += stake;
            if(r.correct===true){ profit += odds>0 ? (stake*odds/100) : (stake*100/Math.abs(odds)); }
            else if(r.correct===false) { profit -= stake; }
            if(level[r.conf]){
              level[r.conf].resolved += 1;
              level[r.conf].wins += (r.correct===true ? 1 : 0);
              level[r.conf].stake += stake;
              if(r.correct===true){ level[r.conf].profit += odds>0 ? (stake*odds/100) : (stake*100/Math.abs(odds)); }
              else if(r.correct===false) { level[r.conf].profit -= stake; }
            }
          });
          const accPct = resolved ? (wins/resolved*100) : 0;
          const roiPct = totalStake ? (profit/totalStake*100) : 0;
          const tilesHtml = [
            {label:'Rec Accuracy', val: accPct.toFixed(1)+'%'},
            {label:'Total Recs', val: recs.length},
            {label:'ROI %', val: roiPct.toFixed(1)+'%'},
            {label:'Net Profit', val: '$'+profit.toFixed(2)}
          ].map(t=>`<div class='stat'><div class='num'>${t.val}</div><div class='muted'>${t.label}</div></div>`).join('');
          grid.innerHTML = tilesHtml;

          // Render by-confidence KPIs
          const levelGrid = document.getElementById('day-level-grid');
          const levelStats = [
            { key:'HIGH', label:'High' },
            { key:'MEDIUM', label:'Medium' },
            { key:'LOW', label:'Low' }
          ].map(({key,label})=>{
            const m = level[key];
            const acc = m.resolved ? (m.wins/m.resolved*100) : 0;
            const roi = m.stake ? (m.profit/m.stake*100) : 0;
            return `<div class='stat'><div class='num'>${acc.toFixed(1)}%</div><div class='muted'>${label} Accuracy</div><div class='muted'>ROI: ${roi.toFixed(1)}% â€¢ Profit: $${m.profit.toFixed(2)}</div><div class='muted'>${m.resolved} bets</div></div>`;
          }).join('');
          levelGrid.innerHTML = levelStats;
        } else {
          // Fallback: use historical game cards (may be incomplete vs raw file)
          const cards = data.game_cards || [];
          const rows=[];
          cards.forEach(card=>{
            const game = `${card.away_team} @ ${card.home_team}`;
            (card.recommendations||[]).forEach(r=>{
              rows.push({
                game,
                bet:`${(r.type||'').replace('_',' ').toUpperCase()} ${r.pick||''}`,
                odds:r.odds, conf:String(r.confidence||'').toUpperCase(), ev:r.expected_value, correct:r.is_correct
              });
            });
          });
          rows.sort((a,b)=> confOrder(b.conf)-confOrder(a.conf) || (Number(b.ev||0)-Number(a.ev||0)));
          recDiv.innerHTML = rows.length ? ('<div class="table-wrap"><table class="table"><thead><tr><th>Game</th><th>Bet</th><th>Odds</th><th>Conf</th><th>EV</th><th>Correct</th></tr></thead><tbody>' +
            rows.map(r=>`<tr><td>${r.game}</td><td>${r.bet}</td><td>${r.odds}</td><td><span class="badge ${r.conf}">${r.conf}</span></td><td>${fmtEV(r.ev)}</td><td>${checkIcon(r.correct)}</td></tr>`).join('') +
          '</tbody></table></div>') : '<div class="muted">No recommendations found for this date.</div>';

          // Recap from fallback rows (constant stake to avoid colliding identifiers)
          const unitFB=100; let resolvedFB=0, winsFB=0, profitFB=0;
          rows.forEach(r=>{ if(r.correct===undefined || r.correct==='PUSH') return; resolvedFB+=1; if(r.correct===true) winsFB+=1; const odds=parseAmericanOdds(r.odds); if(r.correct===true){ profitFB += odds>0 ? (unitFB*odds/100) : (unitFB*100/Math.abs(odds)); } else if(r.correct===false) { profitFB -= unitFB; } });
          const accPct = resolvedFB ? (winsFB/resolvedFB*100) : 0;
          const roiPct = resolvedFB ? (profitFB/(resolvedFB*unitFB)*100) : 0;
          grid.innerHTML = [
            {label:'Rec Accuracy', val: accPct.toFixed(1)+'%'},
            {label:'Total Recs', val: rows.length},
            {label:'ROI %', val: roiPct.toFixed(1)+'%'},
            {label:'Net Profit', val: '$'+profitFB.toFixed(2)}
          ].map(t=>`<div class='stat'><div class='num'>${t.val}</div><div class='muted'>${t.label}</div></div>`).join('');
        }
      }catch(e){
        console.warn('Day performance load error', e);
        if(recDiv){ recDiv.innerHTML='<div class="muted">Unable to load recommendations for this date.</div>'; }
        if(grid && (!grid.innerHTML || !grid.innerHTML.trim())){
          grid.innerHTML = [
            {label:'Rec Accuracy', val:'0.0%'},
            {label:'Total Recs', val: 0},
            {label:'ROI %', val:'0.0%'},
            {label:'Net Profit', val:'$0.00'}
          ].map(t=>`<div class='stat'><div class='num'>${t.val}</div><div class='muted'>${t.label}</div></div>`).join('');
        }
      }
    }
    // Expose range loader at global scope
    async function loadRangePerformance(){
      const start = document.getElementById('range-start').value;
      const end = document.getElementById('range-end').value;
      if(!start || !end) return;
    // Placeholders so the section isn't blank during heavy fetches
    const rangeGrid = document.getElementById('range-grid');
    const rangeRecs = document.getElementById('range-recs');
    const levelGridR = document.getElementById('range-level-grid');
    if(rangeRecs) rangeRecs.innerHTML = '<div class="muted">Loading range recommendationsâ€¦</div>';
    if(rangeGrid) rangeGrid.innerHTML = '';
    if(levelGridR) levelGridR.innerHTML = '';
      try{
        // We'll aggregate by fetching per-day rec files and final scores for all days in range
  const datesRes = await fetchWithTimeout('/api/historical-analysis/available-dates', {}, 12000);
        if(!datesRes.ok){
      if(rangeGrid) rangeGrid.innerHTML='';
      if(rangeRecs) rangeRecs.innerHTML='<div class="muted">Historical service unavailable.</div>';
          return;
        }
        const datesData = await datesRes.json();
        // Use union list from backend, but still guard
        const unionDates = (datesData.dates || datesData.available_dates || []);
        const allDates = unionDates.filter(d=> d>=start && d<=end);
        if(!allDates.length){
          if(rangeGrid) rangeGrid.innerHTML='';
          if(rangeRecs) rangeRecs.innerHTML='<div class="muted">No data in selected range.</div>';
          return;
        }

    // Parallel fetch of day analyses for evaluated correctness and final scores
    const dayAnalyses = await Promise.all(allDates.map(async d=>{
          // Always carry the date forward; fill data with minimal scaffolding if analyzer is missing
          try{
            const r = await fetchWithTimeout(`/api/historical-analysis/date/${d}`, {}, 10000);
            if(r.ok){
              const j = await r.json();
              return { date: d, data: (j && j.data ? j.data : j) };
            }
          }catch(_){ /* proceed to lightweight fallback for this date */ }
          // Lightweight fallback: try to load per-day recommendations and final scores directly
          let recs = [];
          try{
            const recRes = await fetchWithTimeout(`/api/betting-recommendations/date/${d}`, {}, 7000);
            if(recRes.ok){ const recData = await recRes.json(); recs = recData.recommendations || []; }
          }catch(_){ /* ignore */ }
          // Try to fetch final scores for this date
          let finalScores = [];
          try{
            const fsRes = await fetchWithTimeout(`/api/historical-analysis/final-scores/${d}`, {}, 6000);
            if(fsRes.ok){ const fsData = await fsRes.json(); const fs = fsData.final_scores || {}; finalScores = Object.values(fs); }
          }catch(_){ /* ignore */ }
          // If we have at least recs or fs, return a minimal shape to allow range aggregation to proceed
          if(recs.length || finalScores.length){
            return { date: d, data: { betting_recommendations: { recommendations_evaluated: [] }, game_cards: [], roi_analysis: { game_results: finalScores.map(s=>({ away_team: s.away_team_display||s.away_team, home_team: s.home_team_display||s.home_team, final_score: `${s.away_score}-${s.home_score}` })) }, _light_recs: recs } };
          }
          return { date: d, data: null };
        }));

  // Build KPI aggregation and rows list
        const rows=[];
        for (const entry of dayAnalyses){
          if(!entry || !entry.data) continue;
          const data = entry.data;
          // Use evaluated recs when available; else fall back to cards; else use lightweight per-day recs if present
          const evals = (data.betting_recommendations && data.betting_recommendations.recommendations_evaluated) || [];
          const cards = data.game_cards || [];
          const finalScores = new Map();
          // Gather final scores from ROI results and cards
          const gr = (data.roi_analysis && data.roi_analysis.game_results) || [];
          gr.forEach(g=>{ const gname = `${g.away_team} @ ${g.home_team}`; let a=0,h=0; if(g.final_score){ const p=String(g.final_score).split('-'); if(p.length===2){ a=Number(p[0]); h=Number(p[1]); } } finalScores.set(gname,{away_team:g.away_team,home_team:g.home_team,away_score:a,home_score:h}); finalScores.set(normGameKey(gname),{away_team:g.away_team,home_team:g.home_team,away_score:a,home_score:h}); });
          cards.forEach(c=>{ const fs=c.final_scores||{}; const a=Number(fs.away_score), h=Number(fs.home_score); if(!isNaN(a)&&!isNaN(h)){ const g=`${c.away_team} @ ${c.home_team}`; finalScores.set(g,{away_team:c.away_team,home_team:c.home_team,away_score:a,home_score:h}); finalScores.set(normGameKey(g),{away_team:c.away_team,home_team:c.home_team,away_score:a,home_score:h}); } });
          // Also try normalized final scores API per date and adjacent days (next first, then prev)
          try{
            const z = n=> String(n).padStart(2,'0');
            // Same day
            const fsRes = await fetchWithTimeout(`/api/historical-analysis/final-scores/${entry.date}`, {}, 8000);
            if(fsRes.ok){ const fsData = await fsRes.json(); const fs = fsData.final_scores || {}; Object.values(fs).forEach(s=>{ const awayName = s.away_team_display || s.away_team; const homeName = s.home_team_display || s.home_team; const gname = `${awayName} @ ${homeName}`; const a = Number(s.away_score), h = Number(s.home_score); if(!isNaN(a)&&!isNaN(h)){ finalScores.set(gname, {away_team:awayName, home_team:homeName, away_score:a, home_score:h}); finalScores.set(normGameKey(gname), {away_team:awayName, home_team:homeName, away_score:a, home_score:h}); } }); }
            // Next day
            const d0 = new Date(entry.date + 'T00:00:00Z');
            const next = new Date(d0.getTime() + 24*60*60*1000);
            const nextStr = `${next.getUTCFullYear()}-${z(next.getUTCMonth()+1)}-${z(next.getUTCDate())}`;
            const fsResNext = await fetchWithTimeout(`/api/historical-analysis/final-scores/${nextStr}`, {}, 8000);
            if(fsResNext.ok){ const fsDataN = await fsResNext.json(); const fsN = fsDataN.final_scores || {}; Object.values(fsN).forEach(s=>{ const awayName = s.away_team_display || s.away_team; const homeName = s.home_team_display || s.home_team; if(!awayName||!homeName) return; const gname = `${awayName} @ ${homeName}`; const a = Number(s.away_score), h = Number(s.home_score); if(!isNaN(a)&&!isNaN(h)){ if(!finalScores.has(gname) && !finalScores.has(normGameKey(gname))){ finalScores.set(gname, {away_team:awayName, home_team:homeName, away_score:a, home_score:h}); finalScores.set(normGameKey(gname), {away_team:awayName, home_team:homeName, away_score:a, home_score:h}); } } }); }
            // Previous day
            const prev = new Date(d0.getTime() - 24*60*60*1000);
            const prevStr = `${prev.getUTCFullYear()}-${z(prev.getUTCMonth()+1)}-${z(prev.getUTCDate())}`;
            const fsResPrev = await fetchWithTimeout(`/api/historical-analysis/final-scores/${prevStr}`, {}, 8000);
            if(fsResPrev.ok){ const fsDataP = await fsResPrev.json(); const fsP = fsDataP.final_scores || {}; Object.values(fsP).forEach(s=>{ const awayName = s.away_team_display || s.away_team; const homeName = s.home_team_display || s.home_team; if(!awayName||!homeName) return; const gname = `${awayName} @ ${homeName}`; const a = Number(s.away_score), h = Number(s.home_score); if(!isNaN(a)&&!isNaN(h)){ if(!finalScores.has(gname) && !finalScores.has(normGameKey(gname))){ finalScores.set(gname, {away_team:awayName, home_team:homeName, away_score:a, home_score:h}); finalScores.set(normGameKey(gname), {away_team:awayName, home_team:homeName, away_score:a, home_score:h}); } } }); }
          }catch(_){ /* optional */ }

          // Build evaluated correctness map
          const evalCorrectness=new Map(); const evalSideOnly=new Map();
          evals.forEach(e=>{
            try{
              const game = `${e.away_team} @ ${e.home_team}`;
              let type=String(e.bet_type||'').toLowerCase();
              if(type.startsWith('total')) type='total';
              if(type.startsWith('moneyline')||type==='ml') type='moneyline';
              if(type.startsWith('run')) type='run_line';
              let sideBase=null, lineVal=null; const recTxt=String(e.recommendation||'');
              if(type==='total'){ const parsed=parseSideLine(recTxt); sideBase=parsed.side; lineVal=parsed.line; }
              else if(type==='moneyline'){ const teamPick=parseMoneylineTeam(recTxt); const tp=teamPick?canonTeam(teamPick):null; if(tp){ if(tp===canonTeam(e.away_team)) sideBase='AWAY'; else if(tp===canonTeam(e.home_team)) sideBase='HOME'; } }
              const key = `${game}|${type}|${(sideBase||'').toUpperCase()}|${lineVal!=null? Number(lineVal): ''}`;
              const skey = `${game}|${type}|${(sideBase||'').toUpperCase()}|*`;
              if(sideBase && (lineVal!=null || type!=='total')) evalCorrectness.set(key, !!e.bet_won);
              if(sideBase) evalSideOnly.set(skey, !!e.bet_won);
            }catch(_){ }
          });

          // Try to fetch per-day recommendations (primary source for list); re-use lightweight if already present
          let recs = Array.isArray(data._light_recs) ? data._light_recs.slice() : [];
          if(!recs.length){
            try{
              const recRes = await fetchWithTimeout(`/api/betting-recommendations/date/${entry.date}`, {}, 9000);
              if(recRes.ok){ const recData = await recRes.json(); recs = recData.recommendations || []; }
            }catch(_){ /* ignore */ }
          }
          const currentDate = entry.date;
          const addRow = (game, typeNorm, pick, odds, conf, ev, lineHint=null, extraFields={})=>{
            // typeNorm must already be one of: total | moneyline | run_line | other
            const parsed = parseSideLine(pick);
            let side = parsed.side;
            let line = parsed.line != null ? Number(parsed.line) : (lineHint!=null ? Number(lineHint) : null);
            if(typeNorm==='total'){
              if(!side && extraFields.side){ const ps = parseSideLine(String(extraFields.side)); if(ps.side) side = ps.side; if(ps.line!=null && line==null) line = Number(ps.line); }
              if(!side && extraFields.pick){ const ps = parseSideLine(String(extraFields.pick)); if(ps.side) side = ps.side; if(ps.line!=null && line==null) line = Number(ps.line); }
              if(line==null && extraFields.total_line!=null) line = Number(extraFields.total_line);
              if(line==null && extraFields.line!=null) line = Number(extraFields.line);
              if(line==null && extraFields.betting_line!=null) line = Number(extraFields.betting_line);
            }
            if(typeNorm==='moneyline' && !side){
              const rsn = normalizeTeamName(pick);
              const parts = game.split('@');
              if(parts.length===2){
                const awayT = normalizeTeamName(parts[0].trim());
                const homeT = normalizeTeamName(parts[1].trim());
                if(rsn===awayT) side='AWAY'; else if(rsn===homeT) side='HOME';
              }
            }
            const sideKey=(side||'').toUpperCase();
            const key = `${game}|${typeNorm}|${sideKey}|${line!=null? Number(line): ''}`;
            let correct = evalCorrectness.has(key) ? evalCorrectness.get(key) : undefined;
            if(correct===undefined && typeNorm==='total'){ const wkey = `${game}|${typeNorm}|${sideKey}|*`; if(evalSideOnly.has(wkey)) correct = evalSideOnly.get(wkey); }
            if(correct===undefined){
              const fs = finalScores.get(game) || finalScores.get(normGameKey(game));
              if(fs){
                if(typeNorm==='total' && sideKey && (line!=null)){
                  const total = Number(fs.away_score)+Number(fs.home_score);
                  const ln = Number(line);
                  if(!isNaN(total) && !isNaN(ln)){
                    if(total===ln) correct = 'PUSH';
                    else correct = sideKey==='OVER' ? (total>ln) : (total<ln);
                  }
                } else if(typeNorm==='moneyline'){
                  const winner = (Number(fs.away_score) > Number(fs.home_score)) ? 'AWAY' : 'HOME';
                  if(sideKey==='AWAY' || sideKey==='HOME') correct = (sideKey === winner);
                }
              }
            }
            rows.push({
              date: currentDate,
              game,
              bet: `${String(typeNorm||'').replace('_',' ').toUpperCase()} ${pick}`.trim(),
              odds,
              conf: String(conf||'').toUpperCase(),
              ev,
              correct
            });
          };

          if(recs.length){
            // Build rows from per-day recommendations (preferred)
            recs.forEach(r=>{
              const game = r.game || `${r.away_team||''} @ ${r.home_team||''}`;
              let type = String(r.type||'').toLowerCase();
              if(type==='over/under' || type.startsWith('total')) type='total';
              else if(type==='ml' || type.startsWith('moneyline')) type='moneyline';
              else if(type.startsWith('run')) type='run_line';
              const pick = r.recommendation || '';
              let lineHint = null;
              if(type==='total') lineHint = (r.betting_line!=null? Number(r.betting_line): (r.line!=null? Number(r.line): (r.total_line!=null? Number(r.total_line): null)));
              const odds = r.american_odds ?? r.odds;
              const conf = r.confidence;
              const ev = r.expected_value;
              addRow(game, type, pick, odds, conf, ev, lineHint, { side: r.side, pick: r.pick, line: r.line, total_line: r.total_line, betting_line: r.betting_line });
            });
          } else {
            // Fallback to cards' recs if recs file missing
            cards.forEach(card=>{
              const game = `${card.away_team} @ ${card.home_team}`;
              (card.recommendations||[]).forEach(r=>{
                let type=String(r.type||'').toLowerCase();
                if(type.startsWith('total')) type='total'; else if(type.startsWith('moneyline')) type='moneyline'; else if(type.startsWith('run')) type='run_line';
                const pick = String((r.side!=null && r.side!=='') ? r.side : (r.pick!=null ? r.pick : r.recommendation||''));
                const odds = r.american_odds ?? r.odds; const conf = r.confidence; const ev = r.expected_value;
                const lineHint = (r.line!=null? Number(r.line): null);
                addRow(game, type, pick, odds, conf, ev, lineHint, { side: r.side, pick: r.pick, line: r.line, total_line: r.total_line, betting_line: r.betting_line });
              });
            });
          }
        }

        // Sort and render rows
        rows.sort((a,b)=> confOrder(b.conf)-confOrder(a.conf) || (Number(b.ev||0)-Number(a.ev||0)));
    const recDiv = document.getElementById('range-recs');
  recDiv.innerHTML = rows.length ? ('<div class="table-wrap"><table class="table"><thead><tr><th>Date</th><th>Game</th><th>Bet</th><th>Odds</th><th>Conf</th><th>EV</th><th>Correct</th></tr></thead><tbody>' +
    rows.map(r=>`<tr><td>${r.date||''}</td><td>${r.game}</td><td>${r.bet}</td><td>${r.odds||''}</td><td><span class="badge ${r.conf}">${r.conf}</span></td><td>${fmtEV(r.ev)}</td><td>${checkIcon(r.correct)}</td></tr>`).join('') +
  '</tbody></table></div>') : '<div class="muted">No recommendations in this range.</div>';

  // Compute KPI tiles using variable stake by confidence
  const stakeByConfR = { HIGH: 100, MEDIUM: 50, LOW: 25 };
  let resolved=0, wins=0, totalStake=0, profit=0;
  const levelR = {
    HIGH: { resolved:0, wins:0, stake:0, profit:0 },
    MEDIUM: { resolved:0, wins:0, stake:0, profit:0 },
    LOW: { resolved:0, wins:0, stake:0, profit:0 }
  };
  rows.forEach(r=>{
    if(r.correct===undefined || r.correct==='PUSH') return;
    const stake = stakeByConfR[r.conf] ?? 0;
    const odds = parseAmericanOdds(r.odds);
    resolved += 1; wins += (r.correct===true ? 1 : 0); totalStake += stake;
    if(r.correct===true){ profit += odds>0 ? (stake*odds/100) : (stake*100/Math.abs(odds)); }
    else if(r.correct===false) { profit -= stake; }
    if(levelR[r.conf]){
      levelR[r.conf].resolved += 1;
      levelR[r.conf].wins += (r.correct===true ? 1 : 0);
      levelR[r.conf].stake += stake;
      if(r.correct===true){ levelR[r.conf].profit += odds>0 ? (stake*odds/100) : (stake*100/Math.abs(odds)); }
      else if(r.correct===false) { levelR[r.conf].profit -= stake; }
    }
  });
  const accPct = resolved ? (wins/resolved*100) : 0;
  const roiPct = totalStake ? (profit/totalStake*100) : 0;
  const grid=document.getElementById('range-grid'); grid.innerHTML='';
  [
    {label:'Rec Accuracy', val: accPct.toFixed(1)+'%'},
    {label:'Total Recs', val: rows.length},
    {label:'ROI %', val: roiPct.toFixed(1)+'%'},
    {label:'Net Profit', val: '$'+profit.toFixed(2)}
  ].forEach(t=>{ const d=document.createElement('div'); d.className='stat'; d.innerHTML=`<div class='num'>${t.val}</div><div class='muted'>${t.label}</div>`; grid.appendChild(d); });

  // Render by-confidence KPIs for range
  const levelStatsR = [
    { key:'HIGH', label:'High' },
    { key:'MEDIUM', label:'Medium' },
    { key:'LOW', label:'Low' }
  ].map(({key,label})=>{
    const m = levelR[key];
    const acc = m.resolved ? (m.wins/m.resolved*100) : 0;
    const roi = m.stake ? (m.profit/m.stake*100) : 0;
    return `<div class='stat'><div class='num'>${acc.toFixed(1)}%</div><div class='muted'>${label} Accuracy</div><div class='muted'>ROI: ${roi.toFixed(1)}% â€¢ Profit: $${m.profit.toFixed(2)}</div><div class='muted'>${m.resolved} bets</div></div>`;
  }).join('');
  levelGridR.innerHTML = levelStatsR;
      }catch(e){ console.warn('Failed to load range performance', e); }
    }
  loadPerformance(); loadTopPicksToday(); loadToday(); loadAvailableDates(); loadPropsSpotlight(); loadPropsCoverageChip();

  // Gentle polling to keep props coverage fresh; spotlight refresh every ~2 minutes
  setInterval(loadPropsCoverageChip, 30000);
  setInterval(loadPropsSpotlight, 120000);

  // Pitcher props snapshot/recap/reconciliation removed

  // Pitcher diagnostics removed
  </script>
</body>
</html>
