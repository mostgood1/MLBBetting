<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Betting Guidance - Kelly Recommendations</title>
  <style>
    body { font-family: Inter, Segoe UI, Arial, sans-serif; background:#0b1e39; color:#111; margin:0; }
    .container { max-width:1200px; margin:0 auto; padding:24px; }
    .card { background:#fff; border-radius:14px; padding:20px; box-shadow:0 10px 30px rgba(0,0,0,0.15); margin-bottom:18px; }
    h1 { color:#163a6b; }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(260px,1fr)); gap:16px; }
    .stat { background:#f8fbff; border:1px solid #e2ecf7; border-radius:12px; padding:16px; text-align:center; }
    .stat .num { font-size:28px; font-weight:700; color:#163a6b; }
    .badge { padding:4px 8px; border-radius:999px; font-size:12px; font-weight:700; }
    .badge.HIGH { background:#16a34a; color:#fff; }
    .badge.MEDIUM { background:#2563eb; color:#fff; }
    .badge.LOW { background:#eab308; color:#111; }
    .muted { color:#666; font-size:13px; }
  .btn { background:#163a6b; color:#fff; padding:10px 16px; border:none; border-radius:10px; cursor:pointer; text-decoration:none; display:inline-block; }
  .btn.secondary { background:#2a74dc; }
  .input { padding:8px 10px; border-radius:8px; border:1px solid #cfe1f8; }
    .table { width:100%; border-collapse: collapse; }
    .table th, .table td { border-bottom:1px solid #eee; padding:10px; text-align:left; }
    .table-wrap { width:100%; overflow-x:auto; -webkit-overflow-scrolling:touch; }
    /* Responsive enhancements */
    @media (max-width: 700px){
      body { font-size:14px; }
      .container { padding:16px; }
      h1 { font-size:22px; }
      h2 { font-size:18px; }
      .grid { grid-template-columns: repeat(auto-fit, minmax(160px,1fr)); gap:12px; }
      .stat { padding:12px; }
      .stat .num { font-size:22px; }
      .btn { padding:8px 12px; font-size:13px; }
      .input { padding:6px 8px; font-size:13px; }
      .table th, .table td { padding:6px 8px; font-size:12px; }
      #roi-metrics-card .grid { grid-template-columns: repeat(auto-fit, minmax(140px,1fr)); }
      .card { padding:16px; }
      .muted { font-size:12px; }
    }
    /* Very small screens */
    @media (max-width:480px){
      h1 { font-size:19px; }
      .grid { grid-template-columns: repeat(auto-fit, minmax(140px,1fr)); }
      .stat .num { font-size:20px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <div style="display:flex; justify-content: space-between; align-items:center;">
        <h1>ðŸŽ¯ Betting Guidance (Kelly-Based)</h1>
        <a class="btn secondary" href="/" style="text-decoration:none;">â¬… Back to Main</a>
      </div>
      <div class="muted">Todayâ€™s opportunities and historical performance by bet type.</div>
      <div style="margin-top:10px;">
        <a class="btn" href="/kelly-guidance" style="text-decoration:none;">Open Kelly Guidance Page â†’</a>
      </div>
    </div>

  <div class="grid" id="perf"></div>

  <div class="card" id="roi-metrics-card" style="margin-top:18px;">
    <h2>Recent ROI & Efficiency</h2>
    <div class="muted" style="margin-bottom:8px;">Derived from latest weekly retune (rolling 7-day window). Efficiency = profit / sqrt(total stake). Kelly comparison uses recorded Kelly bet sizes vs fixed_stake model.</div>
    <div id="roi-metrics-content" class="grid"></div>
  </div>


    <div class="card">
      <h2>Todayâ€™s Recommendations (All)</h2>
      <div class="muted" style="margin-bottom:8px;">Sorted by confidence, then EV. EV shown as percentage.</div>
      <div id="today"></div>
      <div style="margin-top:16px;">
        <h3 style="margin:8px 0;">Today Recap</h3>
        <div class="grid" id="today-kpis"></div>
      </div>
    </div>

    <div class="card">
      <h2>Pitcher Prop Recommendations (Snapshot)</h2>
      <div class="muted" style="margin-bottom:8px;">
        Live <span id="prop-refresh-tag">30s</span>
      </div>
      <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px; flex-wrap:wrap;">
        <label class="muted">Filter:</label>
        <select id="prop-market" class="input">
          <option value="ALL">All</option>
          <option value="strikeouts">K</option>
          <option value="outs">Outs</option>
          <option value="earned_runs">ER</option>
          <option value="hits_allowed">Hits</option>
          <option value="walks">BB</option>
        </select>
        <label style="display:flex;align-items:center;gap:6px;">
          <input type="checkbox" id="prop-hide-low" /> <span class="muted">Hide LOW</span>
        </label>
      </div>
      <div id="prop-snapshot"></div>
    </div>

    <div class="card">
      <h2>Yesterday Pitcher Props Recap</h2>
      <div id="props-yesterday-kpis" class="grid" style="margin-bottom:10px;"></div>
      <div id="props-yesterday"></div>
    </div>

    <div class="card">
      <h2>Historical Day Performance</h2>
      <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
        <label for="hist-day" class="muted">Select day:</label>
        <select id="hist-day" class="input"></select>
        <button class="btn" onclick="loadDayPerformance()">Load</button>
      </div>
      <div class="grid" id="day-grid"></div>
  <div class="muted" style="margin:8px 0 4px;">By Confidence (variable stake)</div>
  <div class="grid" id="day-level-grid"></div>
      <div style="margin-top:16px;">
        <h3 style="margin:8px 0;">Recommendations for Selected Day</h3>
        <div id="day-recs"></div>
      </div>
    </div>

    <div class="card">
      <h2>Historical Performance (Date Range)</h2>
      <div class="muted" style="margin-bottom:8px;">Select a window to see cumulative performance over time.</div>
      <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px; flex-wrap:wrap;">
        <label for="range-start" class="muted">Start date:</label>
        <select id="range-start" class="input"></select>
        <label for="range-end" class="muted">End date:</label>
        <select id="range-end" class="input"></select>
        <button class="btn" onclick="loadRangePerformance()">Load Range</button>
      </div>
      <div class="grid" id="range-grid"></div>
  <div class="muted" style="margin:8px 0 4px;">By Confidence (variable stake)</div>
  <div class="grid" id="range-level-grid"></div>
      <div style="margin-top:16px;">
        <h3 style="margin:8px 0;">Recommendations for Selected Range</h3>
        <div id="range-recs"></div>
      </div>
    </div>

    <div class="card">
      <h2>Pitcher Prop Reconciliation (Day)</h2>
      <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px; flex-wrap:wrap;">
        <label class="muted" for="props-day">Select day:</label>
        <select id="props-day" class="input"></select>
        <button class="btn" onclick="loadPropsForDay()">Load</button>
        <span class="muted" style="margin-left:auto;">By Stat</span>
      </div>
      <div id="props-day-kpis" class="grid" style="margin-bottom:10px;"></div>
      <div id="props-day"></div>
    </div>
  </div>

  <script>
    function fmtPct(n){ return (Number(n)||0).toFixed(1) + '%'; }
    function fmtEV(n){ const v=Number(n); if(!isFinite(v)) return '-'; return (v*100).toFixed(1)+'%'; }
    const confOrder = c => ({'HIGH':3,'MEDIUM':2,'LOW':1}[String(c||'').toUpperCase()]||0);
  const checkIcon = ok => ok===true ? 'âœ…' : ok===false ? 'âŒ' : (ok==='PUSH' ? 'âž–' : '');
    function parseAmericanOdds(od){
      try{
        if(od===null || od===undefined) return -110;
        if(typeof od==='number') return Math.trunc(od);
        let s=String(od).trim();
        if(!s || s.toUpperCase()==='N/A') return -110;
        s=s.replace('âˆ’','-');
        if(s.startsWith('+')) s=s.slice(1);
        return Math.trunc(parseFloat(s));
      }catch(_){ return -110; }
    }
    function parseSideLine(rec){
      if(!rec) return { side:null, line:null };
      const txt = String(rec).trim().toLowerCase();
      let side = null; let line = null;
      // Prefer explicit words
      if(/\bover\b/.test(txt)) side = 'OVER';
      else if(/\bunder\b/.test(txt)) side = 'UNDER';
      // Compact formats like "O9", "O 9", "U8.5", "U 8.5"
      if(!side){
        const mo = txt.match(/(^|[^a-z])o\s*(\d+(?:\.\d+)?)/i);
        if(mo){ side='OVER'; line = Number(mo[2]); }
      }
      if(!side){
        const mu = txt.match(/(^|[^a-z])u\s*(\d+(?:\.\d+)?)/i);
        if(mu){ side='UNDER'; line = Number(mu[2]); }
      }
      // If line still missing, grab the first number
      if(line==null){ const m = txt.match(/(\d+\.?\d*)/); if(m) line = Number(m[1]); }
      return { side, line };
    }
    function normalizeTeamName(s){
      return String(s||'').toLowerCase().replace(/[^a-z0-9]/g,'');
    }
    // Canonicalize common aliases to improve cross-source matching
    function canonTeam(s){
      const t = normalizeTeamName(s);
      const m = {
        // LA teams
        'laangels':'losangelesangels','losangelesangels':'losangelesangels','anaheimangels':'losangelesangels','laa':'losangelesangels',
        'ladodgers':'losangelesdodgers','losangelesdodgers':'losangelesdodgers','lad':'losangelesdodgers',
        // NY teams
        'nyyankees':'newyorkyankees','newyorkyankees':'newyorkyankees','nyy':'newyorkyankees',
        'nymets':'newyorkmets','newyorkmets':'newyorkmets','nym':'newyorkmets',
        // Chicago
        'chiwhitesox':'chicagowhitesox','chicagowhitesox':'chicagowhitesox','chw':'chicagowhitesox','cws':'chicagowhitesox',
        'chicubs':'chicagocubs','chicagocubs':'chicagocubs','chc':'chicagocubs',
        // St. Louis
        'stlouiscardinals':'stlouiscardinals','saintlouiscardinals':'stlouiscardinals','stl':'stlouiscardinals',
        // Boston
        'bostonredsox':'bostonredsox','redsox':'bostonredsox','bos':'bostonredsox',
        // Toronto
        'torontobluejays':'torontobluejays','bluejays':'torontobluejays','tor':'torontobluejays','tbj':'torontobluejays',
        // Tampa Bay
        'tampabayrays':'tampabayrays','rays':'tampabayrays','tampabaydevilrays':'tampabayrays','tb':'tampabayrays','tbr':'tampabayrays',
        // Baltimore
        'baltimoreorioles':'baltimoreorioles','orioles':'baltimoreorioles','bal':'baltimoreorioles',
        // Cleveland
        'clevelandguardians':'clevelandguardians','guardians':'clevelandguardians','clevelandindians':'clevelandguardians','cle':'clevelandguardians','clg':'clevelandguardians',
        // Detroit
        'detroittigers':'detroittigers','tigers':'detroittigers','det':'detroittigers',
        // Kansas City
        'kansascityroyals':'kansascityroyals','royals':'kansascityroyals','kc':'kansascityroyals','kcr':'kansascityroyals',
        // Minnesota
        'minnesotatwins':'minnesotatwins','twins':'minnesotatwins','min':'minnesotatwins',
        // Houston
        'houstonastros':'houstonastros','astros':'houstonastros','hou':'houstonastros',
        // Seattle
        'seattlemariners':'seattlemariners','mariners':'seattlemariners','sea':'seattlemariners',
        // Texas
        'texasrangers':'texasrangers','rangers':'texasrangers','tex':'texasrangers',
        // Atlanta
        'atlantabraves':'atlantabraves','braves':'atlantabraves','atl':'atlantabraves',
        // Miami
        'miamimarlins':'miamimarlins','floridamarlins':'miamimarlins','marlins':'miamimarlins','mia':'miamimarlins','fla':'miamimarlins',
        // Philadelphia
        'philadelphiaphillies':'philadelphiaphillies','phillies':'philadelphiaphillies','phi':'philadelphiaphillies',
        // Washington
        'washingtonnationals':'washingtonnationals','nationals':'washingtonnationals','was':'washingtonnationals','wsn':'washingtonnationals',
        // Arizona
        'arizonadiamondbacks':'arizonadiamondbacks','diamondbacks':'arizonadiamondbacks','ari':'arizonadiamondbacks','az':'arizonadiamondbacks',
        // Colorado
        'coloradorockies':'coloradorockies','rockies':'coloradorockies','col':'coloradorockies',
        // San Diego
        'sandiegopadres':'sandiegopadres','padres':'sandiegopadres','sd':'sandiegopadres','sdp':'sandiegopadres',
        // San Francisco
        'sanfranciscogiants':'sanfranciscogiants','giants':'sanfranciscogiants','sf':'sanfranciscogiants','sfg':'sanfranciscogiants',
        // Milwaukee
        'milwaukeebrewers':'milwaukeebrewers','brewers':'milwaukeebrewers','mil':'milwaukeebrewers',
        // Cincinnati
        'cincinnatireds':'cincinnatireds','reds':'cincinnatireds','cin':'cincinnatireds',
        // Pittsburgh
        'pittsburghpirates':'pittsburghpirates','pirates':'pittsburghpirates','pit':'pittsburghpirates',
  // Oakland
  'oaklandathletics':'oaklandathletics','athletics':'oaklandathletics','oak':'oaklandathletics','as':'oaklandathletics','oaklandas':'oaklandathletics'
      };
      return m[t] || t;
    }
    function normGameKey(game){
      const raw = String(game||'');
      if(raw.includes('@')){
        const parts = raw.split('@');
        return `${canonTeam(parts[0])}@${canonTeam(parts[1])}`;
      }
      return normalizeTeamName(raw);
    }
    function parseMoneylineTeam(pick){
      if(!pick) return null;
      let t = String(pick).replace(/ml$/i,'').replace(/moneyline/i,'').trim();
      return t;
    }
    function gameKey(away, home){ return `${away} @ ${home}`; }
    async function loadPerformance(){
      const res=await fetch('/api/betting-guidance/performance');
      const data=await res.json();
      const perf=data.performance_by_bet_type||{};
      const grid=document.getElementById('perf');
      grid.innerHTML='';
      Object.entries(perf).forEach(([type,stats])=>{
        const div=document.createElement('div'); div.className='stat';
        div.innerHTML=`<div class='num'>${fmtPct(stats.accuracy)}</div><div class='muted'>${type.replace('_',' ').toUpperCase()}</div><div class='muted'>ROI: ${stats.roi?.toFixed(1)||0}% | Profit: $${stats.net_profit?.toFixed(2)||0}</div><div class='muted'>${stats.total_bets} bets (${stats.correct_bets} wins)</div>`;
        grid.appendChild(div);
      });
      loadROIMetricsPanel();
    }

    async function loadROIMetricsPanel(){
      try{
        const res = await fetch('/api/optimization/roi-metrics');
        const data = await res.json();
        const cont = document.getElementById('roi-metrics-content');
        cont.innerHTML='';
        if(!data.roi_metrics){ cont.innerHTML='<div class="muted">No ROI metrics available yet.</div>'; return; }
        const rm = data.roi_metrics;
        // Build cards for each confidence
        const confMap = rm.by_confidence || {};
        Object.entries(confMap).forEach(([conf,vals])=>{
          const eff = vals.total_stake>0 ? (vals.total_profit/Math.sqrt(vals.total_stake)) : 0;
          const div=document.createElement('div'); div.className='stat';
          div.innerHTML = `<div class='num'>${(vals.roi*100).toFixed(1)}%</div>
            <div class='muted'>${conf.toUpperCase()} ROI</div>
            <div class='muted'>Profit $${vals.total_profit.toFixed(2)} / Stake $${vals.total_stake.toFixed(0)}</div>
            <div class='muted'>Eff: ${eff.toFixed(3)} | W:${vals.wins} L:${vals.losses} P:${vals.pushes}</div>`;
          cont.appendChild(div);
        });
        // Kelly vs Fixed Stake summary if present
        if(rm.kelly_comparison){
          const kc = rm.kelly_comparison;
            const div=document.createElement('div'); div.className='stat';
            div.style.background='#eef7ff';
            div.innerHTML = `<div class='num'>Kelly vs Fixed</div>
              <div class='muted'>Kelly ROI: ${(kc.kelly_roi*100).toFixed(1)}% ($${kc.kelly_profit.toFixed(2)})</div>
              <div class='muted'>Fixed ROI: ${(kc.fixed_roi*100).toFixed(1)}% ($${kc.fixed_profit.toFixed(2)})</div>
              <div class='muted'>Edge: ${( (kc.kelly_roi-kc.fixed_roi)*100).toFixed(1)} pts</div>`;
            cont.appendChild(div);
        }
      }catch(e){
        console.error('ROI metrics panel error', e);
        const cont = document.getElementById('roi-metrics-content');
        if(cont && (!cont.innerHTML || !cont.innerHTML.trim())){
          cont.innerHTML = '<div class="muted">ROI metrics failed to load. Check /api/optimization/roi-metrics and /api/debug-data-files.</div>';
        }
      }
    }
    async function loadToday(){
      // Use the new endpoint to fetch ALL recommendations from today's betting_recommendations file
      const today = todayISO();
      const res = await fetch(`/api/betting-recommendations/date/${today}`);
      const data = await res.json();
      const div = document.getElementById('today');
      const recs = data.recommendations || [];
      if(!recs.length){ div.innerHTML='<div class="muted">No recommendations available.</div>'; return; }
      // Normalize rows and sort by confidence then EV
      const rows = recs.map(r=>({
        game: r.game || `${r.away_team||''} @ ${r.home_team||''}`,
        bet: `${String(r.type||'').replace('_',' ').toUpperCase()} ${r.recommendation||''}`.trim(),
        odds: r.american_odds ?? r.odds,
        conf: String(r.confidence||'').toUpperCase(),
        ev: r.expected_value
      }));
      rows.sort((a,b)=> confOrder(b.conf)-confOrder(a.conf) || (Number(b.ev||0)-Number(a.ev||0)));
      div.innerHTML = '<div class="table-wrap"><table class="table"><thead><tr><th>Game</th><th>Bet</th><th>Odds</th><th>Conf</th><th>EV</th></tr></thead><tbody>' +
        rows.map(r=>`<tr><td>${r.game}</td><td>${r.bet}</td><td>${r.odds}</td><td><span class="badge ${r.conf}">${r.conf}</span></td><td>${fmtEV(r.ev)}</td></tr>`).join('') +
      '</tbody></table></div>';

      // Build Today Recap KPIs based on THESE recs only (so counts match what you see)
      await loadTodayRecap(recs);
    }
    async function loadAvailableDates(){
      try{
    const res=await fetch('/api/historical-analysis/available-dates');
        const data=await res.json();
  const sel=document.getElementById('hist-day'); sel.innerHTML='';
  // Historical proxy returns { dates: [...] }
  const dates = (data.dates || data.available_dates || []);
  // Sort dates ascending to keep behavior stable, then select the latest
  dates.sort();
  dates.forEach(dt=>{ const o=document.createElement('option'); o.value=dt; o.textContent=dt; sel.appendChild(o); });
  // Auto-select most recent date and preload KPIs
  if(dates.length){ sel.value = dates[dates.length-1]; await loadDayPerformance(); }

  // Populate range selectors
  const rs = document.getElementById('range-start');
  const re = document.getElementById('range-end');
  rs.innerHTML = ''; re.innerHTML = '';
  dates.forEach(dt=>{
    const o1=document.createElement('option'); o1.value=dt; o1.textContent=dt; rs.appendChild(o1);
    const o2=document.createElement('option'); o2.value=dt; o2.textContent=dt; re.appendChild(o2);
  });
  if(dates.length){
    // Default to current month range if available
    const now = new Date();
    const z = n=>String(n).padStart(2,'0');
    const prefix = `${now.getFullYear()}-${z(now.getMonth()+1)}-`;
    const monthDates = dates.filter(d=> d.startsWith(prefix));
    if(monthDates.length){
      rs.value = monthDates[0];
      re.value = monthDates[monthDates.length-1];
    } else {
      // Fallback to full available range
      rs.value = dates[0];
      re.value = dates[dates.length-1];
    }
    await loadRangePerformance();
  }
      }catch(e){ console.warn('Failed to load available dates', e); }
    }
    function todayISO(){ const d=new Date(); const z=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}`; }
  function yesterdayISO(){ const d=new Date(); d.setDate(d.getDate()-1); const z=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}`; }
  // Kelly details now live on the dedicated page via link above
  async function loadTodayRecap(recs){
      const grid = document.getElementById('today-kpis'); grid.innerHTML='';
      try{
        // Pull historical analysis for today to evaluate correctness using final scores (and evaluated maps)
        const res = await fetch(`/api/historical-analysis/date/${todayISO()}`);
        if(!res.ok){
          // If historical API not available for today yet, show neutral tiles based on rec count only
          const tiles=[
            {label:'Rec Accuracy', val:'0.0%'},
            {label:'Total Recs', val: (recs?.length||0)},
            {label:'ROI %', val:'0.0%'},
            {label:'Net Profit', val:'$0.00'}
          ];
          tiles.forEach(t=>{ const d=document.createElement('div'); d.className='stat'; d.innerHTML=`<div class='num'>${t.val}</div><div class='muted'>${t.label}</div>`; grid.appendChild(d); });
          return;
        }
        const raw = await res.json();
        const data = raw && raw.data ? raw.data : raw;

        // Build evaluated correctness maps (type+side+line) and fallback final scores from ROI game results
        const evalCorrectness = new Map();
        const evalSideOnly = new Map();
        const evals = (data.betting_recommendations && data.betting_recommendations.recommendations_evaluated) || [];
        evals.forEach(e=>{
          try{
            const game = `${e.away_team} @ ${e.home_team}`;
            let type = String(e.bet_type||'').toLowerCase();
            if(type.startsWith('total')) type='total';
            if(type.startsWith('moneyline')||type==='ml') type='moneyline';
            if(type.startsWith('run')) type='run_line';
            const recTxt = String(e.recommendation||'').trim();
            let sideBase=null, lineVal=null;
            if(type==='total'){
              const parsed = parseSideLine(recTxt); sideBase=parsed.side; lineVal=parsed.line;
            } else if(type==='moneyline'){
              const teamPick = parseMoneylineTeam(recTxt);
              const tp = canonTeam(teamPick);
              if(tp){
                if(tp===canonTeam(e.away_team)) sideBase='AWAY';
                else if(tp===canonTeam(e.home_team)) sideBase='HOME';
              }
            }
            const key = `${game}|${type}|${(sideBase||'').toUpperCase()}|${lineVal!=null? Number(lineVal): ''}`;
            if(sideBase && (lineVal!=null || type!=='total')) evalCorrectness.set(key, !!e.bet_won);
            const skey = `${game}|${type}|${(sideBase||'').toUpperCase()}|*`; if(sideBase) evalSideOnly.set(skey, !!e.bet_won);
          }catch(_){ /* ignore */ }
        });

        const finalScores = new Map();
        const gr = (data.roi_analysis && data.roi_analysis.game_results) || [];
        gr.forEach(g=>{
          const gname = `${g.away_team} @ ${g.home_team}`;
          let away=0, home=0; if(g.final_score){ const p=String(g.final_score).split('-'); if(p.length===2){ away=Number(p[0]); home=Number(p[1]); } }
          finalScores.set(gname, {away_team:g.away_team, home_team:g.home_team, away_score:away, home_score:home});
        });

        // Evaluate only the recs shown today
        const unit=100;
        let resolved=0, wins=0, profit=0;
        recs.forEach(r=>{
          const game = r.game || `${r.away_team||''} @ ${r.home_team||''}`;
          let type = String(r.type||'').toLowerCase();
          if(type==='over/under' || type.startsWith('total')) type='total';
          if(type==='ml' || type.startsWith('moneyline')) type='moneyline';
          if(type.startsWith('run')) type='run_line';
          const pick = r.recommendation || '';
          let side=null, line=null;
          if(type==='total'){
            const parsed = parseSideLine(pick); side=parsed.side; line = parsed.line ?? (r.betting_line!=null? Number(r.betting_line): null);
          } else if(type==='moneyline'){
            const teamPick = parseMoneylineTeam(pick);
            if(teamPick){
              const tp = canonTeam(teamPick);
              const awayName = r.away_team ? canonTeam(r.away_team) : null;
              const homeName = r.home_team ? canonTeam(r.home_team) : null;
              if(awayName && tp===awayName) side='AWAY'; else if(homeName && tp===homeName) side='HOME';
            }
          }
          const sideKey=(side||'').toUpperCase();
          const key = `${game}|${type}|${sideKey}|${line!=null? Number(line): ''}`;
          let correct = evalCorrectness.has(key) ? evalCorrectness.get(key) : undefined;
          if(correct===undefined && type==='total'){ const wkey = `${game}|${type}|${sideKey}|*`; if(evalSideOnly.has(wkey)) correct = evalSideOnly.get(wkey); }
          if(correct===undefined && finalScores.has(game)){
            const fs = finalScores.get(game);
            if(type==='total' && sideKey && (line!=null)){
              const total = Number(fs.away_score)+Number(fs.home_score);
              if(!isNaN(total)){
                const ln = Number(line);
                if(total===ln) correct = 'PUSH'; else correct = sideKey==='OVER' ? (total>ln) : (total<ln);
              }
            } else if(type==='moneyline'){ const winner = (Number(fs.away_score) > Number(fs.home_score)) ? 'AWAY' : 'HOME'; if(sideKey==='AWAY'||sideKey==='HOME') correct = (sideKey===winner); }
          }
          if(correct!==undefined){
            if(correct!=='PUSH'){ resolved += 1; if(correct===true) wins += 1; }
            const odds = parseAmericanOdds(r.american_odds ?? r.odds);
            if(correct===true){ profit += odds>0 ? (unit * odds/100) : (unit * 100/Math.abs(odds)); }
            else if (correct===false) { profit -= unit; }
          }
        });

        const accPct = resolved ? (wins/resolved*100) : 0;
        const totalBet = resolved * 100;
        const roiPct = totalBet ? (profit/totalBet*100) : 0;
        const tiles=[
          {label:'Rec Accuracy', val: accPct.toFixed(1)+'%'},
          {label:'Total Recs', val: (recs?.length||0)},
          {label:'ROI %', val: roiPct.toFixed(1)+'%'},
          {label:'Net Profit', val: '$'+profit.toFixed(2)}
        ];
        tiles.forEach(t=>{ const d=document.createElement('div'); d.className='stat'; d.innerHTML=`<div class='num'>${t.val}</div><div class='muted'>${t.label}</div>`; grid.appendChild(d); });
      }catch(e){ console.warn('Failed to load today recap', e); }
    }
    async function loadDayPerformance(){
      const day=document.getElementById('hist-day').value; if(!day) return;
      const res=await fetch(`/api/historical-analysis/date/${day}`);
      let data = {};
      if(res.ok){
        const raw=await res.json();
        data = raw && raw.data ? raw.data : raw;
      } else {
        // Proceed with minimal data; we'll rely on per-day recs and final-scores route if present
        data = {};
      }
  const grid=document.getElementById('day-grid'); grid.innerHTML='';
      // Build recommendations table pulling directly from the per-day betting recommendations file
      const recDiv = document.getElementById('day-recs');
      try{
        // 1) Primary source: evaluated recommendations from historical API
        // Build correctness map from data.betting_recommendations.recommendations_evaluated
        const evalCorrectness = new Map();
        const evalSideOnly = new Map(); // key = game|type|SIDE|*
        const evals = (data.betting_recommendations && data.betting_recommendations.recommendations_evaluated) || [];
        evals.forEach(e=>{
          try{
            const game = `${e.away_team} @ ${e.home_team}`;
            // Normalize type
            let type = String(e.bet_type||'').toLowerCase();
            if(type.startsWith('total')) type = 'total';
            if(type.startsWith('moneyline') || type==='ml') type = 'moneyline';
            if(type.startsWith('run')) type = 'run_line';
            const recTxt = String(e.recommendation||'').trim();
            let sideBase=null, lineVal=null;
            if(type==='total'){
              const parsed = parseSideLine(recTxt);
              sideBase = parsed.side; lineVal = parsed.line;
            } else if(type==='moneyline'){
              const teamPick = parseMoneylineTeam(recTxt);
              const tp = canonTeam(teamPick);
              if(tp){
                if(tp===canonTeam(e.away_team)) sideBase='AWAY';
                else if(tp===canonTeam(e.home_team)) sideBase='HOME';
              }
            }
            const key = `${game}|${type}|${(sideBase||'').toUpperCase()}|${lineVal!=null? Number(lineVal): ''}`;
            const nkey = `${normGameKey(game)}|${type}|${(sideBase||'').toUpperCase()}|${lineVal!=null? Number(lineVal): ''}`;
            if(sideBase && (lineVal!=null || type!=='total')){
              evalCorrectness.set(key, !!e.bet_won);
              evalCorrectness.set(nkey, !!e.bet_won);
            }
            const skey = `${game}|${type}|${(sideBase||'').toUpperCase()}|*`;
            const nskey = `${normGameKey(game)}|${type}|${(sideBase||'').toUpperCase()}|*`;
            if(sideBase){ evalSideOnly.set(skey, !!e.bet_won); evalSideOnly.set(nskey, !!e.bet_won); }
          }catch(_){/* ignore single eval parse errors */}
        });

        // 2) Secondary source: game cards recommendations map
        // Build correctness map from historical cards: key = game|type|SIDE|line and side-only wildcard
        const correctness = new Map();
        const sideOnlyCorrectness = new Map(); // key = game|type|SIDE|*
        const cards = data.game_cards || [];
        cards.forEach(card=>{
          const g = gameKey(card.away_team, card.home_team);
          const ng = normGameKey(g);
          (card.recommendations||[]).forEach(r=>{
            // Normalize type
            let type = String(r.type||'').toLowerCase();
            if(type.startsWith('total')) type = 'total';
            if(type.startsWith('moneyline')) type = 'moneyline';
            if(type.startsWith('run')) type = 'run_line';

            // Normalize side and line from historical card
      const rawSide = String((r.side!=null && r.side!=='') ? r.side : (r.pick!=null ? r.pick : r.recommendation||'')).trim();
            let sideBase = null;
            let lineVal = null;
            // Try to parse totals
            const parsed = parseSideLine(rawSide);
            if(parsed.side){ sideBase = parsed.side; }
            if(parsed.line != null){ lineVal = Number(parsed.line); }
            // If still missing, use fields
            if((lineVal==null || isNaN(lineVal)) && (r.line!=null && r.line!=='')) lineVal = Number(r.line);
            // Moneyline: map team text to HOME/AWAY if present
            if(type==='moneyline' && !sideBase){
              const rsn = normalizeTeamName(rawSide);
              if(rsn){
                if(rsn === normalizeTeamName(card.away_team)) sideBase = 'AWAY';
                else if(rsn === normalizeTeamName(card.home_team)) sideBase = 'HOME';
              }
              // Also accept explicit keywords
              const low = rawSide.toLowerCase();
              if(!sideBase && low.includes('away')) sideBase = 'AWAY';
              if(!sideBase && low.includes('home')) sideBase = 'HOME';
            }

  const key = `${g}|${type}|${(sideBase||'').toUpperCase()}|${lineVal}`;
  const nkey = `${ng}|${type}|${(sideBase||'').toUpperCase()}|${lineVal}`;
  const hasLine = (lineVal!==null && !Number.isNaN(Number(lineVal)));
  if(hasLine){ correctness.set(key, r.is_correct); correctness.set(nkey, r.is_correct); }
    const skey = `${g}|${type}|${(sideBase||'').toUpperCase()}|*`;
    const nskey = `${ng}|${type}|${(sideBase||'').toUpperCase()}|*`;
  sideOnlyCorrectness.set(skey, r.is_correct);
  sideOnlyCorrectness.set(nskey, r.is_correct);
          });
        });

        const recRes = await fetch(`/api/betting-recommendations/date/${day}`);
  if (recRes.ok) {
          const recData = await recRes.json();
          const recs = recData.recommendations || [];
          // Build final scores map (prefer direct API, fallback to ROI game results and game cards)
          const finalScores = new Map();
          try{
            // Fetch same-day final scores
            const fsRes = await fetch(`/api/historical-analysis/final-scores/${day}`);
            if(fsRes.ok){
              const fsData = await fsRes.json();
              const fs = fsData.final_scores || {};
              Object.values(fs).forEach(s=>{
                const awayName = s.away_team_display || s.away_team;
                const homeName = s.home_team_display || s.home_team;
                if(!awayName || !homeName) return;
                const gname = gameKey(awayName, homeName);
                const a = Number(s.away_score), h = Number(s.home_score);
                if(!isNaN(a) && !isNaN(h)){
                  finalScores.set(gname, {away_team:awayName, home_team:homeName, away_score:a, home_score:h});
                  finalScores.set(normGameKey(gname), {away_team:awayName, home_team:homeName, away_score:a, home_score:h});
                }
              });
            }
            // Merge next-day finals first (common for late games saved under next calendar date)
            const d0 = new Date(day + 'T00:00:00Z');
            const z = n=> String(n).padStart(2,'0');
            const next = new Date(d0.getTime() + 24*60*60*1000);
            const nextStr = `${next.getUTCFullYear()}-${z(next.getUTCMonth()+1)}-${z(next.getUTCDate())}`;
            const fsResNext = await fetch(`/api/historical-analysis/final-scores/${nextStr}`);
            if(fsResNext.ok){
              const fsDataN = await fsResNext.json();
              const fsN = fsDataN.final_scores || {};
              Object.values(fsN).forEach(s=>{
                const awayName = s.away_team_display || s.away_team;
                const homeName = s.home_team_display || s.home_team;
                if(!awayName || !homeName) return;
                const gname = gameKey(awayName, homeName);
                const a = Number(s.away_score), h = Number(s.home_score);
                if(!isNaN(a) && !isNaN(h)){
                  if(!finalScores.has(gname) && !finalScores.has(normGameKey(gname))){
                    finalScores.set(gname, {away_team:awayName, home_team:homeName, away_score:a, home_score:h});
                    finalScores.set(normGameKey(gname), {away_team:awayName, home_team:homeName, away_score:a, home_score:h});
                  }
                }
              });
            }

            // Then merge previous-day finals
            const prev = new Date(d0.getTime() - 24*60*60*1000);
            const prevStr = `${prev.getUTCFullYear()}-${z(prev.getUTCMonth()+1)}-${z(prev.getUTCDate())}`;
            const fsResPrev = await fetch(`/api/historical-analysis/final-scores/${prevStr}`);
            if(fsResPrev.ok){
              const fsDataP = await fsResPrev.json();
              const fsP = fsDataP.final_scores || {};
              Object.values(fsP).forEach(s=>{
                const awayName = s.away_team_display || s.away_team;
                const homeName = s.home_team_display || s.home_team;
                if(!awayName || !homeName) return;
                const gname = gameKey(awayName, homeName);
                const a = Number(s.away_score), h = Number(s.home_score);
                if(!isNaN(a) && !isNaN(h)){
                  if(!finalScores.has(gname) && !finalScores.has(normGameKey(gname))){
                    finalScores.set(gname, {away_team:awayName, home_team:homeName, away_score:a, home_score:h});
                    finalScores.set(normGameKey(gname), {away_team:awayName, home_team:homeName, away_score:a, home_score:h});
                  }
                }
              });
            }
          }catch(_){ /* ignore and use fallbacks below */ }
          const gr = (data.roi_analysis && data.roi_analysis.game_results) || [];
          gr.forEach(g=>{
            const gname = gameKey(g.away_team, g.home_team);
            let away=0, home=0;
            if (g.final_score) {
              const parts = String(g.final_score).split('-');
              if(parts.length===2){ away = Number(parts[0]); home = Number(parts[1]); }
            }
            if(!finalScores.has(gname)){
              finalScores.set(gname, {away_team:g.away_team, home_team:g.home_team, away_score:away, home_score:home});
              finalScores.set(normGameKey(gname), {away_team:g.away_team, home_team:g.home_team, away_score:away, home_score:home});
            }
          });
          const cardsFs = data.game_cards || [];
          cardsFs.forEach(card=>{
            const fs = card.final_scores || {};
            const a = Number(fs.away_score), h = Number(fs.home_score);
            if(!isNaN(a) && !isNaN(h)){
              const gname = gameKey(card.away_team, card.home_team);
              if(!finalScores.has(gname)){
                finalScores.set(gname, {away_team:card.away_team, home_team:card.home_team, away_score:a, home_score:h});
                finalScores.set(normGameKey(gname), {away_team:card.away_team, home_team:card.home_team, away_score:a, home_score:h});
              }
              // Also add a '@'-key for compatibility with rec.game format
              const compatKey = `${card.away_team} @ ${card.home_team}`;
              if(!finalScores.has(compatKey)){
                finalScores.set(compatKey, {away_team:card.away_team, home_team:card.home_team, away_score:a, home_score:h});
                finalScores.set(normGameKey(compatKey), {away_team:card.away_team, home_team:card.home_team, away_score:a, home_score:h});
              }
            }
          });

          const rows = recs.map(r=>{
            const game = r.game || `${r.away_team||''} @ ${r.home_team||''}`;
            const ngame = normGameKey(game);
            let type = String(r.type||'').toLowerCase();
            if(type==='over/under' || type.startsWith('total')) type='total';
            if(type==='ml' || type.startsWith('moneyline')) type='moneyline';
            if(type.startsWith('run')) type='run_line';
            const pick = r.recommendation || '';
            let side=null, line=null;
            if(type==='total'){
              // Primary parse from recommendation
              const parsed = parseSideLine(pick);
              side = parsed.side; line = parsed.line;
              // Supplemental: common fields from rec object
              if(!side && r.side){ const ps = parseSideLine(String(r.side)); if(ps.side) side = ps.side; if(ps.line!=null && line==null) line = Number(ps.line); }
              if(!side && r.pick){ const ps = parseSideLine(String(r.pick)); if(ps.side) side = ps.side; if(ps.line!=null && line==null) line = Number(ps.line); }
              if(line==null && r.betting_line!=null) line = Number(r.betting_line);
              if(line==null && r.line!=null) line = Number(r.line);
              if(line==null && r.total_line!=null) line = Number(r.total_line);
              // Last resort: infer side from bet text itself (e.g., "TOTAL Under 9.0" style already handled), else from fields casing
              if(!side){
                const betTxt = String(r.type||'') + ' ' + String(r.recommendation||'') + ' ' + String(r.side||'') + ' ' + String(r.pick||'');
                const low = betTxt.toLowerCase();
                if(low.includes(' under ')) side = 'UNDER';
                else if(low.includes(' over ')) side = 'OVER';
              }
            } else if(type==='moneyline'){
              // Derive HOME/AWAY from team name match
              const teamPick = parseMoneylineTeam(pick);
              const fs = finalScores.get(game) || finalScores.get(ngame);
              if(teamPick){
                const tp = normalizeTeamName(teamPick);
                // Prefer comparing to known away/home from rec when available
                const awayName = r.away_team ? normalizeTeamName(r.away_team) : null;
                const homeName = r.home_team ? normalizeTeamName(r.home_team) : null;
                if(awayName && tp===awayName) side='AWAY';
                else if(homeName && tp===homeName) side='HOME';
                // Otherwise compare using finalScores mapping if present
                if(!side && fs){
                  const isAway = tp === normalizeTeamName(fs.away_team);
                  const isHome = tp === normalizeTeamName(fs.home_team);
                  if(isAway) side = 'AWAY'; else if(isHome) side = 'HOME';
                }
                // Last resort: parse from the game string
                if(!side && game.includes('@')){
                  const parts = game.split('@');
                  const gAway = normalizeTeamName(parts[0].trim());
                  const gHome = normalizeTeamName(parts[1].trim());
                  if(tp===gAway) side='AWAY'; else if(tp===gHome) side='HOME';
                }
              }
            }
            const sideKey = (side||'').toUpperCase();
            const key = `${game}|${type}|${sideKey}|${line!=null? Number(line): ''}`;
            const nkey = `${ngame}|${type}|${sideKey}|${line!=null? Number(line): ''}`;
            // Priority 1: evaluated recs
            let correct = evalCorrectness.has(key) ? evalCorrectness.get(key) : (evalCorrectness.has(nkey) ? evalCorrectness.get(nkey) : undefined);
            if(correct === undefined && type==='total'){
              const wkey = `${game}|${type}|${sideKey}|*`;
              const nwkey = `${ngame}|${type}|${sideKey}|*`;
              if(evalSideOnly.has(wkey)) correct = evalSideOnly.get(wkey); else if(evalSideOnly.has(nwkey)) correct = evalSideOnly.get(nwkey);
            }
            // Priority 2: cards (only accept boolean or 'PUSH'; ignore null to allow fallback)
            if(correct === undefined){
              let v = correctness.has(key) ? correctness.get(key) : (correctness.has(nkey) ? correctness.get(nkey) : undefined);
              if(v === true || v === false || v === 'PUSH') correct = v;
            }
            if(correct === undefined && type==='total'){
              const wkey = `${game}|${type}|${sideKey}|*`;
              const nwkey = `${ngame}|${type}|${sideKey}|*`;
              let v = sideOnlyCorrectness.has(wkey) ? sideOnlyCorrectness.get(wkey) : (sideOnlyCorrectness.has(nwkey) ? sideOnlyCorrectness.get(nwkey) : undefined);
              if(v === true || v === false || v === 'PUSH') correct = v;
            }
            // Fallback correctness computation from final score when available
            let fs = finalScores.get(game) || finalScores.get(ngame);
            // If not found, try building an alternate key from rec away/home when present
            if(!fs){
              const parts = game.includes('@') ? game.split('@') : [];
              const altAway = (r.away_team || (parts[0] ? parts[0].trim() : null));
              const altHome = (r.home_team || (parts[1] ? parts[1].trim() : null));
              if(altAway && altHome){
                const altKey = `${altAway} @ ${altHome}`;
                fs = finalScores.get(altKey) || finalScores.get(normGameKey(altKey));
              }
            }
            // Last resort: scan the map for normalized away/home match
            if(!fs && game.includes('@')){
              const parts = game.split('@');
              const wantAway = normalizeTeamName(parts[0].trim());
              const wantHome = normalizeTeamName(parts[1].trim());
              for(const v of finalScores.values()){
                if(v && normalizeTeamName(v.away_team||'')===wantAway && normalizeTeamName(v.home_team||'')===wantHome){ fs = v; break; }
              }
            }
            if(correct === undefined && fs){
              if(type==='total' && sideKey && (line!=null)){
                const total = Number(fs.away_score) + Number(fs.home_score);
                const ln = Number(line);
                if(!isNaN(total) && !isNaN(ln)){
                  if(total===ln) correct = 'PUSH';
                  else correct = sideKey==='OVER' ? (total>ln) : (total<ln);
                }
              } else if(type==='moneyline'){
                const winner = (Number(fs.away_score) > Number(fs.home_score)) ? 'AWAY' : 'HOME';
                if(sideKey==='AWAY' || sideKey==='HOME') correct = (sideKey === winner);
              }
            }
            // Debug aid: surface unresolved totals to console
            if(correct === undefined && type==='total'){
              const sideKeyDbg = (side||'').toUpperCase();
              // eslint-disable-next-line no-console
              console.debug('Unresolved total rec', { game, side: sideKeyDbg, line, hasFS: !!fs });
            }
            return {
              game,
              bet: `${String(r.type||'').replace('_',' ').toUpperCase()} ${pick}`.trim(),
              odds: r.american_odds ?? r.odds,
              conf: String(r.confidence||'').toUpperCase(),
              ev: r.expected_value,
              correct
            };
          });
          rows.sort((a,b)=> confOrder(b.conf)-confOrder(a.conf) || (Number(b.ev||0)-Number(a.ev||0)));
          recDiv.innerHTML = rows.length ? ('<div class="table-wrap"><table class="table"><thead><tr><th>Game</th><th>Bet</th><th>Odds</th><th>Conf</th><th>EV</th><th>Correct</th></tr></thead><tbody>' +
            rows.map(r=>`<tr><td>${r.game}</td><td>${r.bet}</td><td>${r.odds}</td><td><span class="badge ${r.conf}">${r.conf}</span></td><td>${fmtEV(r.ev)}</td><td>${checkIcon(r.correct)}</td></tr>`).join('') +
          '</tbody></table></div>') : '<div class="muted">No recommendations found for this date.</div>';

          // Build recap tiles using variable stake by confidence
          const stakeByConf = { HIGH: 100, MEDIUM: 50, LOW: 25 };
          let resolved=0, wins=0, totalStake=0, profit=0;
          const level = {
            HIGH: { resolved:0, wins:0, stake:0, profit:0 },
            MEDIUM: { resolved:0, wins:0, stake:0, profit:0 },
            LOW: { resolved:0, wins:0, stake:0, profit:0 }
          };
          rows.forEach(r=>{
            if(r.correct===undefined || r.correct==='PUSH') return;
            const stake = stakeByConf[r.conf] ?? 0;
            const odds = parseAmericanOdds(r.odds);
            resolved += 1; wins += (r.correct===true ? 1 : 0); totalStake += stake;
            if(r.correct===true){ profit += odds>0 ? (stake*odds/100) : (stake*100/Math.abs(odds)); }
            else if(r.correct===false) { profit -= stake; }
            if(level[r.conf]){
              level[r.conf].resolved += 1;
              level[r.conf].wins += (r.correct===true ? 1 : 0);
              level[r.conf].stake += stake;
              if(r.correct===true){ level[r.conf].profit += odds>0 ? (stake*odds/100) : (stake*100/Math.abs(odds)); }
              else if(r.correct===false) { level[r.conf].profit -= stake; }
            }
          });
          const accPct = resolved ? (wins/resolved*100) : 0;
          const roiPct = totalStake ? (profit/totalStake*100) : 0;
          const tilesHtml = [
            {label:'Rec Accuracy', val: accPct.toFixed(1)+'%'},
            {label:'Total Recs', val: recs.length},
            {label:'ROI %', val: roiPct.toFixed(1)+'%'},
            {label:'Net Profit', val: '$'+profit.toFixed(2)}
          ].map(t=>`<div class='stat'><div class='num'>${t.val}</div><div class='muted'>${t.label}</div></div>`).join('');
          grid.innerHTML = tilesHtml;

          // Render by-confidence KPIs
          const levelGrid = document.getElementById('day-level-grid');
          const levelStats = [
            { key:'HIGH', label:'High' },
            { key:'MEDIUM', label:'Medium' },
            { key:'LOW', label:'Low' }
          ].map(({key,label})=>{
            const m = level[key];
            const acc = m.resolved ? (m.wins/m.resolved*100) : 0;
            const roi = m.stake ? (m.profit/m.stake*100) : 0;
            return `<div class='stat'><div class='num'>${acc.toFixed(1)}%</div><div class='muted'>${label} Accuracy</div><div class='muted'>ROI: ${roi.toFixed(1)}% â€¢ Profit: $${m.profit.toFixed(2)}</div><div class='muted'>${m.resolved} bets</div></div>`;
          }).join('');
          levelGrid.innerHTML = levelStats;
        } else {
          // Fallback: use historical game cards (may be incomplete vs raw file)
          const cards = data.game_cards || [];
          const rows=[];
          cards.forEach(card=>{
            const game = `${card.away_team} @ ${card.home_team}`;
            (card.recommendations||[]).forEach(r=>{
              rows.push({
                game,
                bet:`${(r.type||'').replace('_',' ').toUpperCase()} ${r.pick||''}`,
                odds:r.odds, conf:String(r.confidence||'').toUpperCase(), ev:r.expected_value, correct:r.is_correct
              });
            });
          });
          rows.sort((a,b)=> confOrder(b.conf)-confOrder(a.conf) || (Number(b.ev||0)-Number(a.ev||0)));
          recDiv.innerHTML = rows.length ? ('<div class="table-wrap"><table class="table"><thead><tr><th>Game</th><th>Bet</th><th>Odds</th><th>Conf</th><th>EV</th><th>Correct</th></tr></thead><tbody>' +
            rows.map(r=>`<tr><td>${r.game}</td><td>${r.bet}</td><td>${r.odds}</td><td><span class="badge ${r.conf}">${r.conf}</span></td><td>${fmtEV(r.ev)}</td><td>${checkIcon(r.correct)}</td></tr>`).join('') +
          '</tbody></table></div>') : '<div class="muted">No recommendations found for this date.</div>';

          // Recap from fallback rows (constant stake to avoid colliding identifiers)
          const unitFB=100; let resolvedFB=0, winsFB=0, profitFB=0;
          rows.forEach(r=>{ if(r.correct===undefined || r.correct==='PUSH') return; resolvedFB+=1; if(r.correct===true) winsFB+=1; const odds=parseAmericanOdds(r.odds); if(r.correct===true){ profitFB += odds>0 ? (unitFB*odds/100) : (unitFB*100/Math.abs(odds)); } else if(r.correct===false) { profitFB -= unitFB; } });
          const accPct = resolvedFB ? (winsFB/resolvedFB*100) : 0;
          const roiPct = resolvedFB ? (profitFB/(resolvedFB*unitFB)*100) : 0;
          grid.innerHTML = [
            {label:'Rec Accuracy', val: accPct.toFixed(1)+'%'},
            {label:'Total Recs', val: rows.length},
            {label:'ROI %', val: roiPct.toFixed(1)+'%'},
            {label:'Net Profit', val: '$'+profitFB.toFixed(2)}
          ].map(t=>`<div class='stat'><div class='num'>${t.val}</div><div class='muted'>${t.label}</div></div>`).join('');
        }
      }catch(e){ recDiv.innerHTML='<div class="muted">Unable to load recommendations for this date.</div>'; }
    }
    // Expose range loader at global scope
    async function loadRangePerformance(){
      const start = document.getElementById('range-start').value;
      const end = document.getElementById('range-end').value;
      if(!start || !end) return;
      try{
        // We'll aggregate by fetching per-day rec files and final scores for all days in range
        const datesRes = await fetch('/api/historical-analysis/available-dates');
        if(!datesRes.ok){
          document.getElementById('range-grid').innerHTML='';
          document.getElementById('range-recs').innerHTML='<div class="muted">Historical service unavailable.</div>';
          return;
        }
        const datesData = await datesRes.json();
        const allDates = (datesData.dates || datesData.available_dates || []).filter(d=> d>=start && d<=end);
        if(!allDates.length){
          document.getElementById('range-grid').innerHTML='';
          document.getElementById('range-recs').innerHTML='<div class="muted">No data in selected range.</div>';
          return;
        }

    // Parallel fetch of day analyses for evaluated correctness and final scores
    const dayAnalyses = await Promise.all(allDates.map(async d=>{
          try{
            const r = await fetch(`/api/historical-analysis/date/${d}`);
            if(!r.ok) return { date: d, data: null };
            const j = await r.json();
            return { date: d, data: (j && j.data ? j.data : j) };
          }catch(_){ return { date: d, data: null }; }
        }));

  // Build KPI aggregation and rows list
        const rows=[];
        for (const entry of dayAnalyses){
          if(!entry || !entry.data) continue;
          const data = entry.data;
          // Use evaluated recs when available; else fall back to cards
          const evals = (data.betting_recommendations && data.betting_recommendations.recommendations_evaluated) || [];
          const cards = data.game_cards || [];
          const finalScores = new Map();
          // Gather final scores from ROI results and cards
          const gr = (data.roi_analysis && data.roi_analysis.game_results) || [];
          gr.forEach(g=>{ const gname = `${g.away_team} @ ${g.home_team}`; let a=0,h=0; if(g.final_score){ const p=String(g.final_score).split('-'); if(p.length===2){ a=Number(p[0]); h=Number(p[1]); } } finalScores.set(gname,{away_team:g.away_team,home_team:g.home_team,away_score:a,home_score:h}); finalScores.set(normGameKey(gname),{away_team:g.away_team,home_team:g.home_team,away_score:a,home_score:h}); });
          cards.forEach(c=>{ const fs=c.final_scores||{}; const a=Number(fs.away_score), h=Number(fs.home_score); if(!isNaN(a)&&!isNaN(h)){ const g=`${c.away_team} @ ${c.home_team}`; finalScores.set(g,{away_team:c.away_team,home_team:c.home_team,away_score:a,home_score:h}); finalScores.set(normGameKey(g),{away_team:c.away_team,home_team:c.home_team,away_score:a,home_score:h}); } });
          // Also try normalized final scores API per date and adjacent days (next first, then prev)
          try{
            const z = n=> String(n).padStart(2,'0');
            // Same day
            const fsRes = await fetch(`/api/historical-analysis/final-scores/${entry.date}`);
            if(fsRes.ok){ const fsData = await fsRes.json(); const fs = fsData.final_scores || {}; Object.values(fs).forEach(s=>{ const awayName = s.away_team_display || s.away_team; const homeName = s.home_team_display || s.home_team; const gname = `${awayName} @ ${homeName}`; const a = Number(s.away_score), h = Number(s.home_score); if(!isNaN(a)&&!isNaN(h)){ finalScores.set(gname, {away_team:awayName, home_team:homeName, away_score:a, home_score:h}); finalScores.set(normGameKey(gname), {away_team:awayName, home_team:homeName, away_score:a, home_score:h}); } }); }
            // Next day
            const d0 = new Date(entry.date + 'T00:00:00Z');
            const next = new Date(d0.getTime() + 24*60*60*1000);
            const nextStr = `${next.getUTCFullYear()}-${z(next.getUTCMonth()+1)}-${z(next.getUTCDate())}`;
            const fsResNext = await fetch(`/api/historical-analysis/final-scores/${nextStr}`);
            if(fsResNext.ok){ const fsDataN = await fsResNext.json(); const fsN = fsDataN.final_scores || {}; Object.values(fsN).forEach(s=>{ const awayName = s.away_team_display || s.away_team; const homeName = s.home_team_display || s.home_team; if(!awayName||!homeName) return; const gname = `${awayName} @ ${homeName}`; const a = Number(s.away_score), h = Number(s.home_score); if(!isNaN(a)&&!isNaN(h)){ if(!finalScores.has(gname) && !finalScores.has(normGameKey(gname))){ finalScores.set(gname, {away_team:awayName, home_team:homeName, away_score:a, home_score:h}); finalScores.set(normGameKey(gname), {away_team:awayName, home_team:homeName, away_score:a, home_score:h}); } } }); }
            // Previous day
            const prev = new Date(d0.getTime() - 24*60*60*1000);
            const prevStr = `${prev.getUTCFullYear()}-${z(prev.getUTCMonth()+1)}-${z(prev.getUTCDate())}`;
            const fsResPrev = await fetch(`/api/historical-analysis/final-scores/${prevStr}`);
            if(fsResPrev.ok){ const fsDataP = await fsResPrev.json(); const fsP = fsDataP.final_scores || {}; Object.values(fsP).forEach(s=>{ const awayName = s.away_team_display || s.away_team; const homeName = s.home_team_display || s.home_team; if(!awayName||!homeName) return; const gname = `${awayName} @ ${homeName}`; const a = Number(s.away_score), h = Number(s.home_score); if(!isNaN(a)&&!isNaN(h)){ if(!finalScores.has(gname) && !finalScores.has(normGameKey(gname))){ finalScores.set(gname, {away_team:awayName, home_team:homeName, away_score:a, home_score:h}); finalScores.set(normGameKey(gname), {away_team:awayName, home_team:homeName, away_score:a, home_score:h}); } } }); }
          }catch(_){ /* optional */ }

          // Build evaluated correctness map
          const evalCorrectness=new Map(); const evalSideOnly=new Map();
          evals.forEach(e=>{
            try{
              const game = `${e.away_team} @ ${e.home_team}`;
              let type=String(e.bet_type||'').toLowerCase();
              if(type.startsWith('total')) type='total';
              if(type.startsWith('moneyline')||type==='ml') type='moneyline';
              if(type.startsWith('run')) type='run_line';
              let sideBase=null, lineVal=null; const recTxt=String(e.recommendation||'');
              if(type==='total'){ const parsed=parseSideLine(recTxt); sideBase=parsed.side; lineVal=parsed.line; }
              else if(type==='moneyline'){ const teamPick=parseMoneylineTeam(recTxt); const tp=teamPick?canonTeam(teamPick):null; if(tp){ if(tp===canonTeam(e.away_team)) sideBase='AWAY'; else if(tp===canonTeam(e.home_team)) sideBase='HOME'; } }
              const key = `${game}|${type}|${(sideBase||'').toUpperCase()}|${lineVal!=null? Number(lineVal): ''}`;
              const skey = `${game}|${type}|${(sideBase||'').toUpperCase()}|*`;
              if(sideBase && (lineVal!=null || type!=='total')) evalCorrectness.set(key, !!e.bet_won);
              if(sideBase) evalSideOnly.set(skey, !!e.bet_won);
            }catch(_){ }
          });

          // Try to fetch per-day recommendations (primary source for list)
          let recs = [];
          try{
            const recRes = await fetch(`/api/betting-recommendations/date/${entry.date}`);
            if(recRes.ok){ const recData = await recRes.json(); recs = recData.recommendations || []; }
          }catch(_){ /* ignore */ }
          const currentDate = entry.date;
          const addRow = (game, typeNorm, pick, odds, conf, ev, lineHint=null, extraFields={})=>{
            // typeNorm must already be one of: total | moneyline | run_line | other
            const parsed = parseSideLine(pick);
            let side = parsed.side;
            let line = parsed.line != null ? Number(parsed.line) : (lineHint!=null ? Number(lineHint) : null);
            if(typeNorm==='total'){
              if(!side && extraFields.side){ const ps = parseSideLine(String(extraFields.side)); if(ps.side) side = ps.side; if(ps.line!=null && line==null) line = Number(ps.line); }
              if(!side && extraFields.pick){ const ps = parseSideLine(String(extraFields.pick)); if(ps.side) side = ps.side; if(ps.line!=null && line==null) line = Number(ps.line); }
              if(line==null && extraFields.total_line!=null) line = Number(extraFields.total_line);
              if(line==null && extraFields.line!=null) line = Number(extraFields.line);
              if(line==null && extraFields.betting_line!=null) line = Number(extraFields.betting_line);
            }
            if(typeNorm==='moneyline' && !side){
              const rsn = normalizeTeamName(pick);
              const parts = game.split('@');
              if(parts.length===2){
                const awayT = normalizeTeamName(parts[0].trim());
                const homeT = normalizeTeamName(parts[1].trim());
                if(rsn===awayT) side='AWAY'; else if(rsn===homeT) side='HOME';
              }
            }
            const sideKey=(side||'').toUpperCase();
            const key = `${game}|${typeNorm}|${sideKey}|${line!=null? Number(line): ''}`;
            let correct = evalCorrectness.has(key) ? evalCorrectness.get(key) : undefined;
            if(correct===undefined && typeNorm==='total'){ const wkey = `${game}|${typeNorm}|${sideKey}|*`; if(evalSideOnly.has(wkey)) correct = evalSideOnly.get(wkey); }
            if(correct===undefined){
              const fs = finalScores.get(game) || finalScores.get(normGameKey(game));
              if(fs){
                if(typeNorm==='total' && sideKey && (line!=null)){
                  const total = Number(fs.away_score)+Number(fs.home_score);
                  const ln = Number(line);
                  if(!isNaN(total) && !isNaN(ln)){
                    if(total===ln) correct = 'PUSH';
                    else correct = sideKey==='OVER' ? (total>ln) : (total<ln);
                  }
                } else if(typeNorm==='moneyline'){
                  const winner = (Number(fs.away_score)>Number(fs.home_score)) ? 'AWAY' : 'HOME';
                  if(sideKey==='AWAY'||sideKey==='HOME') correct = (sideKey===winner);
                }
              }
            }
            rows.push({
              date: currentDate,
              game,
              bet: `${String(typeNorm||'').replace('_',' ').toUpperCase()} ${pick}`.trim(),
              odds,
              conf: String(conf||'').toUpperCase(),
              ev,
              correct
            });
          };

          if(recs.length){
            // Build rows from per-day recommendations (preferred)
            recs.forEach(r=>{
              const game = r.game || `${r.away_team||''} @ ${r.home_team||''}`;
              let type = String(r.type||'').toLowerCase();
              if(type==='over/under' || type.startsWith('total')) type='total';
              else if(type==='ml' || type.startsWith('moneyline')) type='moneyline';
              else if(type.startsWith('run')) type='run_line';
              const pick = r.recommendation || '';
              let lineHint = null;
              if(type==='total') lineHint = (r.betting_line!=null? Number(r.betting_line): (r.line!=null? Number(r.line): (r.total_line!=null? Number(r.total_line): null)));
              const odds = r.american_odds ?? r.odds;
              const conf = r.confidence;
              const ev = r.expected_value;
              addRow(game, type, pick, odds, conf, ev, lineHint, { side: r.side, pick: r.pick, line: r.line, total_line: r.total_line, betting_line: r.betting_line });
            });
          } else {
            // Fallback to cards' recs if recs file missing
            cards.forEach(card=>{
              const game = `${card.away_team} @ ${card.home_team}`;
              (card.recommendations||[]).forEach(r=>{
                let type=String(r.type||'').toLowerCase();
                if(type.startsWith('total')) type='total'; else if(type.startsWith('moneyline')) type='moneyline'; else if(type.startsWith('run')) type='run_line';
                const pick = String((r.side!=null && r.side!=='') ? r.side : (r.pick!=null ? r.pick : r.recommendation||''));
                const odds = r.american_odds ?? r.odds; const conf = r.confidence; const ev = r.expected_value;
                const lineHint = (r.line!=null? Number(r.line): null);
                addRow(game, type, pick, odds, conf, ev, lineHint, { side: r.side, pick: r.pick, line: r.line, total_line: r.total_line, betting_line: r.betting_line });
              });
            });
          }
        }

        // Sort and render rows
        rows.sort((a,b)=> confOrder(b.conf)-confOrder(a.conf) || (Number(b.ev||0)-Number(a.ev||0)));
        const recDiv = document.getElementById('range-recs');
  recDiv.innerHTML = rows.length ? ('<div class="table-wrap"><table class="table"><thead><tr><th>Date</th><th>Game</th><th>Bet</th><th>Odds</th><th>Conf</th><th>EV</th><th>Correct</th></tr></thead><tbody>' +
    rows.map(r=>`<tr><td>${r.date||''}</td><td>${r.game}</td><td>${r.bet}</td><td>${r.odds||''}</td><td><span class="badge ${r.conf}">${r.conf}</span></td><td>${fmtEV(r.ev)}</td><td>${checkIcon(r.correct)}</td></tr>`).join('') +
  '</tbody></table></div>') : '<div class="muted">No recommendations in this range.</div>';

  // Compute KPI tiles using variable stake by confidence
  const stakeByConfR = { HIGH: 100, MEDIUM: 50, LOW: 25 };
  let resolved=0, wins=0, totalStake=0, profit=0;
  const levelR = {
    HIGH: { resolved:0, wins:0, stake:0, profit:0 },
    MEDIUM: { resolved:0, wins:0, stake:0, profit:0 },
    LOW: { resolved:0, wins:0, stake:0, profit:0 }
  };
  rows.forEach(r=>{
    if(r.correct===undefined || r.correct==='PUSH') return;
    const stake = stakeByConfR[r.conf] ?? 0;
    const odds = parseAmericanOdds(r.odds);
    resolved += 1; wins += (r.correct===true ? 1 : 0); totalStake += stake;
    if(r.correct===true){ profit += odds>0 ? (stake*odds/100) : (stake*100/Math.abs(odds)); }
    else if(r.correct===false) { profit -= stake; }
    if(levelR[r.conf]){
      levelR[r.conf].resolved += 1;
      levelR[r.conf].wins += (r.correct===true ? 1 : 0);
      levelR[r.conf].stake += stake;
      if(r.correct===true){ levelR[r.conf].profit += odds>0 ? (stake*odds/100) : (stake*100/Math.abs(odds)); }
      else if(r.correct===false) { levelR[r.conf].profit -= stake; }
    }
  });
  const accPct = resolved ? (wins/resolved*100) : 0;
  const roiPct = totalStake ? (profit/totalStake*100) : 0;
  const grid=document.getElementById('range-grid'); grid.innerHTML='';
  [
    {label:'Rec Accuracy', val: accPct.toFixed(1)+'%'},
    {label:'Total Recs', val: rows.length},
    {label:'ROI %', val: roiPct.toFixed(1)+'%'},
    {label:'Net Profit', val: '$'+profit.toFixed(2)}
  ].forEach(t=>{ const d=document.createElement('div'); d.className='stat'; d.innerHTML=`<div class='num'>${t.val}</div><div class='muted'>${t.label}</div>`; grid.appendChild(d); });

  // Render by-confidence KPIs for range
  const levelGridR = document.getElementById('range-level-grid');
  const levelStatsR = [
    { key:'HIGH', label:'High' },
    { key:'MEDIUM', label:'Medium' },
    { key:'LOW', label:'Low' }
  ].map(({key,label})=>{
    const m = levelR[key];
    const acc = m.resolved ? (m.wins/m.resolved*100) : 0;
    const roi = m.stake ? (m.profit/m.stake*100) : 0;
    return `<div class='stat'><div class='num'>${acc.toFixed(1)}%</div><div class='muted'>${label} Accuracy</div><div class='muted'>ROI: ${roi.toFixed(1)}% â€¢ Profit: $${m.profit.toFixed(2)}</div><div class='muted'>${m.resolved} bets</div></div>`;
  }).join('');
  levelGridR.innerHTML = levelStatsR;
      }catch(e){ console.warn('Failed to load range performance', e); }
    }
    loadPerformance(); loadToday(); loadAvailableDates();

    // =============== Pitcher Prop Snapshot (Today) ===============
    async function loadPropSnapshot(){
      try{
        const sel=document.getElementById('prop-market');
        const hideLow=document.getElementById('prop-hide-low').checked;
        const res = await fetch(`/api/pitcher-projections?date=${todayISO()}`);
        const data = await res.json();
        const cont = document.getElementById('prop-snapshot');
        if(!data.success){ cont.innerHTML = '<div class="muted">No projections available.</div>'; return; }
        const proj = data.projections||[];
        const rows = [];
        proj.forEach(p=>{
          const rec = p.recommendation;
          if(!rec) return;
          const market = rec.market;
          if(sel.value!=='ALL' && market!==sel.value) return;
          const edge = Number(rec.edge||0);
          const conf = edge>=1.0 ? 'HIGH' : edge>=0.7 ? 'MEDIUM' : 'LOW';
          if(hideLow && conf==='LOW') return;
          const line = (p.lines||{})[market];
          const projVal = (p.proj||{})[market];
          rows.push({
            pitcher: p.pitcher,
            team: p.team,
            opponent: p.opponent,
            market,
            side: rec.side,
            line,
            proj: projVal,
            edge,
            conf
          });
        });
        rows.sort((a,b)=> (b.edge||0)-(a.edge||0));
        cont.innerHTML = rows.length ? ('<div class="table-wrap"><table class="table"><thead><tr><th>Pitcher</th><th>Team</th><th>Market</th><th>Pick</th><th>Line</th><th>Proj</th><th>Edge</th><th>Conf</th></tr></thead><tbody>'+
          rows.map(r=>`<tr><td>${r.pitcher}</td><td>${r.team} vs ${r.opponent}</td><td>${r.market}</td><td>${r.side}</td><td>${r.line ?? '-'}</td><td>${(r.proj!=null)? r.proj.toFixed? r.proj.toFixed(1): r.proj : '-'}</td><td>${(r.edge!=null)? r.edge.toFixed(2): '-'}</td><td><span class="badge ${r.conf}">${r.conf}</span></td></tr>`).join('')+
        '</tbody></table></div>') : '<div class="muted">No prop recommendations available.</div>';
      }catch(e){ console.warn('prop snapshot error', e); }
    }
    document.getElementById('prop-market').addEventListener('change', loadPropSnapshot);
    document.getElementById('prop-hide-low').addEventListener('change', loadPropSnapshot);
    // Poll every 30s
    setInterval(loadPropSnapshot, 30000);

    // =============== Yesterday Pitcher Prop Recap ===============
    async function loadYesterdayPropRecap(){
      try{
        const date = yesterdayISO();
        const res = await fetch(`/api/pitcher-props/recap?date=${date}`);
        const data = await res.json();
        const cont = document.getElementById('props-yesterday');
        const kpis = document.getElementById('props-yesterday-kpis');
        if(!data.success || !(data.results||[]).length){
          cont.innerHTML = '<div class="muted">No pitcher prop recap available.</div>';
          kpis.innerHTML = '';
          return;
        }
        const rows = data.results;
        // KPIs overall
        const total = rows.length;
        const hits = rows.filter(r=>r.result==='HIT').length;
        const misses = rows.filter(r=>r.result==='MISS').length;
        const pushes = rows.filter(r=>r.result==='PUSH').length;
        kpis.innerHTML = [
          {label:'Total Props', val: total},
          {label:'Hits', val: hits},
          {label:'Misses', val: misses},
          {label:'Pushes', val: pushes}
        ].map(t=>`<div class='stat'><div class='num'>${t.val}</div><div class='muted'>${t.label}</div></div>`).join('');
        cont.innerHTML = '<div class="table-wrap"><table class="table"><thead><tr><th>Pitcher</th><th>Team</th><th>Market</th><th>Pick</th><th>Line</th><th>Actual</th><th>Result</th><th>Edge</th></tr></thead><tbody>'+
          rows.map(r=>`<tr><td>${r.pitcher}</td><td>${r.team} vs ${r.opponent}</td><td>${r.market}</td><td>${r.side}</td><td>${r.line ?? '-'}</td><td>${r.actual ?? '-'}</td><td>${r.result ?? ''}</td><td>${(r.edge!=null)? r.edge.toFixed? r.edge.toFixed(2): r.edge : '-'}</td></tr>`).join('')+
        '</tbody></table></div>';
      }catch(e){ console.warn('yesterday prop recap error', e); }
    }

    // =============== Per-Day Prop Reconciliation ===============
    async function populatePropsDaySelector(){
      try{
        const res = await fetch('/api/historical-analysis/available-dates');
        const data = await res.json();
        const dates = (data.dates || data.available_dates || []);
        const sel = document.getElementById('props-day'); sel.innerHTML='';
        dates.forEach(d=>{ const o=document.createElement('option'); o.value=d; o.textContent=d; sel.appendChild(o); });
        if(dates.length){ sel.value = dates[dates.length-1]; }
      }catch(e){ /* ignore */ }
    }
    async function loadPropsForDay(){
      const day = document.getElementById('props-day').value; if(!day) return;
      try{
        const res = await fetch(`/api/pitcher-props/recap?date=${day}`);
        const data = await res.json();
        const cont = document.getElementById('props-day');
        const kpis = document.getElementById('props-day-kpis');
        if(!data.success || !(data.results||[]).length){
          cont.innerHTML = '<div class="muted">No prop recap for selected day.</div>';
          kpis.innerHTML = '';
          return;
        }
        const rows = data.results;
        // KPIs by stat
        const byMarket = rows.reduce((acc,r)=>{ const m=r.market||'other'; acc[m]=acc[m]||{total:0,h:0,m:0,p:0}; acc[m].total++; if(r.result==='HIT')acc[m].h++; else if(r.result==='MISS')acc[m].m++; else if(r.result==='PUSH')acc[m].p++; return acc; }, {});
        kpis.innerHTML = Object.entries(byMarket).map(([m,v])=>{
          const acc = v.total? (v.h/v.total*100):0;
          return `<div class='stat'><div class='num'>${acc.toFixed(1)}%</div><div class='muted'>${m.toUpperCase()} Accuracy</div><div class='muted'>H:${v.h} M:${v.m} P:${v.p} â€¢ ${v.total} bets</div></div>`;
        }).join('');
        cont.innerHTML = '<div class="table-wrap"><table class="table"><thead><tr><th>Pitcher</th><th>Team</th><th>Market</th><th>Pick</th><th>Line</th><th>Actual</th><th>Result</th><th>Edge</th></tr></thead><tbody>'+
          rows.map(r=>`<tr><td>${r.pitcher}</td><td>${r.team} vs ${r.opponent}</td><td>${r.market}</td><td>${r.side}</td><td>${r.line ?? '-'}</td><td>${r.actual ?? '-'}</td><td>${r.result ?? ''}</td><td>${(r.edge!=null)? r.edge.toFixed? r.edge.toFixed(2): r.edge : '-'}</td></tr>`).join('')+
        '</tbody></table></div>';
      }catch(e){ console.warn('props day load error', e); }
    }

    // Kick off prop sections
    loadPropSnapshot();
    loadYesterdayPropRecap();
    populatePropsDaySelector().then(loadPropsForDay);
  </script>
</body>
</html>
