<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>MLB-Betting Prediction System</title>
    <!-- Removed meta theme-color (partial support). Consider platform-specific tags if needed. -->
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <link rel="stylesheet" href="/static/css/utilities.css" />
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; background: #0b1e2a; color: #e5e7eb; }
    .container { max-width: 1100px; margin: 0 auto; padding: 20px; }
    .header { text-align: center; margin-bottom: 30px; }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        /* Removed summary stat cards per request */

        .clickable-stat:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.15);
            border-color: #4fd1c7;
            box-shadow: 0 10px 25px rgba(79, 209, 199, 0.3);
        }

        .clickable-stat:hover h3 {
            color: #5ce1e6;
            text-shadow: 0 0 10px rgba(92, 225, 230, 0.5);
        }

    .stat-card p { opacity: 0.8; }

    .games-section { margin-top: 30px; }

        .games-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .date-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

    .date-selector input { padding: 8px 12px; border: none; border-radius: 8px; background: rgba(255, 255, 255, 0.9); color: #333; }

        .admin-link { display: inline-block; padding: 8px 16px; background: rgba(255, 215, 0, 0.2); color: #FFD700; text-decoration: none; border-radius: 8px; border: 1px solid #FFD700; font-size: 0.9rem; font-weight: bold; transition: all 0.3s ease; }
        .admin-link:hover { background: rgba(255, 215, 0, 0.3); transform: translateY(-2px); }

    .btn-small { padding: 4px 8px; border: none; border-radius: 4px; background: #4fd1c7; color: white; cursor: pointer; font-size: 0.8rem; font-weight: bold; transition: background 0.3s; }

        .btn-small:hover {
            background: #45b7b8;
        }

        /* Pitcher props UI/styles moved to /pitcher-props */
    @media (max-width: 480px) { .betting-lines h4 { font-size: 0.85rem; } }

        /* Game cards and grid layout (restored) */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 16px;
        }
        @media (max-width: 900px) { .games-grid { grid-template-columns: 1fr; } }

        .game-card {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 6px 14px rgba(0,0,0,0.25);
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            cursor: pointer;
        }
        .game-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.35);
            border-color: rgba(79, 209, 199, 0.35);
        }

        .game-header {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.06);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }
        .game-teams .team-info {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .header-center { text-align: center; }
        .team-logo {
            width: 28px; height: 28px; object-fit: contain;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.35));
        }
        .team-name { font-weight: 700; letter-spacing: 0.2px; }

        .card-body { padding: 12px; display: grid; gap: 12px; }
        .card-section {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 10px;
        }
        .card-section.transparent { background: transparent; border: none; padding: 0; }

        .starting-pitchers .pitcher-matchup {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            gap: 8px;
        }
    .pitcher-label { font-size: 0.75rem; opacity: 0.85; margin-right: 4px; }
    .pitcher-name { font-weight: 600; }
        .vs-separator { font-weight: 700; color: #9ca3af; background: rgba(255,255,255,0.08); border-radius: 999px; padding: 2px 8px; }

        .prediction-summary { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }

        /* Live at-bat compact widget */
        .live-header { display: grid; gap: 4px; justify-items: center; }
        .batter-line { font-weight: 600; }
        .last-play-line { font-size: 0.8rem; opacity: 0.9; }
        .live-atbat { display: inline-flex; align-items: center; gap: 8px; margin-top: 2px; }
        .half-inning { font-weight: 700; color: #ffd54f; }
        .bases-diamond { display: inline-grid; grid-template-columns: repeat(3, 8px); gap: 2px; margin: 0 6px; }
        .base-dot { width: 8px; height: 8px; border: 1px solid rgba(255,255,255,0.45); border-radius: 2px; transform: rotate(45deg); opacity: 0.5; background: transparent; }
        .base-dot.on { background: #ffd54f; border-color: #ffd54f; opacity: 1; }
        .outs { display: inline-flex; gap: 2px; }
        .out-dot { width: 8px; height: 8px; border-radius: 50%; background: rgba(255,255,255,0.25); }
        .out-dot.on { background: #ef4444; }
        .count-chip { background: rgba(255,255,255,0.12); padding: 2px 6px; border-radius: 12px; font-size: 0.7rem; }

        .betting-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }
        @media (max-width: 480px) { .betting-grid { grid-template-columns: 1fr 1fr; } }
        @media (max-width: 360px) { .betting-grid { grid-template-columns: 1fr; } }

        .betting-item {
            text-align: center;
            padding: 10px 8px;
            background: rgba(79, 209, 199, 0.08);
            border-radius: 8px;
            border: 1px solid rgba(79, 209, 199, 0.2);
            transition: all 0.2s ease;
        }

        .betting-item:hover {
            background: rgba(79, 209, 199, 0.12);
            border-color: rgba(79, 209, 199, 0.3);
        }

        .betting-item .line-label {
            font-size: 0.72rem;
            opacity: 0.9;
            margin-bottom: 4px;
            color: #4fd1c7;
            font-weight: 600;
        }

        .betting-item .line-value {
            font-size: 0.8rem;
            font-weight: bold;
            line-height: 1.3;
        }

        .moneyline-away, .moneyline-home {
            font-size: 0.75rem;
            margin: 1px 0;
            font-weight: 600;
        }

        .moneyline-away {
            color: #ff8a80;
        }

        .moneyline-home {
            color: #81c784;
        }

        .betting-recommendations {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid #4fd1c7;
        }
    @media (max-width: 480px) { .betting-recommendations { margin-top: 10px; padding: 12px; } }

        .betting-recommendations h4 {
            margin: 0 0 12px 0;
            color: #4fd1c7;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .value-bet {
            margin: 8px 0;
            padding: 12px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.08);
            border-left: 3px solid transparent;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .value-bet:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-1px);
        }

        .value-bet.high-confidence {
            border-left-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.15);
        }

        .value-bet.medium-confidence {
            border-left-color: #ffa726;
            background: rgba(255, 167, 38, 0.15);
        }

        .value-bet.low-confidence {
            border-left-color: #66bb6a;
            background: rgba(102, 187, 106, 0.15);
        }

        .best-bet {
            margin: 8px 0;
            padding: 12px;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .no-value {
            font-style: italic;
            opacity: 0.7;
            text-align: center;
            padding: 10px;
            color: #888;
        }

        .value-bet.low-confidence {
            border-left-color: #66bb6a;
            background: rgba(102, 187, 106, 0.15);
        }

        .value-bet.positive-ev {
            border-left-color: #4fd1c7;
            background: rgba(79, 209, 199, 0.2);
            box-shadow: 0 0 8px rgba(79, 209, 199, 0.3);
        }

        .positive-ev-badge {
            background: linear-gradient(45deg, #4fd1c7, #00d4aa);
            color: white;
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: bold;
            margin-left: 5px;
        }

        .no-value-bet {
            padding: 10px;
            text-align: center;
            color: #888;
            font-style: italic;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .edge-indicator {
            font-weight: bold;
            margin-left: 4px;
        }

        .game-status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
            margin-left: 8px;
        }

        .badge-scheduled {
            background: rgba(108, 117, 125, 0.2);
            color: #6c757d;
            border: 1px solid rgba(108, 117, 125, 0.3);
        }

        .badge-live {
            background: rgba(220, 53, 69, 0.2);
            color: #dc3545;
            border: 1px solid rgba(220, 53, 69, 0.4);
            animation: pulse 2s infinite;
        }

        .badge-final {
            background: rgba(40, 167, 69, 0.2);
            color: #28a745;
            border: 1px solid rgba(40, 167, 69, 0.4);
        }

        .badge-delayed {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.4);
        }

        .badge-unknown {
            background: rgba(255, 255, 255, 0.1);
            color: #adb5bd;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .game-time {
            font-size: 0.9rem;
            opacity: 0.85;
            margin-top: 4px;
        }

        .live-score {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            padding: 8px;
            background: rgba(220, 53, 69, 0.1);
            border-radius: 6px;
            border-left: 3px solid #dc3545;
        }

        .live-score .team-score {
            font-weight: bold;
            font-size: 1.1rem;
        }
    @media (max-width: 480px) { .live-score .team-score { font-size: 1rem; } }

        .final-analysis {
            margin-top: 10px;
            padding: 10px;
            background: rgba(40, 167, 69, 0.1);
            border-radius: 8px;
            border-left: 3px solid #28a745;
        }
    @media (max-width: 480px) { .final-analysis { padding: 8px; } }

        .final-analysis h5 {
            color: #28a745;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
    @media (max-width: 480px) { .analysis-grid { grid-template-columns: 1fr; } }

        .analysis-item {
            margin: 4px 0;
            font-size: 0.8rem;
            padding: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .analysis-correct {
            color: #28a745;
        }

        .analysis-incorrect {
            color: #dc3545;
        }

        .betting-comparison {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .betting-comparison h6 {
            margin: 5px 0 8px 0;
            font-size: 0.9rem;
            color: #ffd700;
        }

        .betting-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .section-title {
            color: #4fd1c7;
            font-size: 1.2rem;
            margin: 20px 0 15px 0;
            padding: 10px 15px;
            background: rgba(79, 209, 199, 0.1);
            border-left: 4px solid #4fd1c7;
            border-radius: 5px;
        }

        .btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn.secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .prediction-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .prediction-item .value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #4fd1c7;
        }

        .prediction-item .label {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2rem;
        }

        .error {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid rgba(255, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: white;
            cursor: pointer;
        }

        .recommendations {
            margin-top: 20px;
        }

        .recommendation {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .recommendation.high-confidence {
            border-left: 4px solid #4fd1c7;
        }

        .recommendation.medium-confidence {
            border-left: 4px solid #f39c12;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .games-header {
                flex-direction: column;
                gap: 15px;
            }
        }

    
    </style>
    <link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="48" fill="white" stroke="black" stroke-width="4"/><path d="M20,30 C40,50 60,50 80,30" stroke="red" stroke-width="4" fill="none"/><path d="M20,70 C40,50 60,50 80,70" stroke="red" stroke-width="4" fill="none"/></svg>' />
</head>
<body>
    <!-- Pitcher props UI moved to dedicated page (/pitcher-props) -->
    <div class="container">
        <div class="header">
            <h1>‚öæ MLB-Betting</h1>
            <p>Advanced MLB Prediction System with Real-Time Betting Analysis</p>
            <p class="subtle-note mt-5">
                üìä Comprehensive Analysis Since August 7th ‚Ä¢ Updated Daily ‚Ä¢ {{ comprehensive_stats.total_games_analyzed or 0 }} Games Tracked
            </p>
            
            <!-- Admin Navigation -->
            <div class="mt-15 flex gap-10 flex-wrap">
                <a href="/admin" class="admin-link">
                    üéØ Tuning Dashboard
                </a>
                <button id="run-automation-btn" onclick="runDailyAutomation()" class="btn-ghost-cyan">
                    üöÄ Run Daily Update
                </button>
                <button id="refresh-stats-btn" onclick="refreshDashboardStats()" class="btn-ghost-gray">
                    üìä Refresh Stats
                </button>
                <button id="init-system-btn" onclick="initializeSystem()" class="btn-ghost-green">
                    ‚ö° Load Real MLB Data
                </button>
                <!-- Compact TBD Monitor button -->
                <button id="tbd-monitor-btn" onclick="checkTBD()" title="Check TBD pitchers" class="btn-tbd">
                    üïµÔ∏è TBD Monitor <span id="tbd-badge" class="badge-pill">0</span>
                </button>
            </div>
        </div>

        <!-- Summary stat cards removed per request -->

        <div class="games-section">
            <div class="games-header">
                <h2>Today's MLB Games</h2>
                <div class="date-selector">
                    <label for="game-date" class="hidden">Game date</label>
                    <input type="date" id="game-date" class="hidden" title="Game date" />
                    <button class="btn" onclick="loadToday()">Refresh</button>
                    <button class="btn secondary" onclick="refreshBettingLines()" id="refresh-betting-lines-btn">üí∞ Update Betting Lines</button>
                    <button class="btn secondary" onclick="goToHistoricalAnalysis()">üìä Historical Analysis</button>
                    <button class="btn secondary" onclick="goToBettingGuidance()">üéØ Betting Guidance</button>
                    <button class="btn secondary" onclick="goToPitcherProps()">üéØ Pitcher Props</button>
                </div>
            </div>

            <!-- Live Games Section -->
            <div id="live-games-section" class="hidden">
                <h3 class="section-title">üî¥ Live Games</h3>
                <div id="live-games-container" class="games-grid"></div>
            </div>

            <!-- Upcoming Games Section -->
            <div id="upcoming-games-section" class="hidden">
                <h3 class="section-title">‚è∞ Upcoming Games</h3>
                <div id="upcoming-games-container" class="games-grid"></div>
            </div>

            <div id="games-container">
                <div class="loading">Loading today's games...</div>
            </div>

            <!-- Completed Games Section - Moved to bottom -->
            <div id="completed-games-section" class="hidden mt-30">
                <h3 class="section-title">‚úÖ Completed Games</h3>
                <div id="completed-games-container" class="games-grid"></div>
            </div>
        </div>
    </div>

    <!-- Pitcher Props moved to dedicated page (/pitcher-props) -->

    <!-- Prediction Modal -->
    <div id="prediction-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">Game Prediction</h2>
                <button class="close-btn" onclick="closeModal()">&times;</button>
            </div>
            <div id="modal-body">
                Loading prediction...
            </div>
        </div>
    </div>

    <script>
        // --- Lightweight Performance Instrumentation (dev-friendly) ---
        (function initPerf(){
            try {
                if (window.__PERF) return; // idempotent
                window.__PERF = {
                    t0: performance.now(),
                    marks: {},
                    data: {}
                };
                window.__PERF.mark = function(name){ this.marks[name] = performance.now(); };
                document.addEventListener('DOMContentLoaded', ()=>{ try { window.__PERF.mark('domContentLoaded'); } catch(_){} });

                // Optional tiny badge for quick visual check; hidden by default
                const badge = document.createElement('div');
                badge.id = 'perfBadge';
                badge.style.cssText = 'display:none;position:fixed;top:10px;right:10px;background:rgba(0,0,0,0.7);color:#fff;padding:6px 8px;border-radius:6px;font:12px system-ui;z-index:9999;box-shadow:0 2px 8px rgba(0,0,0,0.2);';
                badge.title = 'Performance summary (press Ctrl+Alt+P to toggle)';
                badge.textContent = 'Loading‚Ä¶';
                document.addEventListener('keydown', (e)=>{
                    try {
                        if ((e.ctrlKey || e.metaKey) && e.altKey && (e.key.toLowerCase() === 'p')){
                            const vis = badge.style.display !== 'none';
                            badge.style.display = vis ? 'none' : 'block';
                        }
                    } catch(_){ }
                });
                document.body.appendChild(badge);

                window.__PERF.updateBadge = function(summary){
                    try {
                        const el = document.getElementById('perfBadge');
                        if (!el) return;
                        const s = summary || this.data.summary;
                        if (!s) return;
                        el.textContent = `Load ${s.total.toFixed(1)}ms ‚Ä¢ fetch ${s.fetch.toFixed(1)} ‚Ä¢ render ${s.render.toFixed(1)}${s.props ? ` ‚Ä¢ props ${s.props.toFixed(1)}`:''}`;
                    } catch(_){ }
                };
            } catch(_){ }
        })();
        // Small fetch helper with timeout and cache-busting
        async function fetchWithTimeout(url, options = {}, timeoutMs = 10000) {
            const controller = new AbortController();
            const id = setTimeout(() => {
                try { controller.abort('timeout'); } catch(_) { controller.abort(); }
            }, timeoutMs);
            try {
                const bust = url.includes('?') ? `&_=${Date.now()}` : `?_=${Date.now()}`;
                const res = await fetch(url + bust, { ...options, signal: controller.signal });
                return res;
            } finally {
                clearTimeout(id);
            }
        }
        // Modal helpers: open/close with backdrop and Escape support
        function openModal() {
            const modal = document.getElementById('prediction-modal');
            if (!modal) return;
            modal.style.display = 'block';
            try { document.body.style.overflow = 'hidden'; } catch(_){}
        }
        function closeModal() {
            const modal = document.getElementById('prediction-modal');
            if (!modal) return;
            modal.style.display = 'none';
            try { document.body.style.overflow = ''; } catch(_){}
        }
        // Attach one-time listeners for backdrop click and Escape key
        (function attachModalHandlers(){
            if (window.__MODAL_HANDLERS_ATTACHED__) return;
            window.__MODAL_HANDLERS_ATTACHED__ = true;
            document.addEventListener('DOMContentLoaded', function(){
                const modal = document.getElementById('prediction-modal');
                if (!modal) return;
                // Close when clicking backdrop (but not when clicking content)
                modal.addEventListener('click', function(e){ if (e.target === modal) closeModal(); });
                // Close on Escape
                document.addEventListener('keydown', function(e){ if (e.key === 'Escape') closeModal(); });
            });
        })();
    // Cache of last-known live stats keyed by game compositeId and side (away/home)
    window.__LAST_LIVE_STATS = window.__LAST_LIVE_STATS || {};

        // Shared name normalizer: lowercases, strips diacritics, removes non-alphanumerics
        function normName(s) {
            return String(s || '')
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, ' ')
                .trim();
        }
        // Parse "HH:MM AM/PM ET" to a CT display string. If parsing fails, return original string.
        function etToCtDisplay(timeStr) {
            try {
                if (!timeStr) return '';
                const m = String(timeStr).trim().match(/^(\d{1,2}):(\d{2})\s*(AM|PM)\s*(ET)?$/i);
                if (!m) return String(timeStr).trim();
                let h = parseInt(m[1], 10);
                const min = parseInt(m[2], 10);
                const ampm = m[3].toUpperCase();
                if (ampm === 'PM' && h !== 12) h += 12;
                if (ampm === 'AM' && h === 12) h = 0;
                // ET -> CT is -1 hour (handles DST uniformly since both shift together)
                h = (h + 24 - 1) % 24;
                const h12 = ((h + 11) % 12) + 1;
                const ampmOut = h < 12 ? 'AM' : 'PM';
                return `${h12}:${String(min).padStart(2, '0')} ${ampmOut} CT`;
            } catch (_) {
                return String(timeStr).trim();
            }
        }
        // Convert ISO/Z timestamps to Central Time (CT) display regardless of user's local timezone
        function isoToCtDisplay(isoStr) {
            try {
                if (!isoStr || (typeof isoStr !== 'string')) return '';
                const d = new Date(isoStr);
                if (isNaN(d.getTime())) return String(isoStr).trim();
                return new Intl.DateTimeFormat('en-US', {
                    hour: 'numeric', minute: '2-digit', hour12: true,
                    timeZone: 'America/Chicago'
                }).format(d).replace(' AM', ' AM CT').replace(' PM', ' PM CT');
            } catch (_) {
                return String(isoStr).trim();
            }
        }
        // Extract minutes since midnight for a "HH:MM AM/PM" string, assuming ET; returns null if unparseable
        function meridianToMinutesET(timeStr) {
            try {
                const m = String(timeStr || '').match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
                if (!m) return null;
                let h = parseInt(m[1], 10);
                const min = parseInt(m[2], 10);
                const ampm = m[3].toUpperCase();
                if (ampm === 'PM' && h !== 12) h += 12;
                if (ampm === 'AM' && h === 12) h = 0;
                return h * 60 + min; // ET minutes
            } catch (_) { return null; }
        }
        // Build a numeric sort key for a game time, preferring ISO timestamps; fallback to ET minutes for meridian strings
        function gameSortKey(game) {
            try {
                const gt = game?.game_time || '';
                if (gt && (gt.includes('T') || gt.includes('Z'))) {
                    const ts = Date.parse(gt);
                    if (!Number.isNaN(ts)) return ts;
                }
                const tStr = (game?.live_status?.game_time) || gt || '';
                const minsET = meridianToMinutesET(tStr);
                if (minsET != null) return minsET * 60000; // scale to ms for consistency
            } catch (_) {}
            return Number.MAX_SAFE_INTEGER; // push unknowns to end
        }
        // Get user's local date, not UTC date
        let currentDate = new Date();
        let localDateString = currentDate.getFullYear() + '-' + 
                              String(currentDate.getMonth() + 1).padStart(2, '0') + '-' + 
                              String(currentDate.getDate()).padStart(2, '0');
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            try { if ('serviceWorker' in navigator) { navigator.serviceWorker.register('/sw.js').catch(()=>{}); } } catch(_){}
            document.getElementById('game-date').value = localDateString;
            loadSummary();
            // Quick-first: paint ultra-fast snapshot, then hydrate full data
            loadTodaysGames({ quickFirst: true });
            
            // Start live updates for games in progress
            startLiveUpdates();
            
            // Initialize TBD monitoring
            updateTBDStatus();
            
            // Initialize live dashboard stats
            loadLiveDashboardStats();
            
            // Update TBD status every 5 minutes
            setInterval(updateTBDStatus, 300000);
            
            // Update dashboard stats every 2 minutes
            setInterval(loadLiveDashboardStats, 120000);
        });

        // On back/forward cache restore, skip heavy reloads and just tick live once
        window.addEventListener('pageshow', function(e){
            try {
                if (e && e.persisted) {
                    console.info('[NAV] bfcache restore detected ‚Äî skipping heavy re-fetch');
                    // Ensure live updates interval is running, and do a single lightweight update
                    try { startLiveUpdates(); } catch(_){}
                    try { setTimeout(updateLiveGames, 500); } catch(_){}
                }
            } catch(_){}
        });

        // üî• LIVE DASHBOARD STATS WIDGET
        async function loadLiveDashboardStats() {
            try {
                console.log('üîÑ Loading live dashboard stats from historical analysis API...');
                
                const response = await fetch('/api/historical-analysis/cumulative');
                if (!response.ok) {
                    console.warn('‚ùå Historical analysis API not available, keeping server-side stats');
                    return;
                }
                
                const apiData = await response.json();
                if (!apiData.success || !apiData.data) {
                    console.warn('‚ùå Historical analysis API returned error:', apiData.message);
                    return;
                }
                
                const data = apiData.data;
                const betting = data.betting_performance || {};
                const analysis = data.analysis_period || '2025-08-15 to 2025-08-25';
                
                console.log('‚úÖ Live dashboard data loaded:', {
                    totalRecommendations: betting.total_recommendations,
                    accuracy: betting.overall_accuracy,
                    roi: betting.roi_percentage
                });
                
                // Update the dashboard stats with live data
                updateDashboardStat(0, {
                    value: betting.total_recommendations || 0,
                    subtitle: `Since ${analysis.split(' to ')[0]} (${data.total_dates_analyzed || 0} days)`
                });
                
                updateDashboardStat(1, {
                    value: `${(betting.overall_accuracy || 0).toFixed(2)}%`,
                    subtitle: `${betting.correct_recommendations || 0}/${betting.total_recommendations || 0} correct predictions`
                });
                
                updateDashboardStat(2, {
                    value: `$${(betting.net_profit || 0).toFixed(2)}`,
                    subtitle: `${(betting.roi_percentage || 0).toFixed(2)}% ROI on ${betting.total_recommendations || 0} bets`
                });
                
                updateDashboardStat(3, {
                    value: `${(betting.overall_accuracy || 0).toFixed(2)}%`,
                    subtitle: `${betting.correct_recommendations || 0} winning bets of ${betting.total_recommendations || 0} placed`
                });
                
                // Add visual indicator that data is live
                const header = document.querySelector('.header p');
                if (header && !header.textContent.includes('üî¥ LIVE')) {
                    header.innerHTML = header.innerHTML.replace('üìä Comprehensive Analysis', 'üî¥ LIVE Analysis');
                }
                
                console.log('‚úÖ Dashboard stats updated with live data');
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Could not load live dashboard stats:', error);
                // Keep server-side stats if API fails
            }
        }
        
        function updateDashboardStat(index, data) {
            const statCards = document.querySelectorAll('#summary-stats .stat-card h3');
            const subtitleCards = document.querySelectorAll('#summary-stats .stat-card small');
            
            if (statCards[index]) {
                statCards[index].textContent = data.value;
                // Add a subtle animation to show the update
                statCards[index].style.transition = 'all 0.3s ease';
                statCards[index].style.transform = 'scale(1.05)';
                statCards[index].style.color = '#4fd1c7';
                setTimeout(() => {
                    statCards[index].style.transform = 'scale(1)';
                    statCards[index].style.color = '';
                }, 300);
            }
            
            if (subtitleCards[index] && data.subtitle) {
                subtitleCards[index].textContent = data.subtitle;
            }
        }

        function goToHistoricalAnalysis() {
            // Navigate to model performance/accuracy page
            window.location.href = '/historical-performance';
        }

        function goToBettingGuidance() {
            // Navigate to Kelly-based betting guidance page
            window.location.href = '/betting-guidance';
        }

        function goToPitcherProps() {
            window.location.href = '/pitcher-props';
        }

        function loadToday() {
            currentDate = new Date();
            localDateString = currentDate.getFullYear() + '-' + 
                              String(currentDate.getMonth() + 1).padStart(2, '0') + '-' + 
                              String(currentDate.getDate()).padStart(2, '0');
            document.getElementById('game-date').value = localDateString;
            loadTodaysGames();
        }

        // Betting Lines Refresh Function
        async function refreshBettingLines() {
            const btn = document.getElementById('refresh-betting-lines-btn');
            const originalText = btn.textContent;
            
            btn.textContent = '‚è≥ Updating...';
            btn.disabled = true;
            
            try {
                // Show loading notification
                showNotification('Fetching fresh betting lines from OddsAPI...', 'info', 0);
                
                const response = await fetch('/api/refresh-betting-lines', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const linesCount = data.data.fresh_lines_count;
                    const recsGenerated = data.data.recommendations_generated;
                    const recsCount = data.data.recommendations_count;
                    
                    let message = `‚úÖ Successfully updated ${linesCount} betting lines`;
                    if (recsGenerated) {
                        message += ` and regenerated recommendations for ${recsCount} games`;
                    }
                    
                    showNotification(message, 'success', 5000);
                    
                    // Refresh the games display to show updated lines
                    setTimeout(() => {
                        loadTodaysGames();
                    }, 1000);
                    
                } else {
                    showNotification(`‚ùå Failed to update betting lines: ${data.error}`, 'error', 8000);
                }
                
            } catch (error) {
                console.error('Error refreshing betting lines:', error);
                showNotification('‚ùå Network error while updating betting lines', 'error', 8000);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        // Notification function for user feedback
        function showNotification(message, type = 'info', duration = 5000) {
            // Remove existing notifications
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(notif => notif.remove());
            
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = message;
            
            // Styling
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                border-radius: 8px;
                font-weight: bold;
                max-width: 400px;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                transition: all 0.3s ease;
                transform: translateX(100%);
            `;
            
            // Type-specific styling
            if (type === 'success') {
                notification.style.background = 'rgba(16, 185, 129, 0.9)';
                notification.style.color = 'white';
                notification.style.border = '1px solid #10b981';
            } else if (type === 'error') {
                notification.style.background = 'rgba(239, 68, 68, 0.9)';
                notification.style.color = 'white';
                notification.style.border = '1px solid #ef4444';
            } else {
                notification.style.background = 'rgba(59, 130, 246, 0.9)';
                notification.style.color = 'white';
                notification.style.border = '1px solid #3b82f6';
            }
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            // Auto-remove if duration is set
            if (duration > 0) {
                setTimeout(() => {
                    notification.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }, duration);
            }
        }

        // TBD Monitoring Functions (compact badge)
        async function updateTBDStatus() {
            try {
                const response = await fetch('/api/tbd-status');
                const data = await response.json();
                if (data && data.success) {
                    const status = data.status || {};
                    const badge = document.getElementById('tbd-badge');
                    if (badge) {
                        const count = Number(status.tbd_games_count || 0);
                        badge.textContent = isNaN(count) ? '0' : String(count);
                        badge.style.background = count > 0 ? 'rgba(239,68,68,0.85)' : 'rgba(31,41,55,0.6)';
                    }
                }
            } catch (error) {
                console.error('Error updating TBD status:', error);
                const badge = document.getElementById('tbd-badge');
                if (badge) { badge.textContent = '!'; badge.style.background = 'rgba(239,68,68,0.85)'; }
            }
        }

        async function checkTBD() {
            const btn = document.getElementById('tbd-monitor-btn');
            const originalText = btn ? btn.textContent : '';
            if (btn) { btn.textContent = 'Checking...'; btn.disabled = true; }
            try {
                const response = await fetch('/api/tbd-check', { method: 'POST', headers: { 'Content-Type': 'application/json' } });
                const data = await response.json();
                if (data && data.success) {
                    if (data.updated) {
                        loadToday();
                        updateTBDStatus();
                        showNotification('Pitcher updates found! Recommendations refreshed.', 'success', 4000);
                    } else {
                        showNotification('No pitcher updates found.', 'info', 3000);
                    }
                } else {
                    showNotification('Error checking for updates.', 'error', 4000);
                }
            } catch (error) {
                console.error('Error checking TBD:', error);
                showNotification('Network error checking for pitcher updates.', 'error', 4000);
            } finally {
                if (btn) { btn.textContent = originalText; btn.disabled = false; }
            }
        }

        // Daily Automation Function
        async function runDailyAutomation() {
            const btn = document.getElementById('run-automation-btn');
            const originalText = btn.textContent;
            
            try {
                btn.textContent = 'üîÑ Starting...';
                btn.disabled = true;
                
                const response = await fetch('/api/run-daily-automation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    btn.textContent = '‚úÖ Running...';
                    alert('Daily automation started! This will update all data including betting recommendations for today. Check the console logs for progress. The page will refresh in 30 seconds.');
                    
                    // Refresh the page after 30 seconds to show updated data
                    setTimeout(() => {
                        window.location.reload();
                    }, 30000);
                } else {
                    btn.textContent = originalText;
                    btn.disabled = false;
                    alert('Error starting automation: ' + data.error);
                }
            } catch (error) {
                console.error('Error starting automation:', error);
                btn.textContent = originalText;
                btn.disabled = false;
                alert('Error starting daily automation.');
            }
        }

        // Refresh Dashboard Stats Function
        async function refreshDashboardStats() {
            const btn = document.getElementById('refresh-stats-btn');
            const originalText = btn.textContent;
            
            try {
                btn.textContent = 'üîÑ Updating...';
                btn.disabled = true;
                
                const response = await fetch('/api/update-dashboard-stats');
                const data = await response.json();
                
                if (data.status === 'success') {
                    btn.textContent = '‚úÖ Updated!';
                    
                    // Update the stats display on the page
                    const totalGamesElement = document.querySelector('.stat-card h3');
                    const subtitleCards = document.querySelectorAll('#summary-stats .stat-card small');
                    if (totalGamesElement && data.stats) {
                        totalGamesElement.textContent = data.stats.total_games_analyzed || 0;
                        
                        // Update subtitles with new data
                        subtitleCards[0].textContent = `Since ${data.stats.analysis_start_date} (${data.stats.days_of_data || 0} days)`;
                        subtitleCards[1].textContent = `${data.stats.winner_predictions_correct || 0}/${data.stats.total_games_analyzed || 0} correct predictions`;
                        subtitleCards[2].textContent = `${data.stats.roi_percentage || 0}% ROI on ${data.stats.total_bets_placed || 0} bets`;
                        subtitleCards[3].textContent = `${data.stats.total_predictions_correct || 0} winning bets of ${data.stats.total_bets_placed || 0} placed`;
                    }
                    
                    // Refresh the page to show all updated stats
                    setTimeout(() => {
                        window.location.reload();
                    }, 1500);
                } else {
                    btn.textContent = '‚ùå Error';
                    alert('Error updating stats: ' + data.message);
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.disabled = false;
                    }, 2000);
                }
            } catch (error) {
                console.error('Error refreshing stats:', error);
                btn.textContent = '‚ùå Error';
                alert('Error refreshing dashboard statistics.');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 2000);
            }
        }

        async function initializeSystem() {
            const btn = document.getElementById('init-system-btn');
            const originalText = btn.textContent;
            
            try {
                btn.textContent = 'üîÑ Fetching Real MLB Data...';
                btn.disabled = true;
                
                showNotification('üöÄ Fetching real MLB games from API...', 'info', 5000);
                
                const response = await fetch('/api/initialize-system', {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.success) {
                    btn.textContent = '‚úÖ Success!';
                    showNotification(`‚úÖ Successfully loaded ${data.games_loaded} real MLB games!`, 'success', 5000);
                    
                    // Show the games that were loaded
                    if (data.real_games && data.real_games.length > 0) {
                        const gamesList = data.real_games.join(', ');
                        console.log('Real games loaded:', gamesList);
                    }
                    
                    // Refresh the page to show the real data
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                } else {
                    btn.textContent = '‚ùå Failed';
                    showNotification(`‚ùå Failed to load real data: ${data.error}`, 'error', 8000);
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.disabled = false;
                    }, 3000);
                }
            } catch (error) {
                console.error('Error initializing system:', error);
                btn.textContent = '‚ùå Failed';
                showNotification('‚ùå Error fetching real MLB data. Check console for details.', 'error', 8000);
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 3000);
            }
        }

        function startLiveUpdates() {
            // Avoid starting multiple intervals
            if (window.__LIVE_UPDATES_STARTED__) return;
            window.__LIVE_UPDATES_STARTED__ = true;
            // Check for live games more frequently (every 10 seconds)
            setInterval(updateLiveGames, 10000);
        }

    async function updateLiveGames() {
            try {
        // Don't hit API until cards are rendered to avoid noisy logs
        if (!document.querySelector('.game-card')) return;
                const date = document.getElementById('game-date').value;
                const response = await fetch(`/api/live-status?date=${date}`);
                const data = await response.json();
                
                if (data.success) {
                    const liveGames = data.games.filter(game => game.is_live || game.is_final);
                    
                    for (const liveGame of liveGames) {
                        updateGameCard(liveGame);
                    }
                    
                    // Update timestamp
                    console.log(`Live update: ${new Date().toLocaleTimeString()} - ${liveGames.length} games updated`);
                }
            } catch (error) {
                console.error('Error updating live games:', error);
            }
        }

        // Helper: Build "Batter vs Pitcher" string using inning half
        function buildBatterVsPitcher(batter, inningState, awayPitcher, homePitcher, isTopInning) {
            let half = (inningState || '').toLowerCase();
            if (!half && typeof isTopInning === 'boolean') {
                half = isTopInning ? 'top' : 'bottom';
            }
            let pitcher = '';
            if (half.startsWith('top')) {
                pitcher = homePitcher || '';
            } else if (half.startsWith('bottom')) {
                pitcher = awayPitcher || '';
            }
            // Only show when both are known; otherwise, show nothing
            if (batter && pitcher) return `${batter} vs ${pitcher}`;
            return '';
        }

        // Helper: ordinal
        function ordinal(n){
            n = parseInt(n, 10);
            if (!n && n !== 0) return '';
            const s=["th","st","nd","rd"], v=n%100;
            return n + (s[(v-20)%10]||s[v]||s[0]);
        }

        // Build graphical live at-bat widget (bases/outs/inning)
        function buildLiveAtBatWidget(lg){
            if(!lg || !lg.is_live) return '';
            const half = (typeof lg.is_top_inning === 'boolean')
                ? (lg.is_top_inning ? 'Top' : 'Bottom')
                : ((lg.inning_state || '').toLowerCase().startsWith('top') ? 'Top' : (lg.inning_state || '').toLowerCase().startsWith('bottom') ? 'Bottom' : '');
            const arrow = half === 'Top' ? '‚Üë' : (half === 'Bottom' ? '‚Üì' : '');
            const inn = lg.inning ? ordinal(lg.inning) : '';
            const outs = Math.max(0, Math.min(2, parseInt(lg.outs != null ? lg.outs : 0, 10)));
            const outDots = [0,1,2].map(i => `<span class="out-dot${i < outs ? ' on' : ''}"></span>`).join('');
            const b1 = lg.on_first ? ' on' : '';
            const b2 = lg.on_second ? ' on' : '';
            const b3 = lg.on_third ? ' on' : '';
            const countChip = (lg.balls != null && lg.strikes != null) ? `<span class="count-chip">${lg.balls} balls, ${lg.strikes} strikes</span>` : '';
            return `
                <div class="live-atbat">
                    <div class="half-inning">${arrow} ${half} ${inn}</div>
                    <div class="bases-diamond" title="Bases">
                        <span class="base-dot b2${b2}"></span>
                        <span class="base-dot b3${b3}"></span>
                        <span class="base-dot b1${b1}"></span>
                    </div>
                    <div class="outs" title="Outs">${outDots}</div>
                    ${countChip}
                </div>
            `;
        }

        function updateGameCard(liveGame) {
            // Find the corresponding game card by composite ID using the selected date
            const dateStr = document.getElementById('game-date')?.value || '';
            const compositeId = `${liveGame.away_team}_${liveGame.home_team}_${dateStr}${liveGame.game_pk ? '_' + liveGame.game_pk : ''}`;
            
            // Debug logging
            console.log(`üîç Looking for live game: ${liveGame.away_team} @ ${liveGame.home_team}`);
            console.log(`   Status: ${liveGame.status}, Live: ${liveGame.is_live}, Scores: ${liveGame.away_score}-${liveGame.home_score}`);
            
            // Primary: prefer lookup by game_pk for DH disambiguation
            let card = null;
            if (liveGame.game_pk) {
                card = document.querySelector(`.game-card[data-game-pk="${String(liveGame.game_pk)}"]`);
            }
            if (!card) {
                card = document.querySelector(`[data-game-id="${compositeId}"]`);
            }
            
            // Fallback: match by explicit team attributes
            if (!card) {
                const awayKey = (liveGame.away_team || '').toLowerCase();
                const homeKey = (liveGame.home_team || '').toLowerCase();
                card = document.querySelector(`.game-card[data-away-team="${awayKey}"][data-home-team="${homeKey}"]`);
            }
            
            // Fallback: normalized names in composite if formatting differs
            if (!card) {
                const normalizedAway = liveGame.away_team.replace('Oakland ', '').replace(' Athletics', '');
                const normalizedHome = liveGame.home_team.replace('Oakland ', '').replace(' Athletics', '');
                card = document.querySelector(`[data-game-id*="${normalizedAway}"][data-game-id*="${normalizedHome}"]`);
                console.log(`   Trying normalized names: ${normalizedAway} @ ${normalizedHome}`);
            }
            
            if (card) {
                console.log(`‚úÖ Found game card, updating live status`);
                // Update header-center
                const headerCenter = card.querySelector('.header-center');
                if (headerCenter) {
                    if (liveGame.is_live) {
                        // Replace with dynamic batter vs pitcher + last play
                        const vsLine = buildBatterVsPitcher(
                            liveGame.current_batter,
                            liveGame.inning_state,
                            liveGame.away_pitcher,
                            liveGame.home_pitcher,
                            typeof liveGame.is_top_inning === 'boolean' ? liveGame.is_top_inning : undefined
                        );
            // Graphical widget: bases/outs/inning + count
            const atbatWidget = buildLiveAtBatWidget(liveGame);
                        headerCenter.innerHTML = `
                            <div class="live-header" data-dynamic="header-center">
                ${vsLine ? `<div class=\"batter-line\">${vsLine}</div>` : (liveGame.current_batter ? `<div class=\"batter-line\">${liveGame.current_batter}</div>` : '')}
                ${atbatWidget}
                                ${liveGame.last_play ? `<div class=\"last-play-line\">${liveGame.last_play}</div>` : ''}
                            </div>
                        `;
                    } else {
                        // Non-live: show time + pill
                        const timeHtml = (function(){
                            const gt = liveGame.game_time;
                            if (!gt) return '';
                            if (gt.includes('T') || gt.includes('Z')) {
                                const ct = isoToCtDisplay(gt);
                                return ct ? `<div class="game-time">${ct}</div>` : '';
                            }
                            return `<div class="game-time">${gt}</div>`;
                        })();
                        headerCenter.innerHTML = `${timeHtml}<span class="game-status-badge badge-${liveGame.badge_class}">${liveGame.status}</span>`;
                    }
                }
                // Pitch count metrics removed from main page

                // Prop trackers removed: skip per-market updates
                
                // Remove ALL existing live/final content to prevent duplicates
                card.querySelectorAll('.live-score').forEach(el => el.remove());
                card.querySelectorAll('.final-analysis').forEach(el => el.remove());
                
                const gameHeader = card.querySelector('.game-header');
                if (liveGame.is_live && (liveGame.away_score != null || liveGame.home_score != null)) {
                    const liveScoreHtml = createLiveScoreHtml(liveGame);
                    console.log(`   Adding live score HTML: ${liveScoreHtml}`);
                    gameHeader.insertAdjacentHTML('afterend', liveScoreHtml);
                } else if (liveGame.is_final && (liveGame.away_score != null || liveGame.home_score != null)) {
                    // Use stored full game object if available for prediction context
                    let fullGame = null;
                    try {
                        const idEl = card.querySelector('[id^="summary-"]');
                        if (idEl) {
                            const gameId = idEl.id.replace('summary-', '');
                            fullGame = (window.__GAME_BY_ID || {})[gameId] || null;
                        }
                    } catch(_){}
                    // Fallback minimal object to avoid undefineds
                    if(!fullGame){
                        fullGame = {
                            away_team: liveGame.away_team,
                            home_team: liveGame.home_team,
                            predicted_away_score: liveGame.predicted_away_score || 0,
                            predicted_home_score: liveGame.predicted_home_score || 0,
                            predicted_total_runs: liveGame.predicted_total_runs || 0
                        };
                    }
                    const finalScoreHtml = createFinalScoreHtml(liveGame, fullGame);
                    gameHeader.insertAdjacentHTML('afterend', finalScoreHtml);
                }
            } else {
                console.log(`‚ùå Game card not found for ${liveGame.away_team} @ ${liveGame.home_team}`);
            }
        }

    // applyCachedLiveToTrackers removed (no prop trackers on main page)

    async function loadSummary() {
            try {
                const response = await fetch('/api/summary');
                const data = await response.json();
                
                if (data.success) {
            const summary = data.summary || {};
            const setText = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = val; };
            setText('total-games', summary.total_games ?? '');
            setText('completed-games', summary.completed_games ?? '');
            setText('prediction-accuracy', (summary.prediction_accuracy != null ? (summary.prediction_accuracy * 100).toFixed(2) + '%' : ''));
            setText('avg-error', (summary.avg_score_error != null ? Number(summary.avg_score_error).toFixed(2) : ''));
                }
            } catch (error) {
                console.error('Error loading summary:', error);
            }
        }

    async function loadTodaysGames(opts = {}) {
        const options = Object.assign({ quickFirst: false }, opts || {});
            const date = document.getElementById('game-date').value;
            const container = document.getElementById('games-container');
            
            console.log('Loading todays games for date:', date);
            container.innerHTML = '<div class="loading">Loading today\'s games...</div>';
            // Coordinated UI timeouts so we don't prematurely swap the spinner on slow networks
            let fetchTimeoutMs = 15000; // start modest; we'll retry and fallback quickly
            const slowTimer = setTimeout(() => {
                const loading = container.querySelector('.loading');
                if (loading) loading.innerHTML = 'Loading today\'s games... (taking longer than usual)';
            }, 4000);
            const watchdog = setTimeout(() => {
                const loading = container.querySelector('.loading');
                if (loading) {
                    console.warn('Watchdog: load still in progress (slow network/server)');
                    loading.innerHTML = 'Loading today\'s games... (still working; slow network)';
                }
            }, Math.max(12000, fetchTimeoutMs - 5000));
            // Proactive quick-snapshot fallback if first paint takes too long
            let usedQuickFallback = false;
            let paintedQuick = false;
            // Start an immediate quick snapshot fetch in parallel for fastest first paint
            if (options.quickFirst) {
                try {
                    const quickUrl = `/api/today-games/quick?date=${encodeURIComponent(date||'')}`;
                    const quickPromise = fetchWithTimeout(quickUrl, {}, 3000);
                    quickPromise.then(async (q) => {
                        try {
                            if (paintedQuick) return;
                            if (!q || !q.ok) return;
                            const snap = await q.json();
                            if (snap && snap.success && Array.isArray(snap.games) && snap.games.length) {
                                usedQuickFallback = true;
                                paintedQuick = true;
                                hydrateFromTodayGames(snap, container);
                                clearTimeout(slowTimer); clearTimeout(watchdog);
                                try { window.__PERF.mark && window.__PERF.mark('quick_painted'); } catch(_){}
                                console.info('[QUICK] painted immediate snapshot');
                            }
                        } catch(_){}
                    }).catch(()=>{});
                } catch(_){}
            }
            const quickPaintTimer = setTimeout(async () => {
                try {
                    if (paintedQuick) return;
                    if (!options.quickFirst) return;
                    const hasCards = !!document.querySelector('.game-card');
                    if (hasCards) return;
                    console.info('[FALLBACK] timed quick snapshot to avoid long spinner');
                    const q = await fetchWithTimeout(`/api/today-games/quick?date=${encodeURIComponent(date||'')}` , {}, 6000);
                    if (q.ok) {
                        const snap = await q.json();
                        if (snap && snap.success && Array.isArray(snap.games) && snap.games.length) {
                            usedQuickFallback = true;
                            paintedQuick = true;
                            hydrateFromTodayGames(snap, container);
                            clearTimeout(slowTimer); clearTimeout(watchdog);
                        }
                    }
                } catch(_){ /* ignore */ }
            }, 300); // render quick snapshot ASAP on first load
            
            try {
                try { window.__PERF.mark('todayGames_fetch_start'); } catch(_){}
                const url = `/api/today-games?date=${encodeURIComponent(date || '')}`;
                let data;
                let attempt = 0;
                let lastErr = null;
                while (attempt < 3) {
                    try {
                        const endpoint = attempt >= 1 ? '/api/today-games' : url; // let server decide on retry
                        // Extend timeout for first loads and slow connections
                        try {
                            const et = navigator.connection?.effectiveType || '';
                            if (et && (et.includes('2g') || et === 'slow-2g')) {
                                fetchTimeoutMs = Math.max(fetchTimeoutMs, 35000);
                            }
                        } catch(_){ }
                        const response = await fetchWithTimeout(endpoint, {}, fetchTimeoutMs);
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        try {
                            const st = response.headers.get('Server-Timing');
                            if (st) console.info('[PERF] Server-Timing (today-games):', st);
                            const xr = response.headers.get('X-Response-Time');
                            if (xr) console.info('[PERF] X-Response-Time (today-games):', xr);
                        } catch(_){ }
                        data = await response.json();
                        break;
                    } catch (e) {
                        lastErr = e;
                        attempt += 1;
                        console.warn('today-games fetch attempt failed', attempt, e);
                        const isAbort = (e && (e.name === 'AbortError' || String(e).includes('aborted')));
                        // On first failure of any kind, try to paint a quick snapshot if not already done
                        if (!usedQuickFallback && !paintedQuick) {
                            // Immediately fetch quick snapshot to render something, then continue attempts in background
                            usedQuickFallback = true;
                            try {
                                console.info('[FALLBACK] loading quick snapshot for immediate render');
                                const q = await fetchWithTimeout(`/api/today-games/quick?date=${encodeURIComponent(date||'')}`, {}, 6000);
                                if (q.ok) {
                                    const snap = await q.json();
                                    if (snap && snap.success && Array.isArray(snap.games) && snap.games.length) {
                                        // Render snapshot right away
                                        hydrateFromTodayGames(snap, container);
                                        paintedQuick = true;
                                        clearTimeout(slowTimer); clearTimeout(watchdog);
                                        // After snapshot paint, keep trying full endpoint once more with longer timeout
                                        fetchTimeoutMs = Math.min(fetchTimeoutMs + 15000, 45000);
                                    }
                                }
                            } catch(ex){ console.debug('quick snapshot failed', ex); }
                        }
                        if (isAbort && attempt < 3) {
                            fetchTimeoutMs = Math.min(fetchTimeoutMs + 10000, 45000);
                        }
                    }
                }
                try { window.__PERF.mark('todayGames_fetch_end'); } catch(_){}
                if (!data) throw lastErr || new Error('Failed to load today-games');
                
                console.log('API Response:', data);
                console.log('Games count:', data.games?.length);
                
                if (data.success && data.games.length > 0) {
                    try { window.__PERF.mark('render_start'); } catch(_){}
                    console.log('Processing games...');
                    // If we previously rendered a quick snapshot, clear sections before re-render to avoid dupes
                    try {
                        if (usedQuickFallback) {
                            document.getElementById('live-games-container').innerHTML = '';
                            document.getElementById('upcoming-games-container').innerHTML = '';
                            document.getElementById('completed-games-container').innerHTML = '';
                        }
                    } catch(_){ }
                    
                    // Build a quick lookup of full games by game_id for later (finals UI)
                    window.__GAME_BY_ID = window.__GAME_BY_ID || {};
                    try {
                        data.games.forEach(g => { if (g && g.game_id != null) window.__GAME_BY_ID[g.game_id] = g; });
                    } catch(_){ }
                    
                    // Categorize games
                    const liveGames = [];
                    const upcomingGames = [];
                    const completedGames = [];
                    
                    // Track unique games to prevent duplicates
                    const uniqueGames = new Map();
                    
                    for (const game of data.games) {
                        // Include game_pk (or DH game_number) in key to avoid collapsing doubleheaders
                        const dhSuffix = game.game_pk
                            ? `_${game.game_pk}`
                            : (game.meta && game.meta.doubleheader && game.meta.game_number ? `_G${game.meta.game_number}` : '');
                        const gameKey = `${game.away_team}_${game.home_team}_${game.date}${dhSuffix}`;
                        
                        // Only add if we haven't seen this game before
                        if (!uniqueGames.has(gameKey)) {
                            uniqueGames.set(gameKey, game);
                            
                            const liveStatus = game.live_status || {};
                            console.log(`Game: ${game.away_team} @ ${game.home_team}`);
                            console.log(`Live status:`, liveStatus);
                            
                            if (liveStatus.is_live) {
                                console.log(`Adding to live games`);
                                liveGames.push(game);
                            } else if (liveStatus.is_final) {
                                console.log(`Adding to completed games`);
                                completedGames.push(game);
                            } else {
                                console.log(`Adding to upcoming games`);
                                upcomingGames.push(game);
                            }
                        }
                    }
                    
                    // Sort games within each category
                    liveGames.sort((a, b) => {
                        // Live games: show by game time
                        const timeA = new Date(a.game_time || 0);
                        const timeB = new Date(b.game_time || 0);
                        return timeA - timeB;
                    });
                    
                    upcomingGames.sort((a, b) => {
                        // Upcoming: earliest games first using robust sort key
                        return gameSortKey(a) - gameSortKey(b);
                    });
                    
                    completedGames.sort((a, b) => {
                        // Completed: most recently finished first
                        const timeA = new Date(a.game_time || 0);
                        const timeB = new Date(b.game_time || 0);
                        return timeB - timeA;
                    });
                    
                    // Display each section
                    displayGameSection('live-games', liveGames);
                    displayGameSection('upcoming-games', upcomingGames);
                    displayGameSection('completed-games', completedGames);
                    
                    // Hide main container only after sections are populated
                    container.style.display = 'none';
                    
                    console.log(`Loaded games: ${liveGames.length} live, ${upcomingGames.length} upcoming, ${completedGames.length} completed`);

                    // Trigger an initial live update now that cards are rendered
                    updateLiveGames();
                    // Start periodic live updates only after cards exist
                    startLiveUpdates();
                    // Pitcher props unified fetch removed from main page
                    try {
                        window.__PERF.mark('render_end');
                        const m = window.__PERF.marks || {};
                        const t0 = window.__PERF.t0 || 0;
                        const fetchMs = (m.todayGames_fetch_end ?? 0) - (m.todayGames_fetch_start ?? 0);
                        const renderMs = (m.render_end ?? 0) - (m.render_start ?? 0);
                        const totalMs = (m.render_end ?? performance.now()) - t0;
                        const summary = { fetch: Math.max(0, fetchMs), render: Math.max(0, renderMs), total: Math.max(0, totalMs) };
                        window.__PERF.data.summary = summary;
                        console.info('[PERF] load summary:', summary);
                        window.__PERF.updateBadge(summary);
                    } catch(_){ }
                } else {
                    container.style.display = '';
                    container.innerHTML = '<div class="error">No games found for today.</div>';
                }
            } catch (error) {
                console.error('Error loading games:', error);
                // Try one last-ditch quick snapshot if we haven't already painted anything
                try {
                    const hasCard = !!document.querySelector('.game-card');
                    if (!hasCard) {
                        const q = await fetchWithTimeout(`/api/today-games/quick?date=${encodeURIComponent(date||'')}`, {}, 6000);
                        if (q.ok) {
                            const snap = await q.json();
                            if (snap && snap.success && Array.isArray(snap.games) && snap.games.length) {
                                console.info('[FALLBACK] rendered quick snapshot after error');
                                hydrateFromTodayGames(snap, container);
                                clearTimeout(slowTimer); clearTimeout(watchdog);
                                return;
                            }
                        }
                    }
                } catch(_){ }
                container.style.display = '';
                container.innerHTML = `
                    <div class="error">
                        Error loading games: ${error.message || 'Network error'}<br/>
                        <button class="btn" style="margin-top:10px" onclick="loadTodaysGames()">Retry</button>
                    </div>`;
            }
            finally { clearTimeout(slowTimer); clearTimeout(watchdog); clearTimeout(quickPaintTimer); }
        }

        // Helper to render a today-games JSON payload into sections
        function hydrateFromTodayGames(data, container){
            try {
                const liveGames = [];
                const upcomingGames = [];
                const completedGames = [];
                const uniqueGames = new Map();
                (data.games||[]).forEach(game => {
                    // Include game_pk (or DH game_number) in key to avoid collapsing doubleheaders
                    const dhSuffix = game.game_pk
                        ? `_${game.game_pk}`
                        : (game.meta && game.meta.doubleheader && game.meta.game_number ? `_G${game.meta.game_number}` : '');
                    const gameKey = `${game.away_team}_${game.home_team}_${game.date}${dhSuffix}`;
                    if (uniqueGames.has(gameKey)) return;
                    uniqueGames.set(gameKey, true);
                    const ls = game.live_status || {};
                    if (ls.is_live) liveGames.push(game);
                    else if (ls.is_final) completedGames.push(game);
                    else upcomingGames.push(game);
                });
                // Sort like main path
                const sortKey = (g)=>{ try{ return gameSortKey(g);}catch(_){return Number.MAX_SAFE_INTEGER;}};
                liveGames.sort((a,b)=> new Date(a.game_time||0)-new Date(b.game_time||0));
                upcomingGames.sort((a,b)=> sortKey(a)-sortKey(b));
                completedGames.sort((a,b)=> new Date(b.game_time||0)-new Date(a.game_time||0));
                displayGameSection('live-games', liveGames);
                displayGameSection('upcoming-games', upcomingGames);
                displayGameSection('completed-games', completedGames);
                container.style.display = 'none';
                // Trigger live updates
                updateLiveGames();
                startLiveUpdates();
                
            } catch(e){ console.warn('hydrateFromTodayGames failed', e); }
        }

        // Global JS error surface (so silent errors don‚Äôt leave spinner forever)
        window.addEventListener('error', (ev) => {
            try {
                const container = document.getElementById('games-container');
                if (!container) return;
                const hasLoading = !!container.querySelector('.loading');
                if (!hasLoading) return;
                container.style.display = '';
                container.innerHTML = `
                    <div class="error">
                        A script error occurred: ${ev.message || 'Unknown error'}<br/>
                        <small>${(ev.filename||'')}:${(ev.lineno||'')}</small><br/>
                        <button class="btn" style="margin-top:10px" onclick="loadTodaysGames()">Retry</button>
                    </div>`;
            } catch(_){}
        });

        function displayGameSection(sectionPrefix, games) {
            const section = document.getElementById(`${sectionPrefix}-section`);
            const container = document.getElementById(`${sectionPrefix}-container`);
            
            console.log(`Displaying ${sectionPrefix} with ${games.length} games`);
            
            if (games.length > 0) {
                console.log(`Showing section: ${sectionPrefix}-section`);
                // Remove hidden class that enforces display:none !important
                try { section.classList.remove('hidden'); } catch(_) {}
                // Also set display block for good measure
                section.style.display = 'block';
                container.innerHTML = '';
                
                games.forEach((game, index) => {
                    console.log(`Creating card ${index + 1} for ${game.away_team} @ ${game.home_team}`);
                    const gameCard = createGameCard(game);
                    container.appendChild(gameCard);
                });
                
                console.log(`Added ${games.length} game cards to ${sectionPrefix}-container`);
                // After cards render, attempt to rebuild prop sections if unified data is present
                try { rebuildAllGameCardPitcherProps(); } catch(_) {}
            } else {
                console.log(`Hiding section: ${sectionPrefix}-section (no games)`);
                // Ensure the section is hidden and cleared when empty
                try { section.classList.add('hidden'); } catch(_) {}
                section.style.display = 'none';
                try { container.innerHTML = ''; } catch(_) {}
            }
        }

        // Keep the old loadGames function for historical page
        async function loadGames() {
            const date = document.getElementById('game-date').value;
            const container = document.getElementById('games-container');
            
            container.innerHTML = '<div class="loading">Loading games...</div>';
            
            try {
                const response = await fetch(`/api/today-games?date=${date}`);
                const data = await response.json();
                
                if (data.success && data.games.length > 0) {
                    // Clear container completely to prevent duplicates
                    container.innerHTML = '';
                    
                    const gamesGrid = document.createElement('div');
                    gamesGrid.className = 'games-grid';
                    
                    // Track unique games to prevent duplicates
                    const uniqueGames = new Map();
                    
                    for (const game of data.games) {
                        // Include game_pk (or DH game_number) in key to avoid collapsing doubleheaders
                        const dhSuffix = game.game_pk
                            ? `_${game.game_pk}`
                            : (game.meta && game.meta.doubleheader && game.meta.game_number ? `_G${game.meta.game_number}` : '');
                        const gameKey = `${game.away_team}_${game.home_team}_${game.date}${dhSuffix}`;
                        
                        // Only add if we haven't seen this game before
                        if (!uniqueGames.has(gameKey)) {
                            uniqueGames.set(gameKey, game);
                            const gameCard = createGameCard(game);
                            gamesGrid.appendChild(gameCard);
                        }
                    }
                    
                    container.appendChild(gamesGrid);
                    console.log(`Loaded ${uniqueGames.size} unique games`);
                } else {
                    container.innerHTML = '<div class="error">No games found for this date.</div>';
                }
            } catch (error) {
                container.innerHTML = '<div class="error">Error loading games: ' + error.message + '</div>';
            }
        }

        function createGameCard(game) {
            const card = document.createElement('div');
            card.className = 'game-card';
            // Use a composite key that matches live-status lookups and add explicit team attributes; include game_pk to disambiguate DH
            const compositeId = `${game.away_team}_${game.home_team}_${game.date}${game.game_pk ? '_' + game.game_pk : ''}`;
            card.setAttribute('data-game-id', compositeId);
            if (game.game_pk) {
                card.setAttribute('data-game-pk', String(game.game_pk));
            }
            card.setAttribute('data-away-team', (game.away_team || '').toLowerCase());
            card.setAttribute('data-home-team', (game.home_team || '').toLowerCase());
            // Open modal using already-loaded game data (faster, avoids API errors)
            card.onclick = () => openGameModal(game);
            
            // Debug: log the entire game object
            console.log(`üîç CREATING CARD FOR: ${game.away_team} @ ${game.home_team}`);
            console.log('Full game object:', game);
            console.log('Pitcher data:', {
                away_pitcher: game.away_pitcher,
                home_pitcher: game.home_pitcher
            });
            console.log('Prediction data:', {
                predicted_away_score: game.predicted_away_score,
                predicted_home_score: game.predicted_home_score,
                predicted_total_runs: game.predicted_total_runs,
                away_win_probability: game.away_win_probability,
                home_win_probability: game.home_win_probability
            });
            
            // Get team assets for logos and colors
            const awayAssets = game.away_team_assets || { logo_url: game.away_logo };
            const homeAssets = game.home_team_assets || { logo_url: game.home_logo };
            
            // Get team colors for dynamic styling
            const awayColors = game.away_team_colors || { primary: '#333333', secondary: '#666666', text: '#FFFFFF' };
            const homeColors = game.home_team_colors || { primary: '#333333', secondary: '#666666', text: '#FFFFFF' };
            
            // Get live status information
            const liveStatus = game.live_status || {
                status: 'Scheduled',
                badge_class: 'scheduled',
                game_time: 'TBD',
                is_live: false,
                is_final: false
            };
            
            // Format game time - only show for scheduled games
            let displayTime = '';
            let displayStatus = liveStatus.status;
            
            // Only show time for scheduled games (not live or final)
            if (!liveStatus.is_live && !liveStatus.is_final) {
                // First, try to use the already-formatted time from live_status
                if (liveStatus.game_time && liveStatus.game_time !== 'TBD' && 
                    !liveStatus.game_time.includes('T') && !liveStatus.game_time.includes('Z')) {
                    // This is already a formatted time like "7:10 PM"
                    displayTime = liveStatus.game_time;
                } 
                // Otherwise, try to convert the raw game time
                else if (game.game_time && game.game_time !== 'TBD') {
                    try {
                        // Handle ISO or meridian strings like "10:45 PM ET"
                        let gameTimeString = game.game_time;
                        console.log('üïê Processing game time:', gameTimeString);
                        if (/^(\d{1,2}):(\d{2})\s*(AM|PM)\s*ET$/i.test(gameTimeString)) {
                            displayTime = etToCtDisplay(gameTimeString);
                            console.log('‚úÖ ET string converted to:', displayTime);
                        } else if (/(T|Z)/.test(gameTimeString)) {
                            displayTime = isoToCtDisplay(gameTimeString) || 'TBD';
                            console.log('‚úÖ ISO time converted to CT:', displayTime);
                        } else if (/^(\d{1,2}):(\d{2})\s*(AM|PM)$/i.test(gameTimeString)) {
                            // Already a meridian string without TZ; display as-is
                            displayTime = gameTimeString.trim();
                            console.log('‚ÑπÔ∏è Using provided meridian string:', displayTime);
                        } else {
                            console.error('‚ùå Unrecognized time format:', gameTimeString);
                            displayTime = 'TBD';
                        }
                    } catch (error) {
                        console.error('‚ùå Error converting game time:', error);
                        displayTime = 'TBD';
                    }
                }
            }
            
            // For live games, enhance status with inning info if available
            if (liveStatus.is_live && liveStatus.inning && liveStatus.inning_state) {
                displayStatus = `${liveStatus.inning_state} ${liveStatus.inning}`;
            }
            
            // Get real betting lines data
            const realLines = game.real_betting_lines || {};
            const moneyline = realLines.moneyline || {};
            const totalRuns = realLines.total_runs || {};
            const runLine = realLines.run_line || {};
            
            let bettingLinesHtml = '';
            // Show betting lines if we have real betting lines data
            if (game.has_real_betting_lines && Object.keys(realLines).length > 0) {
                // Format moneyline odds with proper + sign for positive values
                const formatOdds = (odds) => {
                    if (!odds) return 'N/A';
                    return odds > 0 ? `+${odds}` : `${odds}`;
                };
                
                // Format run line with proper +/- signs - handle both string and numeric formats
                const formatRunLine = (line, odds, isAway = true) => {
                    if (!line) return 'N/A';
                    
                    // Handle string format like "-1.5 (+130)"
                    if (typeof odds === 'string') {
                        return odds;
                    }
                    
                    // Handle numeric format from OddsAPI
                    if (typeof odds === 'number') {
                        const lineStr = isAway ? (line > 0 ? `+${line}` : `${line}`) : (line > 0 ? `-${line}` : `+${Math.abs(line)}`);
                        const oddsStr = odds > 0 ? `+${odds}` : `${odds}`;
                        return `${lineStr} (${oddsStr})`;
                    }
                    
                    return 'N/A';
                };
                
                bettingLinesHtml = `
                    <div class="betting-lines">
                        <h4>DraftKings Betting Lines</h4>
                        <div class="betting-grid">
                            <div class="betting-item">
                                <div class="line-label">Moneyline</div>
                                <div class="line-value">
                                    <div class="moneyline-away">${game.away_team.substring(0, 3)}: ${formatOdds(moneyline.away)}</div>
                                    <div class="moneyline-home">${game.home_team.substring(0, 3)}: ${formatOdds(moneyline.home)}</div>
                                </div>
                            </div>
                            <div class="betting-item">
                                <div class="line-label">Over/Under</div>
                                <div class="line-value">
                                    ${totalRuns.line ? `${totalRuns.line}` : 'N/A'}<br>
                                    ${totalRuns.over && totalRuns.under ? `O: ${formatOdds(totalRuns.over)} / U: ${formatOdds(totalRuns.under)}` : ''}
                                </div>
                            </div>
                            <div class="betting-item">
                                <div class="line-label">Run Line</div>
                                <div class="line-value">
                                    <div class="moneyline-away">${game.away_team.substring(0, 3)}: ${formatRunLine(runLine.line, runLine.away, true)}</div>
                                    <div class="moneyline-home">${game.home_team.substring(0, 3)}: ${formatRunLine(runLine.line, runLine.home, false)}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Build Batter vs Pitcher line for live header (Top -> home pitcher, Bottom -> away pitcher)
            const liveVsLine = liveStatus.is_live ? buildBatterVsPitcher(
                liveStatus.current_batter,
                liveStatus.inning_state,
                (liveStatus.away_pitcher || game.away_pitcher),
                (liveStatus.home_pitcher || game.home_pitcher),
                typeof liveStatus.is_top_inning === 'boolean' ? liveStatus.is_top_inning : undefined
            ) : '';

            card.innerHTML = `
                <div class="game-header">
                    <div class="header-left game-teams">
                        <div class="team-info" style="background: linear-gradient(135deg, ${awayColors.primary}, ${awayColors.secondary}); color: ${awayColors.text}; border-radius: 8px; padding: 6px 8px;">
                            <img src="${awayAssets.logo_url || ''}" alt="${game.away_team}" class="team-logo" />
                            <span class="team-name">${game.away_team}</span>
                        </div>
                    </div>
                    <div class="header-center">
                        ${liveStatus.is_live ? `
                            <div class="live-header" data-dynamic="header-center">
                                ${(() => {
                                    const countChip = (liveStatus.balls != null && liveStatus.strikes != null) ? `<span class="count-chip">${liveStatus.balls} balls, ${liveStatus.strikes} strikes</span>` : '';
                                    if (liveVsLine) return `<div class="batter-line">${liveVsLine}${countChip ? ` ${countChip}` : ''}</div>`;
                                    if (liveStatus.current_batter) return `<div class="batter-line">${liveStatus.current_batter}${countChip ? ` ${countChip}` : ''}</div>`;
                                    return '';
                                })()}

                                ${liveStatus.last_play ? `<div class=\"last-play-line\">${liveStatus.last_play}</div>` : ''}
                            </div>
                        ` : `
                            ${displayTime ? `<div class=\"game-time\">${displayTime}</div>` : ''}
                            <span class=\"game-status-badge badge-${liveStatus.badge_class}\">${displayStatus}</span>
                            ${game.doubleheader ? `<span class=\"game-status-badge badge-scheduled\" title=\"Doubleheader\">DH G${game.doubleheader_game_number || 1}</span>` : ''}
                        `}
                    </div>
                    <div class="header-right game-teams" style="justify-content: end;">
                        <div class="team-info" style="background: linear-gradient(135deg, ${homeColors.primary}, ${homeColors.secondary}); color: ${homeColors.text}; border-radius: 8px; padding: 6px 8px;">
                            <img src="${homeAssets.logo_url || ''}" alt="${game.home_team}" class="team-logo" />
                            <span class="team-name">${game.home_team}</span>
                        </div>
                    </div>
                </div>

                <div class="card-body">
                    <div class="card-section transparent">
                        <div class="starting-pitchers">
                            <div class="pitcher-matchup">
                                <div class="away-pitcher">
                                    <span class="pitcher-label">Starting Pitcher:</span>
                                    <span class="pitcher-name">${game.away_pitcher || 'TBD'}</span>
                                </div>
                                <span class="vs-separator">vs</span>
                                <div class="home-pitcher">
                                    <span class="pitcher-label">Starting Pitcher:</span>
                                    <span class="pitcher-name">${game.home_pitcher || 'TBD'}</span>
                                </div>
                            </div>
                        </div>
                        
                    </div>
                    <div class="card-section">
                        <div class="prediction-summary" id="summary-${game.game_id}">
                            ${createPredictionSummaryHtml(game)}
                        </div>
                        ${game.betting_recommendations ? createBettingRecommendationsHtml(game.betting_recommendations, game.away_team, game.home_team) : ''}
                        ${bettingLinesHtml}
                    </div>
                </div>
            `;
            
            return card;
        }

        function createPredictionSummaryHtml(game) {
            // Use prediction data directly from the game object
            const predictedAwayScore = game.predicted_away_score || 0;
            const predictedHomeScore = game.predicted_home_score || 0;
            const awayWinProb = game.away_win_probability || 0;
            const homeWinProb = game.home_win_probability || 0;
            const predictedWinner = game.predicted_winner || '';
            
            console.log('Creating prediction summary for:', game.away_team, '@', game.home_team);
            console.log('Prediction data:', { predictedAwayScore, predictedHomeScore, awayWinProb, homeWinProb });
            
            // If no prediction data, show placeholder
            if (!predictedAwayScore && !predictedHomeScore) {
                console.log('No prediction data found, showing placeholder');
                return `
                    <div class="prediction-item">
                        <div class="value">--</div>
                        <div class="label">No Prediction</div>
                    </div>
                `;
            }
            
            console.log('Creating prediction summary with data');
            return `
                <div class="prediction-item">
                    <div class="value">${predictedAwayScore}</div>
                    <div class="label">${game.away_team.split(' ').pop()}</div>
                </div>
                <div class="prediction-item">
                    <div class="value">${predictedHomeScore}</div>
                    <div class="label">${game.home_team.split(' ').pop()}</div>
                </div>
                <div class="prediction-item">
                    <div class="value">${homeWinProb.toFixed(2)}%</div>
                    <div class="label">Home Win</div>
                </div>
            `;
        }

    function createLiveScoreHtml(liveStatus, awayColors = null, homeColors = null) {
            // Only hide if scores are truly missing; show 0-0 as valid
            if (liveStatus.away_score == null && liveStatus.home_score == null) {
                return '';
            }
            
            // Default colors if not provided
            const defaultAwayColors = awayColors || { primary: '#333333', secondary: '#666666', text: '#FFFFFF' };
            const defaultHomeColors = homeColors || { primary: '#444444', secondary: '#777777', text: '#FFFFFF' };
            
            // Create inning display for live games
            let inningDisplay = 'LIVE';
            if (liveStatus.inning && liveStatus.inning_state) {
                inningDisplay = `${liveStatus.inning_state} ${liveStatus.inning}`;
            }
            const count = (liveStatus.balls != null && liveStatus.strikes != null) ? ` | ${liveStatus.balls} balls, ${liveStatus.strikes} strikes` : '';
            const bases = liveStatus.base_state ? ` | ${liveStatus.base_state}` : '';
            const outsVal = (liveStatus.outs != null) ? ` | Outs ${liveStatus.outs}` : '';
            // Optional runner dots
            const r1 = liveStatus.on_first ? '‚óè' : '‚óã';
            const r2 = liveStatus.on_second ? '‚óè' : '‚óã';
            const r3 = liveStatus.on_third ? '‚óè' : '‚óã';
            const runners = (liveStatus.on_first || liveStatus.on_second || liveStatus.on_third) ? ` | ${r1} ${r2} ${r3}` : '';
            const batter = liveStatus.current_batter ? ` | ${liveStatus.current_batter}` : '';
            
            return `
                <div class="live-score">
                    <div style="background: ${defaultAwayColors.primary}; color: ${defaultAwayColors.text}; padding: 4px 8px; border-radius: 4px; border: 1px solid ${defaultAwayColors.secondary};">
                        <span class="team-score">${liveStatus.away_score ?? 0}</span>
                    </div>
                    <div style="color: #dc3545; font-weight: bold; font-size: 0.9em;">${inningDisplay}${count}${outsVal}${bases}${runners}${liveStatus.current_batter ? ` | Hitter: ${liveStatus.current_batter}` : ''}</div>
                    ${liveStatus.last_play ? `<div style="grid-column: 1 / -1; font-size: 0.8rem; opacity: 0.9; margin-top: 4px;">Last play: ${liveStatus.last_play}</div>` : ''}
                    <div style="background: ${defaultHomeColors.primary}; color: ${defaultHomeColors.text}; padding: 4px 8px; border-radius: 4px; border: 1px solid ${defaultHomeColors.secondary};">
                        <span class="team-score">${liveStatus.home_score ?? 0}</span>
                    </div>
                </div>
            `;
        }

        function createFinalScoreHtml(liveStatus, game, awayColors = null, homeColors = null) {
            if (liveStatus.away_score == null && liveStatus.home_score == null) {
                return '';
            }
            
            // Default colors if not provided
            const defaultAwayColors = awayColors || { primary: '#333333', secondary: '#666666', text: '#FFFFFF' };
            const defaultHomeColors = homeColors || { primary: '#444444', secondary: '#777777', text: '#FFFFFF' };
            
            // Use game data directly as it contains prediction info
            const predictedAwayScore = game.predicted_away_score || 0;
            const predictedHomeScore = game.predicted_home_score || 0;
            const predictedTotalRuns = game.predicted_total_runs || (predictedAwayScore + predictedHomeScore);
            
            // Debug: Check what's happening with predicted total runs
            console.log(`üêõ DEBUGGING Total Runs for ${game.away_team} @ ${game.home_team}:`);
            console.log(`  - game.predicted_total_runs: ${game.predicted_total_runs}`);
            console.log(`  - predictedAwayScore: ${predictedAwayScore}`);
            console.log(`  - predictedHomeScore: ${predictedHomeScore}`);
            console.log(`  - calculated predictedTotalRuns: ${predictedTotalRuns}`);
            
            const actualAwayScore = liveStatus.away_score || 0;
            const actualHomeScore = liveStatus.home_score || 0;
            const actualTotalRuns = actualAwayScore + actualHomeScore;
            
            // Winner prediction accuracy
            const predictedWinner = predictedAwayScore > predictedHomeScore ? 'away' : 'home';
            const actualWinner = actualAwayScore > actualHomeScore ? 'away' : 'home';
            const winnerCorrect = predictedWinner === actualWinner;
            
            // Score difference analysis
            const awayScoreDiff = Math.abs(actualAwayScore - predictedAwayScore);
            const homeScoreDiff = Math.abs(actualHomeScore - predictedHomeScore);
            const avgScoreDiff = (awayScoreDiff + homeScoreDiff) / 2;
            
            // Total runs analysis
            const totalRunsDiff = Math.abs(actualTotalRuns - predictedTotalRuns);
            const totalRunsAccuracy = totalRunsDiff <= 1 ? 'Excellent' : 
                                     totalRunsDiff <= 2 ? 'Good' : 
                                     totalRunsDiff <= 3 ? 'Fair' : 'Poor';
            
            // Use the original bet_grade if available (from enhanced grading), otherwise calculate
            let grade = game.bet_grade || '';
            let gradePoints = 0;
            
            // If no bet_grade available, calculate traditional accuracy grade
            if (!grade) {
                if (winnerCorrect) gradePoints += 50;
                if (avgScoreDiff <= 1) gradePoints += 30;
                else if (avgScoreDiff <= 2) gradePoints += 20;
                else if (avgScoreDiff <= 3) gradePoints += 10;
                if (totalRunsDiff <= 1) gradePoints += 20;
                else if (totalRunsDiff <= 2) gradePoints += 15;
                else if (totalRunsDiff <= 3) gradePoints += 10;
                
                if (gradePoints >= 90) grade = 'A+';
                else if (gradePoints >= 80) grade = 'A';
                else if (gradePoints >= 70) grade = 'B+';
                else if (gradePoints >= 60) grade = 'B';
                else if (gradePoints >= 50) grade = 'C';
                else grade = 'D';
            }
            
            // Betting line analysis (if comprehensive analysis available)
            let bettingAnalysisHtml = '';
            const postGameAnalysis = game.post_game_analysis;
            if (postGameAnalysis && postGameAnalysis.betting_analysis) {
                const bettingAnalysis = postGameAnalysis.betting_analysis;
                
                let marketVsModelHtml = '';
                if (bettingAnalysis.betting_favorite) {
                    const favoriteWon = bettingAnalysis.favorite_won;
                    const modelBeatMarket = bettingAnalysis.model_beat_market;
                    
                    marketVsModelHtml = `
                        <div class="analysis-item ${favoriteWon ? 'analysis-correct' : 'analysis-incorrect'}">
                            <strong>Market Favorite:</strong> ${favoriteWon ? '‚úÖ Won' : '‚ùå Lost'}
                        </div>
                        <div class="analysis-item ${modelBeatMarket ? 'analysis-correct' : 'analysis-incorrect'}">
                            <strong>Model vs Market:</strong> ${modelBeatMarket ? '‚úÖ Beat Market' : '‚ùå Followed Market'}
                        </div>
                    `;
                }
                
                let totalBetHtml = '';
                if (bettingAnalysis.total_analysis) {
                    const totalAnalysis = bettingAnalysis.total_analysis;
                    const modelCorrectTotal = totalAnalysis.model_correct_total;
                    
                    totalBetHtml = `
                        <div class="analysis-item ${modelCorrectTotal ? 'analysis-correct' : 'analysis-incorrect'}">
                            <strong>Total Bet:</strong> ${modelCorrectTotal ? '‚úÖ Correct' : '‚ùå Incorrect'} (Line: ${totalAnalysis.line})
                        </div>
                    `;
                }
                
                if (marketVsModelHtml || totalBetHtml) {
                    bettingAnalysisHtml = `
                        <div class="betting-comparison">
                            <h6>üìà Model vs Market Performance</h6>
                            <div class="betting-grid">
                                ${marketVsModelHtml}
                                ${totalBetHtml}
                            </div>
                        </div>
                    `;
                }
            }
            
            return `
                <div class="live-score">
                    <div>
                        <span style="color: #ff6b6b;">${liveStatus.away_team ? liveStatus.away_team.substring(0, 3) : 'AWAY'}</span>
                        <span class="team-score">${actualAwayScore}</span>
                    </div>
                    <div style="color: #28a745; font-weight: bold; font-size: 0.9em;">FINAL</div>
                    <div>
                        <span style="color: #4ecdc4;">${liveStatus.home_team ? liveStatus.home_team.substring(0, 3) : 'HOME'}</span>
                        <span class="team-score">${actualHomeScore}</span>
                    </div>
                </div>
                <div class="final-analysis">
                    <h5>üìä Prediction Analysis (Grade: ${grade})</h5>
                    <div class="analysis-grid">
                        <div class="analysis-item ${winnerCorrect ? 'analysis-correct' : 'analysis-incorrect'}">
                            <strong>Winner:</strong> ${winnerCorrect ? '‚úÖ Correct' : '‚ùå Incorrect'}
                        </div>
                        <div class="analysis-item">
                            <strong>Score Error:</strong> ¬±${avgScoreDiff.toFixed(2)} runs
                        </div>
                        <div class="analysis-item">
                            <strong>Total Runs:</strong> ${actualTotalRuns} (predicted ${predictedTotalRuns})
                        </div>
                        <div class="analysis-item">
                            <strong>Total Accuracy:</strong> ¬±${totalRunsDiff} runs (${totalRunsAccuracy})
                        </div>
                    </div>
                    ${bettingAnalysisHtml}
                </div>
            `;
        }

        async function loadQuickPrediction(awayTeam, homeTeam, date, gameId) {
            try {
                const response = await fetch(`/api/prediction/${awayTeam}/${homeTeam}?date=${date}`);
                const data = await response.json();
                
                if (data.success) {
                    const pred = data.prediction;  // data is directly in prediction object
                    const meta = data.prediction.meta;
                    
                    const summaryElement = document.getElementById(`summary-${gameId}`);
                    if (summaryElement) {
                        // Get pitcher information for display
                        const awayPitcher = pred.away_pitcher || 'TBD';
                        const homePitcher = pred.home_pitcher || 'TBD';
                        
                        summaryElement.innerHTML = `
                            <div class="prediction-item">
                                <div class="value">${pred.predicted_away_score}</div>
                                <div class="label">${awayTeam.split(' ').pop()}</div>
                            </div>
                            <div class="prediction-item">
                                <div class="value">${pred.predicted_home_score}</div>
                                <div class="label">${homeTeam.split(' ').pop()}</div>
                            </div>
                            <div class="prediction-item">
                                <div class="value">${pred.home_win_probability.toFixed(2)}%</div>
                                <div class="label">Home Win</div>
                            </div>
                        `;
                        
                        // Add quick betting tip if available
                        const bettingRecs = data.betting_recommendations;  // Get from top level of data object
                        if (bettingRecs && bettingRecs.best_bet) {
                            const bestBet = bettingRecs.best_bet;
                            const icon = bestBet.edge_rating || 'üéØ';
                            summaryElement.innerHTML += `
                                <div class="prediction-item betting-tip" style="background: rgba(79, 209, 199, 0.2); border-left: 2px solid #4fd1c7;">
                                    <div class="value" style="font-size: 0.8em;">${icon} ${bestBet.recommendation || bestBet.bet || 'Value Bet'}</div>
                                    <div class="label" style="font-size: 0.7em;">Best Bet</div>
                                </div>
                            `;
                        }
                        
                        // Betting recommendations are now included in initial load, no need to add dynamically
                        // This prevents double display issues
                    }
                    
                    // Update betting lines if available (only if not already present)
                    const bettingData = data.prediction.betting_data;
                    if (bettingData) {
                        const gameCard = document.querySelector(`#summary-${gameId}`).closest('.game-card');
                        const existingLines = gameCard.querySelector('.betting-lines');
                        
                        if (gameCard && !existingLines) {
                            updateGameCardBetting(gameId, bettingData, awayTeam, homeTeam);
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading quick prediction:', error);
            }
        }

        function updateGameCardBetting(gameId, bettingData, awayTeam, homeTeam) {
            // Find the game card and check if it already has betting lines
            const gameCard = document.querySelector(`#summary-${gameId}`).closest('.game-card');
            
            // Double-check if betting lines already exist to prevent duplicates
            if (!gameCard || gameCard.querySelector('.betting-lines')) {
                return; // Already has betting lines or can't find game card
            }
            
            const moneyline = bettingData.moneyline || {};
            const total = bettingData.total || {};
            const spread = bettingData.spread || {};
            
            const bettingLinesHtml = `
                <div class="betting-lines">
                    <h4>Betting Lines</h4>
                    <div class="betting-grid">
                        <div class="betting-item">
                            <div class="line-label">Moneyline</div>
                            <div class="line-value">
                                <div class="moneyline-away">${awayTeam.substring(0, 3)}: ${moneyline.away || 'N/A'}</div>
                                <div class="moneyline-home">${homeTeam.substring(0, 3)}: ${moneyline.home || 'N/A'}</div>
                            </div>
                        </div>
                        <div class="betting-item">
                            <div class="line-label">Total</div>
                            <div class="line-value">
                                ${total.line ? `O/U ${total.line}` : 'N/A'}
                            </div>
                        </div>
                        <div class="betting-item">
                            <div class="line-label">Spread</div>
                            <div class="line-value">
                                ${spread.line ? `${spread.line > 0 ? '+' : ''}${spread.line}` : 'N/A'}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Insert betting lines after the prediction summary
            const summaryElement = document.getElementById(`summary-${gameId}`);
            summaryElement.insertAdjacentHTML('afterend', bettingLinesHtml);
        }

        function createBettingRecommendationsHtml(bettingRecs, awayTeam, homeTeam) {
            if (!bettingRecs) {
                return '';
            }

            let html = '<div class="betting-recommendations" data-added="true">';
            html += '<h4>üí∞ Betting Recommendations</h4>';
            
            // Add summary if available
            if (bettingRecs.summary) {
                html += `<div style="font-size: 0.9em; color: #888; margin-bottom: 10px;">${bettingRecs.summary}</div>`;
            }

            // Handle new enhanced format with value_bets array
            if (bettingRecs.value_bets && bettingRecs.value_bets.length > 0) {
                bettingRecs.value_bets.forEach(bet => {
                    const confidenceClass = bet.confidence === 'HIGH' ? 'high-confidence' : 
                                          bet.confidence === 'MEDIUM' ? 'medium-confidence' : 'low-confidence';
                    
                    // Add positive EV class if applicable
                    const isPositiveEV = bet.expected_value && bet.expected_value > 0;
                    const cssClasses = isPositiveEV ? `${confidenceClass} positive-ev` : confidenceClass;
                    
                    const icon = bet.edge_rating || (bet.confidence === 'HIGH' ? 'üî•' : 
                               bet.confidence === 'MEDIUM' ? '‚ö°' : 'üí°');
                    
                    // Display the recommendation with enhanced formatting
                    const recommendation = bet.recommendation || `${bet.direction?.toUpperCase()} ${bet.line}`;
                    const edgeText = typeof bet.edge === 'number' ? `${bet.edge.toFixed(2)}% edge` : 
                                    bet.edge ? bet.edge : 
                                    bet.confidence ? `${bet.confidence} CONFIDENCE` : 'Value Bet';
                    
                    // Format Expected Value display - LIMITED TO 2 DECIMAL PLACES MAX
                    let evDisplay = '';
                    let evBadge = '';
                    if (bet.expected_value !== undefined && bet.expected_value !== null) {
                        const evPercent = (bet.expected_value * 100).toFixed(2);
                        const evColor = bet.expected_value > 0 ? '#4fd1c7' : '#ff6b6b';
                        const evSign = bet.expected_value > 0 ? '+' : '';
                        evDisplay = `<span style="color: ${evColor}; font-weight: bold;">EV: ${evSign}${evPercent}%</span>`;
                        
                        // Add +EV badge for positive expected value
                        if (bet.expected_value > 0) {
                            evBadge = `<span class="positive-ev-badge">+EV</span>`;
                        }
                    }
                    
                    html += `
                        <div class="value-bet ${cssClasses}" title="${bet.reasoning || 'No details available'}">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 5px;">
                                    <span>${icon}</span>
                                    <strong>${recommendation}</strong>
                                    ${evBadge}
                                </div>
                                <div style="display: flex; flex-direction: column; align-items: flex-end; font-size: 0.8em;">
                                    <span style="color: #4fd1c7;">${edgeText}</span>
                                    ${evDisplay ? `<div>${evDisplay}</div>` : ''}
                                    ${bet.estimated_odds && bet.estimated_odds !== 'N/A' ? `<span style="color: #888;">${bet.estimated_odds}</span>` : ''}
                                </div>
                            </div>
                            <div style="font-size: 0.85em; color: #ccc; margin-top: 3px; line-height: 1.2;">
                                ${bet.reasoning}
                            </div>
                        </div>
                    `;
                });
            }
            // Handle legacy format
            else if (bettingRecs.recommendations && bettingRecs.recommendations.length > 0) {
                bettingRecs.recommendations.forEach(rec => {
                    if (rec !== "No significant value bets identified") {
                        html += `<div class="value-bet medium-confidence">‚ö° ${rec}</div>`;
                    }
                });
            }

            // If no value bets found
            const noValueBets = (!bettingRecs.value_bets || bettingRecs.value_bets.length === 0);
            const noLegacy = (!bettingRecs.recommendations || bettingRecs.recommendations.every(r => r.includes("No significant")));
            if (noValueBets && noLegacy) {
                html += '<div class="no-value-bet">üí° No strong value bets identified for this game yet. Lines or projections may still be updating.</div>';
            }

            // Add best bet highlight if available
            if (bettingRecs.best_bet) {
                html += `
                    <div style="margin-top: 10px; padding: 8px; background: rgba(79, 209, 199, 0.2); border-left: 3px solid #4fd1c7; border-radius: 4px;">
                        <strong>üéØ Best Bet:</strong> ${bettingRecs.best_bet.recommendation}
                    </div>
                `;
            }

            html += '</div>';
            return html;
        }

        // Open modal preferring robust API-backed details, with graceful fallback
        function openGameModal(game){
            try {
                if (!game) return;
                const body = document.getElementById('modal-body');
                const title = document.getElementById('modal-title');
                const awayAssets = game.away_team_assets || { logo_url: game.away_logo };
                const homeAssets = game.home_team_assets || { logo_url: game.home_logo };

                // Set title immediately
                title.innerHTML = `
                    <div style="display:flex;align-items:center;gap:10px;">
                        <div style="display:flex;align-items:center;gap:6px;">
                            <img src="${awayAssets.logo_url || ''}" alt="${game.away_team}" style="width:24px;height:24px;" />
                            <span>${game.away_team}</span>
                        </div>
                        <span>@</span>
                        <div style="display:flex;align-items:center;gap:6px;">
                            <img src="${homeAssets.logo_url || ''}" alt="${game.home_team}" style="width:24px;height:24px;" />
                            <span>${game.home_team}</span>
                        </div>
                    </div>`;

                // Show loading state and open modal
                body.innerHTML = '<div class="loading">Loading detailed prediction...</div>';
                openModal();

                // Attempt robust load via API
                const date = game.date || (document.getElementById('game-date')?.value || '');
                loadPrediction(game.away_team, game.home_team, date);
            } catch (e){
                // Fallback: lightweight summary + local recs + pitchers
                try {
                    const summaryHtml = (function(){
                        try { return createPredictionSummaryHtml(game); } catch(_) { return ''; }
                    })();
                    const recsHtml = (function(){
                        try {
                            if (game.betting_recommendations) return createBettingRecommendationsHtml(game.betting_recommendations, game.away_team, game.home_team);
                            return '';
                        } catch(_) { return ''; }
                    })();
                    const pitchersHtml = `
                        <div style="margin-top:16px;">
                            <h3>Starting Pitchers</h3>
                            <p><strong>Away:</strong> ${game.away_pitcher || 'TBD'}</p>
                            <p><strong>Home:</strong> ${game.home_pitcher || 'TBD'}</p>
                        </div>`;
                    document.getElementById('modal-body').innerHTML = `
                        <div class="prediction-details">
                            <div class="prediction-summary">${summaryHtml}</div>
                            ${recsHtml}
                            ${pitchersHtml}
                        </div>`;
                    openModal();
                } catch(_){ }
            }
        }

        async function loadPrediction(awayTeam, homeTeam, date) {
            document.getElementById('modal-body').innerHTML = 'Loading detailed prediction...';
            document.getElementById('prediction-modal').style.display = 'block';
            
            console.log(`üîç Loading prediction for: ${awayTeam} @ ${homeTeam} on ${date}`);
            
            try {
                const url = `/api/prediction/${awayTeam}/${homeTeam}?date=${date}`;
                console.log('API URL:', url);
                
                const response = await fetch(url);
                const data = await response.json();
                
                console.log('Prediction API response:', data);
                
                if (data.success) {
                    const prediction = data.prediction;
                    
                    console.log('Betting recommendations in modal:', data.betting_recommendations);
                    
                    // Update modal title with team logos
                    const awayAssets = prediction.away_team_assets || { logo_url: data.game.away_logo };
                    const homeAssets = prediction.home_team_assets || { logo_url: data.game.home_logo };
                    
                    document.getElementById('modal-title').innerHTML = `
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <img src="${awayAssets.logo_url || ''}" alt="${awayTeam}" style="width: 24px; height: 24px;" />
                                <span>${awayTeam}</span>
                            </div>
                            <span>@</span>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <img src="${homeAssets.logo_url || ''}" alt="${homeTeam}" style="width: 24px; height: 24px;" />
                                <span>${homeTeam}</span>
                            </div>
                        </div>
                    `;
                    
                    displayPredictionDetails(data);
                } else {
                    document.getElementById('modal-body').innerHTML = 
                        '<div class="error">Error loading prediction: ' + data.error + '</div>';
                }
            } catch (error) {
                document.getElementById('modal-body').innerHTML = 
                    '<div class="error">Error loading prediction: ' + error.message + '</div>';
            }
        }

        function displayPredictionDetails(data) {
            console.log('üéØ displayPredictionDetails called with:', data);
            console.log('Betting recommendations:', data.betting_recommendations);
            
            const prediction = data && data.prediction ? data.prediction : {};
            const game = data && data.game ? data.game : {};
            const pred = prediction;  // Keep this for backward compatibility with existing code
            const meta = prediction.meta || {
                execution_time_ms: 0,
                simulations_run: prediction.simulation_count || 5000,
                data_source: prediction.model_version || 'simulation'
            };
            const recs = prediction.recommendations || [];
            
            // Extract pitcher information from game data with real factors
            const awayPitcher = { 
                name: game.away_pitcher || 'TBD', 
                factor: game.away_pitcher_factor || 1.0
            };
            const homePitcher = { 
                name: game.home_pitcher || 'TBD', 
                factor: game.home_pitcher_factor || 1.0
            };
            
            // Get team names from game data
            const awayTeam = game.away_team;
            const homeTeam = game.home_team;
            
            // Get team assets for colors
            const awayAssets = prediction.away_team_assets || {};
            const homeAssets = prediction.home_team_assets || {};
            
            let html = `
                <div class="prediction-details">
                    <div class="prediction-summary">
                        <div class="prediction-item" style="background-color: ${awayAssets.primary_color || '#4fd1c7'}22; border-left: 3px solid ${awayAssets.primary_color || '#4fd1c7'};">
                            <div class="value">${pred.predicted_away_score}</div>
                            <div class="label">${awayTeam} Score</div>
                        </div>
                        <div class="prediction-item" style="background-color: ${homeAssets.primary_color || '#4fd1c7'}22; border-left: 3px solid ${homeAssets.primary_color || '#4fd1c7'};">
                            <div class="value">${pred.predicted_home_score}</div>
                            <div class="label">${homeTeam} Score</div>
                        </div>
                        <div class="prediction-item">
                            <div class="value">${pred.predicted_total_runs}</div>
                            <div class="label">Total Runs</div>
                        </div>
                        <div class="prediction-item">
                            <div class="value">${(pred.home_win_probability != null ? Number(pred.home_win_probability).toFixed(2) : '‚Äî')}%</div>
                            <div class="label">Home Win Prob</div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px;">
                        <h3>Starting Pitchers</h3>
                        <p><strong>Away:</strong> ${awayPitcher.name || 'TBD'} (Quality Factor: ${(awayPitcher.factor || 1.0).toFixed(2)})</p>
                        <p><strong>Home:</strong> ${homePitcher.name || 'TBD'} (Quality Factor: ${(homePitcher.factor || 1.0).toFixed(2)})</p>
                        <div style="font-size: 0.9em; color: #888; margin-top: 10px;">
                            <em>Factor < 1.0 = Better pitcher (allows fewer runs), Factor > 1.0 = Weaker pitcher</em>
                        </div>
                    </div>
                    
                    <!-- Add comprehensive factors section -->
                    <div style="margin-top: 20px;">
                        <h3>üìä Model Factors</h3>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 10px;">
                            ${data.factors ? `
                                <!-- Team Strengths -->
                                <div style="padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid #4fd1c7;">
                                    <div style="font-weight: bold; color: #4fd1c7; margin-bottom: 8px;">Team Strengths</div>
                                    <div style="font-size: 0.9em;">
                                        <div style="color: #ff6b6b; margin-bottom: 4px;">${awayTeam}: ${data.factors.team_strengths ? (data.factors.team_strengths.away_strength > 0 ? '+' : '') + data.factors.team_strengths.away_strength.toFixed(3) : 'N/A'}</div>
                                        <div style="color: #4ecdc4;">${homeTeam}: ${data.factors.team_strengths ? (data.factors.team_strengths.home_strength > 0 ? '+' : '') + data.factors.team_strengths.home_strength.toFixed(3) : 'N/A'}</div>
                                    </div>
                                </div>
                                
                                <!-- Bullpen Quality -->
                                <div style="padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid #ffa726;">
                                    <div style="font-weight: bold; color: #ffa726; margin-bottom: 8px;">Bullpen Quality</div>
                                    <div style="font-size: 0.9em;">
                                        <div style="color: #ff6b6b; margin-bottom: 4px;">${awayTeam}: ${data.factors.bullpen_quality ? data.factors.bullpen_quality.away_bullpen.rating + ' (' + data.factors.bullpen_quality.away_bullpen.quality_factor.toFixed(2) + ')' : 'N/A'}</div>
                                        <div style="color: #4ecdc4;">${homeTeam}: ${data.factors.bullpen_quality ? data.factors.bullpen_quality.home_bullpen.rating + ' (' + data.factors.bullpen_quality.home_bullpen.quality_factor.toFixed(2) + ')' : 'N/A'}</div>
                                    </div>
                                </div>
                                
                                <!-- Weather & Park -->
                                ${data.factors.weather_park && Object.keys(data.factors.weather_park).length > 0 ? `
                                <div style="padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid #66bb6a; grid-column: 1 / -1;">
                                    <div style="font-weight: bold; color: #66bb6a; margin-bottom: 8px;">üå§Ô∏è Weather & Park Factors</div>
                                    <div style="font-size: 0.9em; display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                                        <div>Temp: ${data.factors.weather_park.temperature}¬∞F</div>
                                        <div>Wind: ${data.factors.weather_park.wind_speed} mph</div>
                                        <div>Conditions: ${data.factors.weather_park.weather_condition}</div>
                                        <div>Park Factor: ${data.factors.weather_park.park_factor.toFixed(2)}</div>
                                        <div>Runs Factor: ${data.factors.weather_park.total_runs_factor.toFixed(2)}</div>
                                    </div>
                                </div>
                                ` : `
                                <div style="padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid #888; grid-column: 1 / -1;">
                                    <div style="font-weight: bold; color: #888; margin-bottom: 8px;">üå§Ô∏è Weather & Park Factors</div>
                                    <div style="font-size: 0.9em; color: #888; font-style: italic;">Weather data not available</div>
                                </div>
                                `}
                            ` : `
                                <div style="padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid #888; grid-column: 1 / -1;">
                                    <div style="font-weight: bold; color: #888; margin-bottom: 8px;">üìä Model Factors</div>
                                    <div style="font-size: 0.9em; color: #888; font-style: italic;">Factor details not available</div>
                                </div>
                            `}
                        </div>
                        <div style="font-size: 0.8em; color: #888; margin-top: 10px; text-align: center;">
                            <em>Higher team strength and bullpen factors = better performance expected</em>
                        </div>
                    </div>
                    
                    <!-- Team Form (Last 10) -->
                    <div style="margin-top: 20px;">
                        <h3>üèÅ Team Form (Last 10)</h3>
                        ${data.team_form && (data.team_form.away || data.team_form.home) ? `
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 10px;">
                            <div style="padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid #ff6b6b;">
                                <div style="font-weight: bold; color: #ff6b6b; margin-bottom: 6px;">${awayTeam}</div>
                                ${data.team_form.away ? `
                                <div style="font-size: 0.9em; color: #ccc;">Record: ${data.team_form.away.wins}-${data.team_form.away.losses}</div>
                                <div style="font-size: 0.9em; color: #ccc;">Avg Runs: ${data.team_form.away.avg_runs_for ?? '‚Äî'} for, ${data.team_form.away.avg_runs_against ?? '‚Äî'} against</div>
                                <div style="font-size: 0.85em; color: #aaa; margin-top: 4px;">Trend: ${data.team_form.away.last10_trend || ''}</div>
                                ` : `<div style=\"font-size: 0.9em; color: #888; font-style: italic;\">No recent data</div>`}
                            </div>
                            <div style="padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid #4ecdc4;">
                                <div style="font-weight: bold; color: #4ecdc4; margin-bottom: 6px;">${homeTeam}</div>
                                ${data.team_form.home ? `
                                <div style="font-size: 0.9em; color: #ccc;">Record: ${data.team_form.home.wins}-${data.team_form.home.losses}</div>
                                <div style="font-size: 0.9em; color: #ccc;">Avg Runs: ${data.team_form.home.avg_runs_for ?? '‚Äî'} for, ${data.team_form.home.avg_runs_against ?? '‚Äî'} against</div>
                                <div style="font-size: 0.85em; color: #aaa; margin-top: 4px;">Trend: ${data.team_form.home.last10_trend || ''}</div>
                                ` : `<div style=\"font-size: 0.9em; color: #888; font-style: italic;\">No recent data</div>`}
                            </div>
                        </div>
                        ` : `<div style=\"font-size: 0.9em; color: #888; font-style: italic;\">Recent results not available</div>`}
                    </div>
                    
                    <!-- Head-to-Head -->
                    <div style="margin-top: 20px;">
                        <h3>ü§ù Head-to-Head</h3>
                        ${data.head_to_head ? `
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-top: 10px;">
                            <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                                <div style="font-weight: bold; margin-bottom: 5px;">Games</div>
                                <div>${data.head_to_head.games}</div>
                            </div>
                            <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                                <div style="font-weight: bold; margin-bottom: 5px;">Wins</div>
                                <div style="color: #ff6b6b;">${awayTeam}: ${data.head_to_head.away_wins}</div>
                                <div style="color: #4ecdc4;">${homeTeam}: ${data.head_to_head.home_wins}</div>
                            </div>
                            <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                                <div style="font-weight: bold; margin-bottom: 5px;">Avg Runs</div>
                                <div style="color: #ff6b6b;">${awayTeam}: ${data.head_to_head.away_avg_runs ?? '‚Äî'}</div>
                                <div style="color: #4ecdc4;">${homeTeam}: ${data.head_to_head.home_avg_runs ?? '‚Äî'}</div>
                            </div>
                        </div>
                        ` : `<div style=\"font-size: 0.9em; color: #888; font-style: italic;\">No recent head-to-head data</div>`}
                    </div>
            `;
            
            // Add betting lines section if available
            const bettingData = prediction.betting_data || prediction.closing_lines;
            if (bettingData) {
                const moneyline = bettingData.moneyline || {};
                const total = bettingData.total || {};
                const spread = bettingData.spread || {};
                
                html += `
                    <div style="margin-top: 20px;">
                        <h3>Betting Lines</h3>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-top: 10px;">
                            <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                                <div style="font-weight: bold; margin-bottom: 5px;">Moneyline</div>
                                <div style="font-size: 0.9rem;">
                                    <div style="color: #ff6b6b;">${awayTeam}: ${moneyline.away || 'N/A'}</div>
                                    <div style="color: #4ecdc4;">${homeTeam}: ${moneyline.home || 'N/A'}</div>
                                </div>
                            </div>
                            <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                                <div style="font-weight: bold; margin-bottom: 5px;">Total</div>
                                <div style="font-size: 0.9rem;">
                                    ${total.line ? `O/U ${total.line}` : 'N/A'}<br>
                                    ${total.over && total.under ? `${total.over}/${total.under}` : ''}
                                </div>
                            </div>
                            <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                                <div style="font-weight: bold; margin-bottom: 5px;">Spread</div>
                                <div style="font-size: 0.9rem;">
                                    ${spread.line ? `${spread.line > 0 ? '+' : ''}${spread.line}` : 'N/A'}<br>
                                    ${spread.away && spread.home ? `${spread.away}/${spread.home}` : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Add enhanced betting recommendations section
            const bettingRecs = data.betting_recommendations;  // Get from top level of data object
            if (bettingRecs && (bettingRecs.value_bets || bettingRecs.summary)) {
                html += '<div style="margin-top: 20px;"><h3>üí∞ Betting Recommendations</h3>';
                
                // Add summary if available
                if (bettingRecs.summary) {
                    html += `<div style="margin-bottom: 15px; padding: 10px; background: rgba(79, 209, 199, 0.1); border-radius: 6px; color: #4fd1c7; font-weight: bold;">${bettingRecs.summary}</div>`;
                }
                
                // Show value bets in enhanced format
                if (bettingRecs.value_bets && bettingRecs.value_bets.length > 0) {
                    bettingRecs.value_bets.forEach(bet => {
                        const confidenceColor = bet.confidence === 'HIGH' ? '#ff6b6b' : 
                                               bet.confidence === 'MEDIUM' ? '#ffa726' : '#66bb6a';
                        const icon = bet.edge_rating || (bet.confidence === 'HIGH' ? 'üî•' : 
                                   bet.confidence === 'MEDIUM' ? '‚ö°' : 'üí°');
                        
                        // Format Expected Value for modal - LIMITED TO 2 DECIMAL PLACES MAX
                        let evModalDisplay = '';
                        if (bet.expected_value !== undefined && bet.expected_value !== null) {
                            const evPercent = (bet.expected_value * 100).toFixed(2);
                            const evColor = bet.expected_value > 0 ? '#4fd1c7' : '#ff6b6b';
                            const evSign = bet.expected_value > 0 ? '+' : '';
                            evModalDisplay = `<div style="color: ${evColor}; font-weight: bold; font-size: 0.95em;">EV: ${evSign}${evPercent}%</div>`;
                        }
                        
                        html += `
                            <div style="margin: 12px 0; padding: 15px; background: rgba(255,255,255,0.08); border-left: 4px solid ${confidenceColor}; border-radius: 8px;">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                                    <strong style="color: ${confidenceColor}; font-size: 1.1em;">${icon} ${bet.recommendation || bet.bet}</strong>
                                    <div style="text-align: right; font-size: 0.9em;">
                                        <div style="color: #4fd1c7; font-weight: bold;">${typeof bet.edge === 'number' ? bet.edge.toFixed(2) + '% edge' : bet.edge ? bet.edge : bet.confidence ? bet.confidence + ' CONFIDENCE' : 'Value Bet'}</div>
                                        ${evModalDisplay}
                                        ${bet.estimated_odds && bet.estimated_odds !== 'N/A' ? `<div style="color: #888;">${bet.estimated_odds}</div>` : ''}
                                    </div>
                                </div>
                                <div style="font-size: 0.9em; color: #ccc; line-height: 1.3;">${bet.reasoning}</div>
                                <div style="margin-top: 8px; font-size: 0.8em; color: #888;">
                                    <span style="background: rgba(${bet.confidence === 'HIGH' ? '255, 107, 107' : bet.confidence === 'MEDIUM' ? '255, 167, 38' : '102, 187, 106'}, 0.3); padding: 2px 6px; border-radius: 4px;">${bet.confidence} CONFIDENCE</span>
                                    <span style="margin-left: 10px;">${bet.type}</span>
                                </div>
                            </div>
                        `;
                    });
                    
                    // Highlight best bet if available
                    if (bettingRecs.best_bet) {
                        html += `
                            <div style="margin-top: 15px; padding: 12px; background: rgba(79, 209, 199, 0.2); border: 2px solid #4fd1c7; border-radius: 8px;">
                                <strong style="color: #4fd1c7;">üéØ Recommended Best Bet:</strong> ${bettingRecs.best_bet.recommendation || bettingRecs.best_bet.bet}
                            </div>
                        `;
                    }
                } else {
                    html += '<div style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px; font-style: italic; opacity: 0.8; text-align: center;">üí° No strong value bets identified - consider live betting opportunities</div>';
                }
                
                html += '</div>';
            }

            // EV/Kelly breakdown section
            if (data.ev_kelly && data.ev_kelly.bets && data.ev_kelly.bets.length > 0) {
                html += `
                <div style="margin-top: 20px;">
                    <h3>üìê EV & Kelly Breakdown</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; margin-top: 10px;">
                        ${data.ev_kelly.bets.map(b => `
                            <div style=\"padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid ${b.expected_value > 0 ? '#4fd1c7' : '#ff6b6b'};\">
                                <div style=\"font-weight: 600; margin-bottom: 4px;\">${b.label}</div>
                                <div style=\"font-size: 0.9em; color: #ccc;\">${b.estimated_odds ? `Odds: ${b.estimated_odds}` : ''}</div>
                                <div style=\"margin-top: 4px; font-size: 0.9em;\">EV: ${b.expected_value != null ? ((b.expected_value * 100).toFixed(2) + '%') : '‚Äî'}</div>
                                <div style=\"font-size: 0.9em;\">Kelly: ${(b.kelly_fraction * 100).toFixed(2)}%</div>
                                <div style=\"font-size: 0.9em; color: #aaa;\">Suggested Stake: $${b.suggested_stake}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>`;
            }
            
            if (recs.length > 0) {
                // Legacy recommendations format - now using enhanced betting recommendations above
                console.log('Legacy recommendations found but using enhanced format instead');
            }
            
            html += `
                <div style="margin-top: 20px; font-size: 0.9rem; opacity: 0.8;">
                    ${meta.execution_time_ms > 0 ? `Execution Time: ${meta.execution_time_ms.toFixed(2)}ms | ` : ''}
                    Simulations: ${(meta.simulations_run || 5000).toLocaleString()} |
                    Data Source: ${meta.data_source || 'comprehensive_engine'}
                </div>
            `;
            
            document.getElementById('modal-body').innerHTML = html;
        }

    // Pitcher props SSE/unified logic removed from main page (now in /pitcher-props)
    </script>
    
    
    <!-- Monitoring Widget -->
    <script src="{{ url_for('static', filename='js/monitoring-widget.js') }}"></script>
</body>
</html>
