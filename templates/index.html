<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>MLB-Betting Prediction System</title>
    <meta name="theme-color" content="#0b1e2a">
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; background: #0b1e2a; color: #e5e7eb; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; margin-bottom: 30px; }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        /* Removed summary stat cards per request */

        .clickable-stat:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.15);
            border-color: #4fd1c7;
            box-shadow: 0 10px 25px rgba(79, 209, 199, 0.3);
        }

        .clickable-stat:hover h3 {
            color: #5ce1e6;
            text-shadow: 0 0 10px rgba(92, 225, 230, 0.5);
        }

    .stat-card p { opacity: 0.8; }

    .games-section { margin-top: 30px; }

        .games-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .date-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

    .date-selector input { padding: 8px 12px; border: none; border-radius: 8px; background: rgba(255, 255, 255, 0.9); color: #333; }

    .btn { padding: 8px 16px; border: none; border-radius: 8px; background: #4fd1c7; color: white; cursor: pointer; font-weight: bold; transition: background 0.3s; }

        .btn:hover {
            background: #45b7b8;
        }

    .btn-small { padding: 4px 8px; border: none; border-radius: 4px; background: #4fd1c7; color: white; cursor: pointer; font-size: 0.8rem; font-weight: bold; transition: background 0.3s; }

        .btn-small:hover {
            background: #45b7b8;
        }

    .games-grid { display: grid; gap: 15px; }
    @media (max-width: 640px) {
        .container { padding: 12px; }
        .games-grid { grid-template-columns: 1fr; }
        .card-body { grid-template-columns: 1fr; }
        .game-teams { font-size: 1rem; }
        .team-logo { width: 28px; height: 28px; }
    }

        .game-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
            overflow: hidden;
        }

        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        .game-header {
            /* Compact full-width header: Away | status/score | Home */
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .header-left { justify-self: start; }
        .header-center { justify-self: center; text-align: center; }
        .header-right { justify-self: end; }

        .starting-pitchers {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .pitcher-matchup {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .away-pitcher, .home-pitcher {
            flex: 1;
            text-align: center;
        }

        .pitcher-label {
            display: block;
            font-size: 0.8rem;
            opacity: 0.7;
            margin-bottom: 2px;
        }

        .pitcher-name {
            display: block;
            font-weight: bold;
            color: #4fd1c7;
        }

    /* Pitch count widget */
    .pitch-metrics { margin-top: 4px; font-size: 0.75rem; opacity: 0.9; }
    .pitch-metrics .proj { color: #9cd9d3; }
    .pitch-metrics .live { color: #ffd166; }
    .pitch-metrics .ppo { color: #aaa; font-size: 0.7rem; }

    /* Compact props tracker */
    .prop-tracker { margin-top: 4px; font-size: 0.76rem; display: inline-flex; align-items: center; gap: 6px; padding: 4px 6px; border-radius: 6px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); color:#fff; }
    .prop-tracker .label { font-size: 0.72rem; color:#fff; opacity:1; }
    .prop-tracker .market { font-weight: 700; letter-spacing: 0.2px; color:#fff; }
    .prop-tracker .line { color:#fff; opacity:1; }
    .prop-tracker .progress { font-weight: 700; color:#fff; }
    .prop-tracker .proj { color:#fff; opacity:1; }
    
        /* Edge strength styling for unified prop trackers (boxed colors) */
        .prop-tracker.edge-strong { box-shadow: 0 0 0 2px #22c55e inset; }
        .prop-tracker.edge-medium { box-shadow: 0 0 0 2px #f59e0b inset; }
        .prop-tracker.edge-small { box-shadow: 0 0 0 2px #3b82f6 inset; }
    /* Keep text white regardless of state */
    .prop-tracker.over.pending,
    .prop-tracker.over.crossed,
    .prop-tracker.under.pending,
    .prop-tracker.under.crossed { color:#fff; border-color: rgba(255,255,255,0.12); }
    .prop-tracker .hit-badge { background: #22c55e; color: #0b1c12; padding: 1px 6px; border-radius: 10px; font-size: 0.68rem; font-weight: 800; margin-left: 2px; }
    .prop-tracker .miss-badge { background: #ef4444; color: #1a0b0b; padding: 1px 6px; border-radius: 10px; font-size: 0.68rem; font-weight: 800; margin-left: 2px; }
    .prop-tracker .push-badge { background: #9ca3af; color: #0f172a; padding: 1px 6px; border-radius: 10px; font-size: 0.68rem; font-weight: 800; margin-left: 2px; }
    .prop-trackers { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 4px; }
    /* Live value + tiny progress bar for readability */
    .prop-tracker .live { font-weight: 700; font-size: 0.75rem; opacity: 0.95; color:#fff; }
    /* Removed the right-side progress bar to save space */

        /* At-bat count chip (balls-strikes) */
        .count-chip {
            display: inline-block;
            margin-left: 6px;
            padding: 2px 6px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.18);
            font-size: 0.72rem;
            color: #fff;
        }

    /* Live at-bat widget */
    .live-atbat { display: inline-flex; align-items: center; gap: 10px; margin-top: 4px; }
    .half-inning { font-size: 0.78rem; opacity: 0.9; color: #fff; white-space: nowrap; }
    .bases-diamond { display: grid; grid-template-columns: repeat(3, 8px); grid-template-rows: repeat(3, 8px); gap: 3px; width: 30px; height: 30px; align-items: center; justify-items: center; }
    .base-dot { width: 8px; height: 8px; border-radius: 2px; transform: rotate(45deg); border: 1px solid rgba(255,255,255,0.3); background: transparent; }
    .base-dot.on { background: #22c55e; border-color: #22c55e; }
    .b1 { grid-row: 2; grid-column: 3; }
    .b2 { grid-row: 1; grid-column: 2; }
    .b3 { grid-row: 2; grid-column: 1; }
    .outs { display: inline-flex; align-items: center; gap: 4px; }
    .out-dot { width: 8px; height: 8px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.3); background: transparent; }
    .out-dot.on { background: #ef4444; border-color: #ef4444; }

        .pitcher-matchup .vs-separator {
            font-size: 0.8rem;
            opacity: 0.5;
            margin: 0 5px;
        }

        .game-teams {
            font-size: 1.2rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .team-info {
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .team-info:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .team-logo {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }

        .team-name {
            font-weight: bold;
        }

        .vs-separator {
            font-size: 0.9rem;
            opacity: 0.7;
            margin: 0 5px;
        }

        .game-time {
            opacity: 0.7;
            font-size: 0.9rem;
        }

        .prediction-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        /* Two-column interior body for game card */
        .card-body {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .card-section { background: rgba(255,255,255,0.05); border-radius: 8px; padding: 10px; }
        .card-section.transparent { background: transparent; padding: 0; }

        .betting-lines {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .betting-lines h4 {
            margin-bottom: 12px;
            font-size: 0.9rem;
            color: #ff6600;  /* DraftKings orange color */
            text-align: center;
            font-weight: bold;
        }

        .betting-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        .betting-item {
            text-align: center;
            padding: 10px 8px;
            background: rgba(79, 209, 199, 0.08);
            border-radius: 8px;
            border: 1px solid rgba(79, 209, 199, 0.2);
            transition: all 0.2s ease;
        }

        .betting-item:hover {
            background: rgba(79, 209, 199, 0.12);
            border-color: rgba(79, 209, 199, 0.3);
        }

        .betting-item .line-label {
            font-size: 0.72rem;
            opacity: 0.9;
            margin-bottom: 4px;
            color: #4fd1c7;
            font-weight: 600;
        }

        .betting-item .line-value {
            font-size: 0.8rem;
            font-weight: bold;
            line-height: 1.3;
        }

        .moneyline-away, .moneyline-home {
            font-size: 0.75rem;
            margin: 1px 0;
            font-weight: 600;
        }

        .moneyline-away {
            color: #ff8a80;
        }

        .moneyline-home {
            color: #81c784;
        }

        .betting-recommendations {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid #4fd1c7;
        }

        .betting-recommendations h4 {
            margin: 0 0 12px 0;
            color: #4fd1c7;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .value-bet {
            margin: 8px 0;
            padding: 12px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.08);
            border-left: 3px solid transparent;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .value-bet:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-1px);
        }

        .value-bet.high-confidence {
            border-left-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.15);
        }

        .value-bet.medium-confidence {
            border-left-color: #ffa726;
            background: rgba(255, 167, 38, 0.15);
        }

        .value-bet.low-confidence {
            border-left-color: #66bb6a;
            background: rgba(102, 187, 106, 0.15);
        }

        .best-bet {
            margin: 8px 0;
            padding: 12px;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .no-value {
            font-style: italic;
            opacity: 0.7;
            text-align: center;
            padding: 10px;
            color: #888;
        }

        .value-bet.low-confidence {
            border-left-color: #66bb6a;
            background: rgba(102, 187, 106, 0.15);
        }

        .value-bet.positive-ev {
            border-left-color: #4fd1c7;
            background: rgba(79, 209, 199, 0.2);
            box-shadow: 0 0 8px rgba(79, 209, 199, 0.3);
        }

        .positive-ev-badge {
            background: linear-gradient(45deg, #4fd1c7, #00d4aa);
            color: white;
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: bold;
            margin-left: 5px;
        }

        .no-value-bet {
            padding: 10px;
            text-align: center;
            color: #888;
            font-style: italic;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .edge-indicator {
            font-weight: bold;
            margin-left: 4px;
        }

        .game-status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
            margin-left: 8px;
        }

        .badge-scheduled {
            background: rgba(108, 117, 125, 0.2);
            color: #6c757d;
            border: 1px solid rgba(108, 117, 125, 0.3);
        }

        .badge-live {
            background: rgba(220, 53, 69, 0.2);
            color: #dc3545;
            border: 1px solid rgba(220, 53, 69, 0.4);
            animation: pulse 2s infinite;
        }

        .badge-final {
            background: rgba(40, 167, 69, 0.2);
            color: #28a745;
            border: 1px solid rgba(40, 167, 69, 0.4);
        }

        .badge-delayed {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.4);
        }

        .badge-unknown {
            background: rgba(255, 255, 255, 0.1);
            color: #adb5bd;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .game-time {
            font-size: 0.85rem;
            opacity: 0.8;
            margin-top: 4px;
        }

        .live-score {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            padding: 8px;
            background: rgba(220, 53, 69, 0.1);
            border-radius: 6px;
            border-left: 3px solid #dc3545;
        }

        .live-score .team-score {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .final-analysis {
            margin-top: 10px;
            padding: 10px;
            background: rgba(40, 167, 69, 0.1);
            border-radius: 8px;
            border-left: 3px solid #28a745;
        }

        .final-analysis h5 {
            color: #28a745;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .analysis-item {
            margin: 4px 0;
            font-size: 0.8rem;
            padding: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .analysis-correct {
            color: #28a745;
        }

        .analysis-incorrect {
            color: #dc3545;
        }

        .betting-comparison {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .betting-comparison h6 {
            margin: 5px 0 8px 0;
            font-size: 0.9rem;
            color: #ffd700;
        }

        .betting-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .section-title {
            color: #4fd1c7;
            font-size: 1.2rem;
            margin: 20px 0 15px 0;
            padding: 10px 15px;
            background: rgba(79, 209, 199, 0.1);
            border-left: 4px solid #4fd1c7;
            border-radius: 5px;
        }

        .btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn.secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .prediction-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .prediction-item .value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #4fd1c7;
        }

        .prediction-item .label {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2rem;
        }

        .error {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid rgba(255, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: white;
            cursor: pointer;
        }

        .recommendations {
            margin-top: 20px;
        }

        .recommendation {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .recommendation.high-confidence {
            border-left: 4px solid #4fd1c7;
        }

        .recommendation.medium-confidence {
            border-left: 4px solid #f39c12;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .games-header {
                flex-direction: column;
                gap: 15px;
            }
        }

    /* highlight updated line */
    .prop-tracker .line-updated { animation: flashLine 2s ease-in-out; }
    @keyframes flashLine { 0%{background:rgba(255,230,150,0.9);} 50%{background:rgba(255,230,150,0.2);} 100%{background:transparent;} }
    /* edge coloring */
    .edge { margin-left:4px; font-weight:600; }
    /* Keep chip text white even when edge classes are present */
    .prop-tracker.edge-strong, .prop-tracker.edge-medium, .prop-tracker.edge-small { color:#fff; }
    .odds { margin-left:6px; font-size:11px; color:#fff; opacity:0.85; font-weight:500; }
    </style>
    <link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="48" fill="white" stroke="black" stroke-width="4"/><path d="M20,30 C40,50 60,50 80,30" stroke="red" stroke-width="4" fill="none"/><path d="M20,70 C40,50 60,50 80,70" stroke="red" stroke-width="4" fill="none"/></svg>' />
</head>
<body>
        <!-- Health banner for props feed -->
        <div id="propsHealthBanner" style="display:none; position:fixed; bottom:16px; right:16px; z-index:9999; background:#fff7e6; color:#663c00; border:1px solid #ffe8bf; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.12); padding:10px 12px; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial;">
            <span style="font-weight:600;">Pitcher props feed is stale</span>
            <span id="propsHealthMsg" style="margin-left:6px;">Showing last-known lines; live updates may be delayed.</span>
        </div>
        <!-- SSE status indicator -->
        <div id="sseStatusDot" title="Props stream status" style="position:fixed; bottom:16px; left:16px; width:10px; height:10px; border-radius:50%; background:#bbb; box-shadow:0 0 0 2px #fff, 0 0 0 3px rgba(0,0,0,0.1); z-index:9999;"></div>
    <div class="container">
        <div class="header">
            <h1>⚾ MLB-Betting</h1>
            <p>Advanced MLB Prediction System with Real-Time Betting Analysis</p>
            <p style="font-size: 0.9rem; opacity: 0.8; margin-top: 5px;">
                📊 Comprehensive Analysis Since August 7th • Updated Daily • {{ comprehensive_stats.total_games_analyzed or 0 }} Games Tracked
            </p>
            
            <!-- Admin Navigation -->
            <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                <a href="/admin" style="display: inline-block; padding: 8px 16px; background: rgba(255, 215, 0, 0.2); color: #FFD700; text-decoration: none; border-radius: 8px; border: 1px solid #FFD700; font-size: 0.9rem; font-weight: bold; transition: all 0.3s ease;" 
                   onmouseover="this.style.background='rgba(255, 215, 0, 0.3)'; this.style.transform='translateY(-2px)'" 
                   onmouseout="this.style.background='rgba(255, 215, 0, 0.2)'; this.style.transform='translateY(0)'">
                    🎯 Tuning Dashboard
                </a>
                <button id="run-automation-btn" onclick="runDailyAutomation()" style="padding: 8px 16px; background: rgba(79, 209, 199, 0.2); color: #4fd1c7; border: 1px solid #4fd1c7; border-radius: 8px; font-size: 0.9rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease;" 
                        onmouseover="this.style.background='rgba(79, 209, 199, 0.3)'; this.style.transform='translateY(-2px)'" 
                        onmouseout="this.style.background='rgba(79, 209, 199, 0.2)'; this.style.transform='translateY(0)'">
                    🚀 Run Daily Update
                </button>
                <button id="refresh-stats-btn" onclick="refreshDashboardStats()" style="padding: 8px 16px; background: rgba(156, 163, 175, 0.2); color: #9ca3af; border: 1px solid #9ca3af; border-radius: 8px; font-size: 0.9rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease; margin-left: 8px;" 
                        onmouseover="this.style.background='rgba(156, 163, 175, 0.3)'; this.style.transform='translateY(-2px)'" 
                        onmouseout="this.style.background='rgba(156, 163, 175, 0.2)'; this.style.transform='translateY(0)'">
                    📊 Refresh Stats
                </button>
                <button id="init-system-btn" onclick="initializeSystem()" style="padding: 8px 16px; background: rgba(34, 197, 94, 0.2); color: #22c55e; border: 1px solid #22c55e; border-radius: 8px; font-size: 0.9rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease; margin-left: 8px;" 
                        onmouseover="this.style.background='rgba(34, 197, 94, 0.3)'; this.style.transform='translateY(-2px)'" 
                        onmouseout="this.style.background='rgba(34, 197, 94, 0.2)'; this.style.transform='translateY(0)'">
                    ⚡ Load Real MLB Data
                </button>
                <!-- Compact TBD Monitor button -->
                <button id="tbd-monitor-btn" onclick="checkTBD()" title="Check TBD pitchers" style="padding: 8px 12px; background: rgba(156,163,175,0.15); color: #e5e7eb; border: 1px solid rgba(156,163,175,0.35); border-radius: 8px; font-size: 0.86rem; font-weight: 700; cursor: pointer; transition: all 0.2s ease; display: inline-flex; align-items: center; gap: 8px;">
                    🕵️ TBD Monitor <span id="tbd-badge" style="display:inline-block; min-width:18px; padding:0 6px; height:18px; line-height:18px; border-radius: 9px; background: rgba(31,41,55,0.6); color:#fff; font-size: 0.72rem; text-align:center;">0</span>
                </button>
            </div>
        </div>

        <!-- Summary stat cards removed per request -->

        <div class="games-section">
            <div class="games-header">
                <h2>Today's MLB Games</h2>
                <div class="date-selector">
                    <input type="date" id="game-date" style="display: none;" />
                    <button class="btn" onclick="loadToday()">Refresh</button>
                    <button class="btn secondary" onclick="refreshBettingLines()" id="refresh-betting-lines-btn">💰 Update Betting Lines</button>
                    <button class="btn secondary" onclick="goToHistoricalAnalysis()">📊 Historical Analysis</button>
                    <button class="btn secondary" onclick="goToBettingGuidance()">🎯 Betting Guidance</button>
                </div>
            </div>

            <!-- Live Games Section -->
            <div id="live-games-section" style="display: none;">
                <h3 class="section-title">🔴 Live Games</h3>
                <div id="live-games-container" class="games-grid"></div>
            </div>

            <!-- Upcoming Games Section -->
            <div id="upcoming-games-section" style="display: none;">
                <h3 class="section-title">⏰ Upcoming Games</h3>
                <div id="upcoming-games-container" class="games-grid"></div>
            </div>

            <div id="games-container">
                <div class="loading">Loading today's games...</div>
            </div>

            <!-- Completed Games Section - Moved to bottom -->
            <div id="completed-games-section" style="display: none; margin-top: 30px;">
                <h3 class="section-title">✅ Completed Games</h3>
                <div id="completed-games-container" class="games-grid"></div>
            </div>
        </div>
    </div>

     <!-- Pitcher Props Sidebar & Toggle -->
     <div id="pitcher-sidebar" style="position:fixed;top:0;right:0;width:340px;height:100%;background:rgba(10,25,40,0.96);border-left:1px solid rgba(255,255,255,0.15);overflow:auto;padding:14px;font-size:12px;line-height:1.25;display:none;z-index:9999;">
         <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
            <h3 style="font-size:14px;margin:0;color:#4fd1c7;">Pitcher Props Live</h3>
            <button id="closePitcherSidebar" style="background:#4fd1c7;border:none;color:#012;padding:4px 8px;border-radius:4px;font-size:11px;cursor:pointer;">×</button>
         </div>
         <div style="margin-bottom:6px;display:flex;gap:6px;">
             <input id="pitcherFilter" placeholder="filter" style="flex:1;padding:4px 6px;border-radius:4px;border:1px solid #244;background:#0d273b;color:#fff;font-size:11px;" />
             <select id="marketFilter" style="padding:4px 6px;border-radius:4px;border:1px solid #244;background:#0d273b;color:#fff;font-size:11px;">
                 <option value="">All</option>
                 <option value="strikeouts">K</option>
                 <option value="outs">Outs</option>
                 <option value="hits_allowed">Hits</option>
                 <option value="walks">BB</option>
                 <option value="earned_runs">ER</option>
             </select>
         </div>
         <div id="pitcherSidebarContent"></div>
     </div>
     <button id="togglePitcherSidebar" style="position:fixed;right:10px;bottom:10px;background:#4fd1c7;color:#042;border:none;border-radius:20px;padding:10px 14px;font-weight:600;cursor:pointer;font-size:12px;z-index:9999;">Pitcher Props</button>

    <!-- Prediction Modal -->
    <div id="prediction-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">Game Prediction</h2>
                <button class="close-btn" onclick="closeModal()">&times;</button>
            </div>
            <div id="modal-body">
                Loading prediction...
            </div>
        </div>
    </div>

    <script>
        // --- Lightweight Performance Instrumentation (dev-friendly) ---
        (function initPerf(){
            try {
                if (window.__PERF) return; // idempotent
                window.__PERF = {
                    t0: performance.now(),
                    marks: {},
                    data: {}
                };
                window.__PERF.mark = function(name){ this.marks[name] = performance.now(); };
                document.addEventListener('DOMContentLoaded', ()=>{ try { window.__PERF.mark('domContentLoaded'); } catch(_){} });

                // Optional tiny badge for quick visual check; hidden by default
                const badge = document.createElement('div');
                badge.id = 'perfBadge';
                badge.style.cssText = 'display:none;position:fixed;top:10px;right:10px;background:rgba(0,0,0,0.7);color:#fff;padding:6px 8px;border-radius:6px;font:12px system-ui;z-index:9999;box-shadow:0 2px 8px rgba(0,0,0,0.2);';
                badge.title = 'Performance summary (press Ctrl+Alt+P to toggle)';
                badge.textContent = 'Loading…';
                document.addEventListener('keydown', (e)=>{
                    try {
                        if ((e.ctrlKey || e.metaKey) && e.altKey && (e.key.toLowerCase() === 'p')){
                            const vis = badge.style.display !== 'none';
                            badge.style.display = vis ? 'none' : 'block';
                        }
                    } catch(_){ }
                });
                document.body.appendChild(badge);

                window.__PERF.updateBadge = function(summary){
                    try {
                        const el = document.getElementById('perfBadge');
                        if (!el) return;
                        const s = summary || this.data.summary;
                        if (!s) return;
                        el.textContent = `Load ${s.total.toFixed(1)}ms • fetch ${s.fetch.toFixed(1)} • render ${s.render.toFixed(1)}${s.props ? ` • props ${s.props.toFixed(1)}`:''}`;
                    } catch(_){ }
                };
            } catch(_){ }
        })();
        // Small fetch helper with timeout and cache-busting
        async function fetchWithTimeout(url, options = {}, timeoutMs = 10000) {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeoutMs);
            try {
                const bust = url.includes('?') ? `&_=${Date.now()}` : `?_=${Date.now()}`;
                const res = await fetch(url + bust, { ...options, signal: controller.signal });
                return res;
            } finally {
                clearTimeout(id);
            }
        }
        // Modal helpers: open/close with backdrop and Escape support
        function openModal() {
            const modal = document.getElementById('prediction-modal');
            if (!modal) return;
            modal.style.display = 'block';
            try { document.body.style.overflow = 'hidden'; } catch(_){}
        }
        function closeModal() {
            const modal = document.getElementById('prediction-modal');
            if (!modal) return;
            modal.style.display = 'none';
            try { document.body.style.overflow = ''; } catch(_){}
        }
        // Attach one-time listeners for backdrop click and Escape key
        (function attachModalHandlers(){
            if (window.__MODAL_HANDLERS_ATTACHED__) return;
            window.__MODAL_HANDLERS_ATTACHED__ = true;
            document.addEventListener('DOMContentLoaded', function(){
                const modal = document.getElementById('prediction-modal');
                if (!modal) return;
                // Close when clicking backdrop (but not when clicking content)
                modal.addEventListener('click', function(e){ if (e.target === modal) closeModal(); });
                // Close on Escape
                document.addEventListener('keydown', function(e){ if (e.key === 'Escape') closeModal(); });
            });
        })();
    // Cache of last-known live stats keyed by game compositeId and side (away/home)
    window.__LAST_LIVE_STATS = window.__LAST_LIVE_STATS || {};

        // Shared name normalizer: lowercases, strips diacritics, removes non-alphanumerics
        function normName(s) {
            return String(s || '')
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, ' ')
                .trim();
        }
        // Parse "HH:MM AM/PM ET" to a CT display string. If parsing fails, return original string.
        function etToCtDisplay(timeStr) {
            try {
                if (!timeStr) return '';
                const m = String(timeStr).trim().match(/^(\d{1,2}):(\d{2})\s*(AM|PM)\s*(ET)?$/i);
                if (!m) return String(timeStr).trim();
                let h = parseInt(m[1], 10);
                const min = parseInt(m[2], 10);
                const ampm = m[3].toUpperCase();
                if (ampm === 'PM' && h !== 12) h += 12;
                if (ampm === 'AM' && h === 12) h = 0;
                // ET -> CT is -1 hour (handles DST uniformly since both shift together)
                h = (h + 24 - 1) % 24;
                const h12 = ((h + 11) % 12) + 1;
                const ampmOut = h < 12 ? 'AM' : 'PM';
                return `${h12}:${String(min).padStart(2, '0')} ${ampmOut} CT`;
            } catch (_) {
                return String(timeStr).trim();
            }
        }
        // Extract minutes since midnight for a "HH:MM AM/PM" string, assuming ET; returns null if unparseable
        function meridianToMinutesET(timeStr) {
            try {
                const m = String(timeStr || '').match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
                if (!m) return null;
                let h = parseInt(m[1], 10);
                const min = parseInt(m[2], 10);
                const ampm = m[3].toUpperCase();
                if (ampm === 'PM' && h !== 12) h += 12;
                if (ampm === 'AM' && h === 12) h = 0;
                return h * 60 + min; // ET minutes
            } catch (_) { return null; }
        }
        // Build a numeric sort key for a game time, preferring ISO timestamps; fallback to ET minutes for meridian strings
        function gameSortKey(game) {
            try {
                const gt = game?.game_time || '';
                if (gt && (gt.includes('T') || gt.includes('Z'))) {
                    const ts = Date.parse(gt);
                    if (!Number.isNaN(ts)) return ts;
                }
                const tStr = (game?.live_status?.game_time) || gt || '';
                const minsET = meridianToMinutesET(tStr);
                if (minsET != null) return minsET * 60000; // scale to ms for consistency
            } catch (_) {}
            return Number.MAX_SAFE_INTEGER; // push unknowns to end
        }
        // Get user's local date, not UTC date
        let currentDate = new Date();
        let localDateString = currentDate.getFullYear() + '-' + 
                              String(currentDate.getMonth() + 1).padStart(2, '0') + '-' + 
                              String(currentDate.getDate()).padStart(2, '0');
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('game-date').value = localDateString;
            loadSummary();
            loadTodaysGames();
            
            // Start live updates for games in progress
            startLiveUpdates();
            
            // Initialize TBD monitoring
            updateTBDStatus();
            
            // Initialize live dashboard stats
            loadLiveDashboardStats();
            
            // Update TBD status every 5 minutes
            setInterval(updateTBDStatus, 300000);
            
            // Update dashboard stats every 2 minutes
            setInterval(loadLiveDashboardStats, 120000);
        });

        // 🔥 LIVE DASHBOARD STATS WIDGET
        async function loadLiveDashboardStats() {
            try {
                console.log('🔄 Loading live dashboard stats from historical analysis API...');
                
                const response = await fetch('/api/historical-analysis/cumulative');
                if (!response.ok) {
                    console.warn('❌ Historical analysis API not available, keeping server-side stats');
                    return;
                }
                
                const apiData = await response.json();
                if (!apiData.success || !apiData.data) {
                    console.warn('❌ Historical analysis API returned error:', apiData.message);
                    return;
                }
                
                const data = apiData.data;
                const betting = data.betting_performance || {};
                const analysis = data.analysis_period || '2025-08-15 to 2025-08-25';
                
                console.log('✅ Live dashboard data loaded:', {
                    totalRecommendations: betting.total_recommendations,
                    accuracy: betting.overall_accuracy,
                    roi: betting.roi_percentage
                });
                
                // Update the dashboard stats with live data
                updateDashboardStat(0, {
                    value: betting.total_recommendations || 0,
                    subtitle: `Since ${analysis.split(' to ')[0]} (${data.total_dates_analyzed || 0} days)`
                });
                
                updateDashboardStat(1, {
                    value: `${(betting.overall_accuracy || 0).toFixed(2)}%`,
                    subtitle: `${betting.correct_recommendations || 0}/${betting.total_recommendations || 0} correct predictions`
                });
                
                updateDashboardStat(2, {
                    value: `$${(betting.net_profit || 0).toFixed(2)}`,
                    subtitle: `${(betting.roi_percentage || 0).toFixed(2)}% ROI on ${betting.total_recommendations || 0} bets`
                });
                
                updateDashboardStat(3, {
                    value: `${(betting.overall_accuracy || 0).toFixed(2)}%`,
                    subtitle: `${betting.correct_recommendations || 0} winning bets of ${betting.total_recommendations || 0} placed`
                });
                
                // Add visual indicator that data is live
                const header = document.querySelector('.header p');
                if (header && !header.textContent.includes('🔴 LIVE')) {
                    header.innerHTML = header.innerHTML.replace('📊 Comprehensive Analysis', '🔴 LIVE Analysis');
                }
                
                console.log('✅ Dashboard stats updated with live data');
                
            } catch (error) {
                console.warn('⚠️ Could not load live dashboard stats:', error);
                // Keep server-side stats if API fails
            }
        }
        
        function updateDashboardStat(index, data) {
            const statCards = document.querySelectorAll('#summary-stats .stat-card h3');
            const subtitleCards = document.querySelectorAll('#summary-stats .stat-card small');
            
            if (statCards[index]) {
                statCards[index].textContent = data.value;
                // Add a subtle animation to show the update
                statCards[index].style.transition = 'all 0.3s ease';
                statCards[index].style.transform = 'scale(1.05)';
                statCards[index].style.color = '#4fd1c7';
                setTimeout(() => {
                    statCards[index].style.transform = 'scale(1)';
                    statCards[index].style.color = '';
                }, 300);
            }
            
            if (subtitleCards[index] && data.subtitle) {
                subtitleCards[index].textContent = data.subtitle;
            }
        }

        function goToHistoricalAnalysis() {
            // Navigate to model performance/accuracy page
            window.location.href = '/historical-performance';
        }

        function goToBettingGuidance() {
            // Navigate to Kelly-based betting guidance page
            window.location.href = '/betting-guidance';
        }

        function loadToday() {
            currentDate = new Date();
            localDateString = currentDate.getFullYear() + '-' + 
                              String(currentDate.getMonth() + 1).padStart(2, '0') + '-' + 
                              String(currentDate.getDate()).padStart(2, '0');
            document.getElementById('game-date').value = localDateString;
            loadTodaysGames();
        }

        // Betting Lines Refresh Function
        async function refreshBettingLines() {
            const btn = document.getElementById('refresh-betting-lines-btn');
            const originalText = btn.textContent;
            
            btn.textContent = '⏳ Updating...';
            btn.disabled = true;
            
            try {
                // Show loading notification
                showNotification('Fetching fresh betting lines from OddsAPI...', 'info', 0);
                
                const response = await fetch('/api/refresh-betting-lines', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const linesCount = data.data.fresh_lines_count;
                    const recsGenerated = data.data.recommendations_generated;
                    const recsCount = data.data.recommendations_count;
                    
                    let message = `✅ Successfully updated ${linesCount} betting lines`;
                    if (recsGenerated) {
                        message += ` and regenerated recommendations for ${recsCount} games`;
                    }
                    
                    showNotification(message, 'success', 5000);
                    
                    // Refresh the games display to show updated lines
                    setTimeout(() => {
                        loadTodaysGames();
                    }, 1000);
                    
                } else {
                    showNotification(`❌ Failed to update betting lines: ${data.error}`, 'error', 8000);
                }
                
            } catch (error) {
                console.error('Error refreshing betting lines:', error);
                showNotification('❌ Network error while updating betting lines', 'error', 8000);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        // Notification function for user feedback
        function showNotification(message, type = 'info', duration = 5000) {
            // Remove existing notifications
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(notif => notif.remove());
            
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = message;
            
            // Styling
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                border-radius: 8px;
                font-weight: bold;
                max-width: 400px;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                transition: all 0.3s ease;
                transform: translateX(100%);
            `;
            
            // Type-specific styling
            if (type === 'success') {
                notification.style.background = 'rgba(16, 185, 129, 0.9)';
                notification.style.color = 'white';
                notification.style.border = '1px solid #10b981';
            } else if (type === 'error') {
                notification.style.background = 'rgba(239, 68, 68, 0.9)';
                notification.style.color = 'white';
                notification.style.border = '1px solid #ef4444';
            } else {
                notification.style.background = 'rgba(59, 130, 246, 0.9)';
                notification.style.color = 'white';
                notification.style.border = '1px solid #3b82f6';
            }
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            // Auto-remove if duration is set
            if (duration > 0) {
                setTimeout(() => {
                    notification.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }, duration);
            }
        }

        // TBD Monitoring Functions (compact badge)
        async function updateTBDStatus() {
            try {
                const response = await fetch('/api/tbd-status');
                const data = await response.json();
                if (data && data.success) {
                    const status = data.status || {};
                    const badge = document.getElementById('tbd-badge');
                    if (badge) {
                        const count = Number(status.tbd_games_count || 0);
                        badge.textContent = isNaN(count) ? '0' : String(count);
                        badge.style.background = count > 0 ? 'rgba(239,68,68,0.85)' : 'rgba(31,41,55,0.6)';
                    }
                }
            } catch (error) {
                console.error('Error updating TBD status:', error);
                const badge = document.getElementById('tbd-badge');
                if (badge) { badge.textContent = '!'; badge.style.background = 'rgba(239,68,68,0.85)'; }
            }
        }

        async function checkTBD() {
            const btn = document.getElementById('tbd-monitor-btn');
            const originalText = btn ? btn.textContent : '';
            if (btn) { btn.textContent = 'Checking...'; btn.disabled = true; }
            try {
                const response = await fetch('/api/tbd-check', { method: 'POST', headers: { 'Content-Type': 'application/json' } });
                const data = await response.json();
                if (data && data.success) {
                    if (data.updated) {
                        loadToday();
                        updateTBDStatus();
                        showNotification('Pitcher updates found! Recommendations refreshed.', 'success', 4000);
                    } else {
                        showNotification('No pitcher updates found.', 'info', 3000);
                    }
                } else {
                    showNotification('Error checking for updates.', 'error', 4000);
                }
            } catch (error) {
                console.error('Error checking TBD:', error);
                showNotification('Network error checking for pitcher updates.', 'error', 4000);
            } finally {
                if (btn) { btn.textContent = originalText; btn.disabled = false; }
            }
        }

        // Daily Automation Function
        async function runDailyAutomation() {
            const btn = document.getElementById('run-automation-btn');
            const originalText = btn.textContent;
            
            try {
                btn.textContent = '🔄 Starting...';
                btn.disabled = true;
                
                const response = await fetch('/api/run-daily-automation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    btn.textContent = '✅ Running...';
                    alert('Daily automation started! This will update all data including betting recommendations for today. Check the console logs for progress. The page will refresh in 30 seconds.');
                    
                    // Refresh the page after 30 seconds to show updated data
                    setTimeout(() => {
                        window.location.reload();
                    }, 30000);
                } else {
                    btn.textContent = originalText;
                    btn.disabled = false;
                    alert('Error starting automation: ' + data.error);
                }
            } catch (error) {
                console.error('Error starting automation:', error);
                btn.textContent = originalText;
                btn.disabled = false;
                alert('Error starting daily automation.');
            }
        }

        // Refresh Dashboard Stats Function
        async function refreshDashboardStats() {
            const btn = document.getElementById('refresh-stats-btn');
            const originalText = btn.textContent;
            
            try {
                btn.textContent = '🔄 Updating...';
                btn.disabled = true;
                
                const response = await fetch('/api/update-dashboard-stats');
                const data = await response.json();
                
                if (data.status === 'success') {
                    btn.textContent = '✅ Updated!';
                    
                    // Update the stats display on the page
                    const totalGamesElement = document.querySelector('.stat-card h3');
                    const subtitleCards = document.querySelectorAll('#summary-stats .stat-card small');
                    if (totalGamesElement && data.stats) {
                        totalGamesElement.textContent = data.stats.total_games_analyzed || 0;
                        
                        // Update subtitles with new data
                        subtitleCards[0].textContent = `Since ${data.stats.analysis_start_date} (${data.stats.days_of_data || 0} days)`;
                        subtitleCards[1].textContent = `${data.stats.winner_predictions_correct || 0}/${data.stats.total_games_analyzed || 0} correct predictions`;
                        subtitleCards[2].textContent = `${data.stats.roi_percentage || 0}% ROI on ${data.stats.total_bets_placed || 0} bets`;
                        subtitleCards[3].textContent = `${data.stats.total_predictions_correct || 0} winning bets of ${data.stats.total_bets_placed || 0} placed`;
                    }
                    
                    // Refresh the page to show all updated stats
                    setTimeout(() => {
                        window.location.reload();
                    }, 1500);
                } else {
                    btn.textContent = '❌ Error';
                    alert('Error updating stats: ' + data.message);
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.disabled = false;
                    }, 2000);
                }
            } catch (error) {
                console.error('Error refreshing stats:', error);
                btn.textContent = '❌ Error';
                alert('Error refreshing dashboard statistics.');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 2000);
            }
        }

        async function initializeSystem() {
            const btn = document.getElementById('init-system-btn');
            const originalText = btn.textContent;
            
            try {
                btn.textContent = '🔄 Fetching Real MLB Data...';
                btn.disabled = true;
                
                showNotification('🚀 Fetching real MLB games from API...', 'info', 5000);
                
                const response = await fetch('/api/initialize-system', {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.success) {
                    btn.textContent = '✅ Success!';
                    showNotification(`✅ Successfully loaded ${data.games_loaded} real MLB games!`, 'success', 5000);
                    
                    // Show the games that were loaded
                    if (data.real_games && data.real_games.length > 0) {
                        const gamesList = data.real_games.join(', ');
                        console.log('Real games loaded:', gamesList);
                    }
                    
                    // Refresh the page to show the real data
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                } else {
                    btn.textContent = '❌ Failed';
                    showNotification(`❌ Failed to load real data: ${data.error}`, 'error', 8000);
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.disabled = false;
                    }, 3000);
                }
            } catch (error) {
                console.error('Error initializing system:', error);
                btn.textContent = '❌ Failed';
                showNotification('❌ Error fetching real MLB data. Check console for details.', 'error', 8000);
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 3000);
            }
        }

        function startLiveUpdates() {
            // Check for live games more frequently (every 10 seconds)
            setInterval(updateLiveGames, 10000);
        }

        async function updateLiveGames() {
            try {
                const date = document.getElementById('game-date').value;
                const response = await fetch(`/api/live-status?date=${date}`);
                const data = await response.json();
                
                if (data.success) {
                    const liveGames = data.games.filter(game => game.is_live || game.is_final);
                    
                    for (const liveGame of liveGames) {
                        updateGameCard(liveGame);
                    }
                    
                    // Update timestamp
                    console.log(`Live update: ${new Date().toLocaleTimeString()} - ${liveGames.length} games updated`);
                }
            } catch (error) {
                console.error('Error updating live games:', error);
            }
        }

        // Unified prop trackers: use /api/pitcher-props/unified dataset (lines, proj, edge, prob, EV, Kelly)
    function buildUnifiedPropTrackersHTML(pitcherName, side, compositeId){
            try {
                if(!pitcherName) return '';
        const pk = normName(pitcherName);
                const data = (window.__UNIFIED_PITCHER_DATA || {});
                const ix = (window.__UNIFIED_NAME_INDEX || {});
                const backendKey = ix[pk] || pk;
                const bundle = data[backendKey];
                if(!bundle){
                    // Unified dataset not ready for this pitcher; attempt minimal render from in-memory line store
                    const store = (window.__PITCHER_PROP_LINES||{})[pk] || {};
                    const mkts = Object.keys(store);
                    if(mkts.length === 0){
                        return '<div class="prop-trackers" data-pitcher="'+pk+'"></div>';
                    }
                    const html = ['<div class="prop-trackers" data-pitcher="'+pk+'">'];
                    mkts.forEach(mk => {
                        const lineVal = store[mk];
                        if(typeof lineVal !== 'number') return;
                        const id = `prop-${mk}-${side}-${compositeId}`;
                        html.push(`<div class=\"prop-tracker over\" id=\"${id}\" data-prop-market=\"${mk}\" data-prop-side=\"over\" data-prop-line=\"${lineVal}\" data-pitcher=\"${pk}\">\n                            <span class=\"label\">${mk==='strikeouts'?'K': mk==='hits_allowed'?'H': mk==='earned_runs'?'ER': mk==='walks'?'BB': mk==='outs'?'Outs': mk}</span>\n                            <span class=\"proj\">Proj -</span>\n                            <span class=\"line\">Line ${Number(lineVal).toFixed(1)}</span>\n                            <span class=\"live\" data-live=\"${mk}\">Live: —</span>\n                        </div>`);
                    });
                    html.push('</div>');
                    return html.join('');
                }
                let markets = bundle.markets || {};
                try { console.debug('[PROPS] build for', pitcherName, 'key=', backendKey, 'markets=', Object.keys(markets).length); } catch(_){ }
                // Fallback: if no enriched markets, synthesize from lines first (even without projections)
                if(Object.keys(markets).length === 0){
                    const lines = bundle.lines || {};
                    const proj = bundle.simple_projection || {};
                    const synth = {};
                    let anyLines = false;
                    Object.entries(lines).forEach(([mk, info])=>{
                        // Prefer bundle line, else try in-memory fallback store (from SSE/snapshot)
                        let lineVal = (info && typeof info.line === 'number') ? info.line : null;
                        if(lineVal==null){
                            try {
                                const nk = normName(pitcherName);
                                const storeLine = (window.__PITCHER_PROP_LINES||{})[nk]?.[mk];
                                if(typeof storeLine === 'number') lineVal = storeLine;
                            } catch(_){ }
                        }
                        if(lineVal != null){
                            anyLines = true;
                            const projVal = proj[mk];
                            const obj = { line: lineVal };
                            if(typeof projVal === 'number'){
                                obj.proj = projVal;
                                obj.edge = projVal - lineVal;
                            }
                            synth[mk] = obj;
                        }
                    });
                    if(anyLines){
                        markets = synth;
                    }
                }
                // If still empty (no lines at all), synthesize projection-only markets so cards show props even without lines
                if(Object.keys(markets).length === 0){
                    const proj = bundle.simple_projection || {};
                    const synthProjOnly = {};
                    ['strikeouts','outs','hits_allowed','walks','earned_runs'].forEach(mk=>{
                        const projVal = proj[mk];
                        if(typeof projVal === 'number'){
                            // No line yet -> show Proj and placeholder line '—'
                            synthProjOnly[mk] = { line: null, proj: projVal };
                        }
                    });
                    markets = synthProjOnly;
                }
                const order = ['strikeouts','outs','hits_allowed','walks','earned_runs'];
                const html = ['<div class="prop-trackers" data-pitcher="'+pk+'">'];
                let rendered = 0;
                order.forEach(mk => {
                    const info = markets[mk];
                    if(!info) return;
                    rendered++;
                    const projVal = info.proj;
                    const lineVal = info.line;
                    const edge = (typeof projVal==='number' && typeof lineVal==='number')? (projVal - lineVal): null;
                    let sideStr = 'over';
                    if(edge != null){ if(edge < -0.5) sideStr='under'; }
                    const id = `prop-${mk}-${side}-${compositeId}`;
                    const edgeTxt = edge!=null? ` (${edge.toFixed(1)})` : '';
                    // Simplified: hide probability/EV/Kelly details on cards for readability
                    let edgeClass='';
                    if(edge!=null){ const a=Math.abs(edge); if(a>=1.5) edgeClass='edge-strong'; else if(a>=1.0) edgeClass='edge-medium'; else if(a>=0.5) edgeClass='edge-small'; }
                    const oddsTxt = (info.over_odds||info.under_odds)? `<div class=\"odds\" style=\"font-size:10px;opacity:0.75;\">O ${info.over_odds||''} / U ${info.under_odds||''}</div>`: '';
                    html.push(`<div class=\"prop-tracker ${sideStr} ${edgeClass}\" id=\"${id}\" data-prop-market=\"${mk}\" data-prop-side=\"${sideStr}\" data-prop-line=\"${lineVal != null ? lineVal : ''}\" data-pitcher=\"${pk}\">\n                        <span class=\"label\">${mk==='strikeouts'?'K': mk==='hits_allowed'?'H': mk==='earned_runs'?'ER': mk==='walks'?'BB': mk==='outs'?'Outs': mk}</span>\n                        <span class=\"proj\">Proj ${projVal!=null?Number(projVal).toFixed(1):'-'}${edgeTxt}</span>\n                        <span class=\"line\">Line ${lineVal!=null?Number(lineVal).toFixed(1):'—'}</span>\n                        <span class=\"live\" data-live=\"${mk}\">Live: —</span>\n                        ${oddsTxt}\n                    </div>`);
                });
                // If still nothing rendered, do a minimal lines-only render so live updates can attach
                if(rendered === 0){
                    const lines = (bundle.lines || {});
                    Object.entries(lines).forEach(([mk, info])=>{
                        const lineVal = (info && typeof info.line === 'number') ? info.line : null;
                        if(lineVal==null) return;
                        const id = `prop-${mk}-${side}-${compositeId}`;
                        html.push(`<div class=\"prop-tracker over\" id=\"${id}\" data-prop-market=\"${mk}\" data-prop-side=\"over\" data-prop-line=\"${lineVal}\" data-pitcher=\"${pk}\">\n                            <span class=\"label\">${mk==='strikeouts'?'K': mk==='hits_allowed'?'H': mk==='earned_runs'?'ER': mk==='walks'?'BB': mk==='outs'?'Outs': mk}</span>\n                            <span class=\"proj\">Proj -</span>\n                            <span class=\"line\">Line ${Number(lineVal).toFixed(1)}</span>\n                            <span class=\"live\" data-live=\"${mk}\">Live: —</span>\n                        </div>`);
                        rendered++;
                    });
                }
                if(rendered === 0){
                    Object.entries(markets).forEach(([mk, info])=>{
                        const projVal = info.proj;
                        const lineVal = info.line;
                        const edge = (typeof projVal==='number' && typeof lineVal==='number')? (projVal - lineVal): null;
                        let sideStr = 'over';
                        if(edge != null){ if(edge < -0.5) sideStr='under'; }
                        const id = `prop-${mk}-${side}-${compositeId}`;
                        const edgeTxt = edge!=null? ` (${edge.toFixed(1)})` : '';
                        let edgeClass='';
                        if(edge!=null){ const a=Math.abs(edge); if(a>=1.5) edgeClass='edge-strong'; else if(a>=1.0) edgeClass='edge-medium'; else if(a>=0.5) edgeClass='edge-small'; }
                        html.push(`<div class=\"prop-tracker ${sideStr} ${edgeClass}\" id=\"${id}\" data-prop-market=\"${mk}\" data-prop-side=\"${sideStr}\" data-prop-line=\"${lineVal != null ? lineVal : ''}\" data-pitcher=\"${pk}\">\n                            <span class=\"label\">${mk}</span>\n                            <span class=\"proj\">Proj ${projVal!=null?Number(projVal).toFixed(1):'-'}${edgeTxt}</span>\n                            <span class=\"line\">Line ${lineVal!=null?Number(lineVal).toFixed(1):'—'}</span>\n                        </div>`);
                    });
                }
                html.push('</div>');
                return html.join('');
            } catch(e){ console.warn('buildUnifiedPropTrackersHTML error', e); return ''; }
        }
        function rebuildAllGameCardPitcherProps(){
            try {
                const cards = document.querySelectorAll('.game-card');
                cards.forEach(card => {
                    const compositeId = card.getAttribute('data-game-id') || 'rebuild';
                    const awayName = card.querySelector('.away-pitcher .pitcher-name')?.textContent;
                    const homeName = card.querySelector('.home-pitcher .pitcher-name')?.textContent;
                    if(awayName){
                        const metricsDiv = card.querySelector('.away-pitcher .pitch-metrics');
                        let container = card.querySelector('.away-pitcher .prop-trackers');
                        if(!container){
                            if(metricsDiv){ metricsDiv.insertAdjacentHTML('afterend', buildUnifiedPropTrackersHTML(awayName,'away', compositeId)); }
                        } else {
                            // Update existing trackers with lines/proj from unified dataset
                            try {
                                const pk = normName(awayName);
                                const idx = window.__UNIFIED_NAME_INDEX || {};
                                const backendKey = idx[pk] || pk;
                                const bundle = (window.__UNIFIED_PITCHER_DATA || {})[backendKey] || {};
                                const uMarkets = bundle.markets || {};
                                const uProj = bundle.simple_projection || {};
                                Object.keys(uMarkets).forEach(mkt => {
                                    const id = `prop-${mkt}-away-${compositeId}`;
                                    const el = document.getElementById(id);
                                    const info = uMarkets[mkt] || {};
                                    if(el){
                                        if(typeof info.line === 'number'){
                                            el.dataset.propLine = info.line;
                                            const lineEl = el.querySelector('.line');
                                            if(lineEl) lineEl.textContent = `Line ${Number(info.line).toFixed(1)}`;
                                        }
                                        const projVal = (typeof info.proj==='number')?info.proj:(typeof uProj[mkt]==='number'?uProj[mkt]:null);
                                        if(projVal!=null){
                                            const projEl = el.querySelector('.proj');
                                            if(projEl) projEl.textContent = `Proj ${Number(projVal).toFixed(1)}`;
                                        }
                                    }
                                });
                            } catch(_){}
                        }
                        // Re-apply cached live values immediately after rebuild to avoid blanking
                        applyCachedLiveToTrackers(card, compositeId, 'away');
                    }
                    if(homeName){
                        const metricsDivH = card.querySelector('.home-pitcher .pitch-metrics');
                        let containerH = card.querySelector('.home-pitcher .prop-trackers');
                        if(!containerH){
                            if(metricsDivH){ metricsDivH.insertAdjacentHTML('afterend', buildUnifiedPropTrackersHTML(homeName,'home', compositeId)); }
                        } else {
                            // Update existing trackers with lines/proj from unified dataset
                            try {
                                const pkH = normName(homeName);
                                const idx = window.__UNIFIED_NAME_INDEX || {};
                                const backendKeyH = idx[pkH] || pkH;
                                const bundleH = (window.__UNIFIED_PITCHER_DATA || {})[backendKeyH] || {};
                                const uMarketsH = bundleH.markets || {};
                                const uProjH = bundleH.simple_projection || {};
                                Object.keys(uMarketsH).forEach(mkt => {
                                    const id = `prop-${mkt}-home-${compositeId}`;
                                    const el = document.getElementById(id);
                                    const info = uMarketsH[mkt] || {};
                                    if(el){
                                        if(typeof info.line === 'number'){
                                            el.dataset.propLine = info.line;
                                            const lineElH = el.querySelector('.line');
                                            if(lineElH) lineElH.textContent = `Line ${Number(info.line).toFixed(1)}`;
                                        }
                                        const projVal = (typeof info.proj==='number')?info.proj:(typeof uProjH[mkt]==='number'?uProjH[mkt]:null);
                                        if(projVal!=null){
                                            const projElH = el.querySelector('.proj');
                                            if(projElH) projElH.textContent = `Proj ${Number(projVal).toFixed(1)}`;
                                        }
                                    }
                                });
                            } catch(_){}
                        }
                        // Re-apply cached live values immediately after rebuild to avoid blanking
                        applyCachedLiveToTrackers(card, compositeId, 'home');
                    }
                });
            } catch(e){ console.warn('rebuildAllGameCardPitcherProps failed', e); }
        }

        // Ensure calls that reference this function don't throw; debounce full rebuild to keep UI snappy
        let __propsRepaintTimer = null;
        function forceRepaintPitcherOnCards(_pitcherKey){
            try {
                if(__propsRepaintTimer){ clearTimeout(__propsRepaintTimer); }
                __propsRepaintTimer = setTimeout(()=>{
                    try { rebuildAllGameCardPitcherProps(); } catch(_){}
                }, 150);
            } catch(_) { /* no-op */ }
        }

        // Helper: Build "Batter vs Pitcher" string using inning half
        function buildBatterVsPitcher(batter, inningState, awayPitcher, homePitcher, isTopInning) {
            let half = (inningState || '').toLowerCase();
            if (!half && typeof isTopInning === 'boolean') {
                half = isTopInning ? 'top' : 'bottom';
            }
            let pitcher = '';
            if (half.startsWith('top')) {
                pitcher = homePitcher || '';
            } else if (half.startsWith('bottom')) {
                pitcher = awayPitcher || '';
            }
            // Only show when both are known; otherwise, show nothing
            if (batter && pitcher) return `${batter} vs ${pitcher}`;
            return '';
        }

        // Helper: ordinal
        function ordinal(n){
            n = parseInt(n, 10);
            if (!n && n !== 0) return '';
            const s=["th","st","nd","rd"], v=n%100;
            return n + (s[(v-20)%10]||s[v]||s[0]);
        }

        // Build graphical live at-bat widget (bases/outs/inning)
        function buildLiveAtBatWidget(lg){
            if(!lg || !lg.is_live) return '';
            const half = (typeof lg.is_top_inning === 'boolean')
                ? (lg.is_top_inning ? 'Top' : 'Bottom')
                : ((lg.inning_state || '').toLowerCase().startsWith('top') ? 'Top' : (lg.inning_state || '').toLowerCase().startsWith('bottom') ? 'Bottom' : '');
            const arrow = half === 'Top' ? '↑' : (half === 'Bottom' ? '↓' : '');
            const inn = lg.inning ? ordinal(lg.inning) : '';
            const outs = Math.max(0, Math.min(2, parseInt(lg.outs != null ? lg.outs : 0, 10)));
            const outDots = [0,1,2].map(i => `<span class="out-dot${i < outs ? ' on' : ''}"></span>`).join('');
            const b1 = lg.on_first ? ' on' : '';
            const b2 = lg.on_second ? ' on' : '';
            const b3 = lg.on_third ? ' on' : '';
            const countChip = (lg.balls != null && lg.strikes != null) ? `<span class="count-chip">${lg.balls} balls, ${lg.strikes} strikes</span>` : '';
            return `
                <div class="live-atbat">
                    <div class="half-inning">${arrow} ${half} ${inn}</div>
                    <div class="bases-diamond" title="Bases">
                        <span class="base-dot b2${b2}"></span>
                        <span class="base-dot b3${b3}"></span>
                        <span class="base-dot b1${b1}"></span>
                    </div>
                    <div class="outs" title="Outs">${outDots}</div>
                    ${countChip}
                </div>
            `;
        }

        function updateGameCard(liveGame) {
            // Find the corresponding game card by composite ID using the selected date
            const dateStr = document.getElementById('game-date')?.value || '';
            const compositeId = `${liveGame.away_team}_${liveGame.home_team}_${dateStr}`;
            
            // Debug logging
            console.log(`🔍 Looking for live game: ${liveGame.away_team} @ ${liveGame.home_team}`);
            console.log(`   Status: ${liveGame.status}, Live: ${liveGame.is_live}, Scores: ${liveGame.away_score}-${liveGame.home_score}`);
            
            // Primary: exact match on data-game-id
            let card = document.querySelector(`[data-game-id="${compositeId}"]`);
            
            // Fallback: match by explicit team attributes
            if (!card) {
                const awayKey = (liveGame.away_team || '').toLowerCase();
                const homeKey = (liveGame.home_team || '').toLowerCase();
                card = document.querySelector(`.game-card[data-away-team="${awayKey}"][data-home-team="${homeKey}"]`);
            }
            
            // Fallback: normalized names in composite if formatting differs
            if (!card) {
                const normalizedAway = liveGame.away_team.replace('Oakland ', '').replace(' Athletics', '');
                const normalizedHome = liveGame.home_team.replace('Oakland ', '').replace(' Athletics', '');
                card = document.querySelector(`[data-game-id*="${normalizedAway}"][data-game-id*="${normalizedHome}"]`);
                console.log(`   Trying normalized names: ${normalizedAway} @ ${normalizedHome}`);
            }
            
            if (card) {
                console.log(`✅ Found game card, updating live status`);
                // Update header-center
                const headerCenter = card.querySelector('.header-center');
                if (headerCenter) {
                    if (liveGame.is_live) {
                        // Replace with dynamic batter vs pitcher + last play
                        const vsLine = buildBatterVsPitcher(
                            liveGame.current_batter,
                            liveGame.inning_state,
                            liveGame.away_pitcher,
                            liveGame.home_pitcher,
                            typeof liveGame.is_top_inning === 'boolean' ? liveGame.is_top_inning : undefined
                        );
            // Graphical widget: bases/outs/inning + count
            const atbatWidget = buildLiveAtBatWidget(liveGame);
                        headerCenter.innerHTML = `
                            <div class="live-header" data-dynamic="header-center">
                ${vsLine ? `<div class=\"batter-line\">${vsLine}</div>` : (liveGame.current_batter ? `<div class=\"batter-line\">${liveGame.current_batter}</div>` : '')}
                ${atbatWidget}
                                ${liveGame.last_play ? `<div class=\"last-play-line\">${liveGame.last_play}</div>` : ''}
                            </div>
                        `;
                    } else {
                        // Non-live: show time + pill
                        const timeHtml = liveGame.game_time && !liveGame.game_time.includes('T') ? `<div class="game-time">${liveGame.game_time}</div>` : '';
                        headerCenter.innerHTML = `${timeHtml}<span class="game-status-badge badge-${liveGame.badge_class}">${liveGame.status}</span>`;
                    }
                }
                try {
                    const pm = liveGame.pitching_metrics || {};
                    const sides = ['away', 'home'];
                    for (const side of sides) {
                        // Select the pitch-metrics container for this side
                        const el = card.querySelector(`.${side}-pitcher .pitch-metrics`);
                        if (!el) continue;
                        const metrics = (pm[side] || {});
                        // Persist last-known live pitches/inning in cache
                        try {
                            const compId = compositeId;
                            const g = window.__LAST_LIVE_STATS[compId] = window.__LAST_LIVE_STATS[compId] || {};
                            const sc = g[side] = g[side] || {};
                            if (metrics.live_pitches != null) sc.live_pitches = metrics.live_pitches;
                            if (metrics.inning != null) sc.inning = metrics.inning;
                        } catch(_){ }
                        if (metrics.live_pitches != null) {
                            // Find or create the live span
                            let liveSpan = el.querySelector('.live');
                            const liveText = ` • Live: ${metrics.live_pitches}${metrics.inning ? ` (IP ${metrics.inning})` : ''}`;
                            if (liveSpan) {
                                liveSpan.textContent = liveText;
                            } else {
                                liveSpan = document.createElement('span');
                                liveSpan.className = 'live';
                                liveSpan.textContent = liveText;
                                el.appendChild(liveSpan);
                            }
                        }
                    }
                } catch (e) {
                    console.warn('⚠️ Could not update pitch-metrics:', e);
                }

                // Update all prop trackers based on live metrics and settle if final
                try {
                    const pm = liveGame.pitching_metrics || {};
                    const sides = ['away', 'home'];
                    for (const side of sides) {
            const sidePm = pm[side] || {};
            // Prepare cache handles per side
            const compId = compositeId;
            const g = window.__LAST_LIVE_STATS[compId] = window.__LAST_LIVE_STATS[compId] || {};
            const sc = g[side] = g[side] || {};
                        const markets = [
                            { key: 'strikeouts' },
                            { key: 'outs' },
                            { key: 'walks' },
                            { key: 'hits_allowed' },
                            { key: 'earned_runs' }
                        ];
                        for (const m of markets) {
                            const id = `prop-${m.key}-${side}-${compositeId}`;
                            const el = document.getElementById(id);
                            if (!el) continue;
                            const line = Number(el.getAttribute('data-prop-line'));
                            const sideStr = (el.getAttribute('data-prop-side') || 'over').toLowerCase();
                            const liveVal = sidePm[m.key];
                            if (liveVal != null) {
                // Persist last-known market value
                sc[m.key] = liveVal;
                                // Update live number and bar
                                const liveSpan = el.querySelector('.live');
                                if (liveSpan) {
                                    const delta = (Number(liveVal) - Number(line));
                                    const sign = delta > 0 ? '+' : (delta < 0 ? '−' : '');
                                    liveSpan.textContent = `Live: ${Number(liveVal).toFixed(1)} (${sign}${Math.abs(delta).toFixed(1)} vs ${Number(line).toFixed(1)})`;
                                }
                                const bar = el.querySelector('.bar');
                                const fill = el.querySelector('.bar .fill');
                                if (bar && fill) {
                                    const pct = Math.max(0, Math.min(100, (Number(liveVal) / Math.max(0.0001, Number(line))) * 100));
                                    fill.style.width = `${pct}%`;
                                    if (Number(liveVal) >= Number(line)) bar.classList.add('over'); else bar.classList.remove('over');
                                }
                                // Color state transitions on the chip itself
                                const crossed = sideStr === 'over' ? (Number(liveVal) >= line) : (Number(liveVal) > line);
                                el.classList.remove('pending', 'crossed');
                                el.classList.add(crossed ? 'crossed' : 'pending');
                            }
                            // On final, show hit/miss/push once
                            if (liveGame.is_final && !el.querySelector('.hit-badge') && !el.querySelector('.miss-badge') && !el.querySelector('.push-badge')) {
                                const liveNum = Number(sidePm[m.key]);
                                let badgeHtml = '';
                                if (!Number.isFinite(liveNum)) continue;
                                const isPush = liveNum === line;
                                const isHit = sideStr === 'over' ? (liveNum > line) : (liveNum < line);
                                if (isPush) badgeHtml = '<span class="push-badge">PUSH</span>';
                                else if (isHit) badgeHtml = '<span class="hit-badge">HIT</span>';
                                else badgeHtml = '<span class="miss-badge">MISS</span>';
                                el.insertAdjacentHTML('beforeend', badgeHtml);
                            }
                        }
                    }
                } catch (e) {
                    console.warn('⚠️ Could not update prop trackers:', e);
                }
                
                // Remove ALL existing live/final content to prevent duplicates
                card.querySelectorAll('.live-score').forEach(el => el.remove());
                card.querySelectorAll('.final-analysis').forEach(el => el.remove());
                
                const gameHeader = card.querySelector('.game-header');
                if (liveGame.is_live && (liveGame.away_score != null || liveGame.home_score != null)) {
                    const liveScoreHtml = createLiveScoreHtml(liveGame);
                    console.log(`   Adding live score HTML: ${liveScoreHtml}`);
                    gameHeader.insertAdjacentHTML('afterend', liveScoreHtml);
                } else if (liveGame.is_final && (liveGame.away_score != null || liveGame.home_score != null)) {
                    // Use stored full game object if available for prediction context
                    let fullGame = null;
                    try {
                        const idEl = card.querySelector('[id^="summary-"]');
                        if (idEl) {
                            const gameId = idEl.id.replace('summary-', '');
                            fullGame = (window.__GAME_BY_ID || {})[gameId] || null;
                        }
                    } catch(_){}
                    // Fallback minimal object to avoid undefineds
                    if(!fullGame){
                        fullGame = {
                            away_team: liveGame.away_team,
                            home_team: liveGame.home_team,
                            predicted_away_score: liveGame.predicted_away_score || 0,
                            predicted_home_score: liveGame.predicted_home_score || 0,
                            predicted_total_runs: liveGame.predicted_total_runs || 0
                        };
                    }
                    const finalScoreHtml = createFinalScoreHtml(liveGame, fullGame);
                    gameHeader.insertAdjacentHTML('afterend', finalScoreHtml);
                }
            } else {
                console.log(`❌ Game card not found for ${liveGame.away_team} @ ${liveGame.home_team}`);
            }
        }

        // Apply cached live market values to trackers within a card to avoid blanking during rebuilds
        function applyCachedLiveToTrackers(card, compositeId, side){
            try {
                const cacheSide = (window.__LAST_LIVE_STATS || {})[compositeId]?.[side] || null;
                if(!cacheSide) return;
                const markets = ['strikeouts','outs','walks','hits_allowed','earned_runs'];
                markets.forEach(mk => {
                    const el = card.querySelector(`#prop-${mk}-${side}-${compositeId}`);
                    if(!el) return;
                    const lineAttr = el.getAttribute('data-prop-line');
                    const line = lineAttr!=null && lineAttr!=='' ? Number(lineAttr) : null;
                    const liveVal = cacheSide[mk];
                    if(liveVal != null){
                        const liveSpan = el.querySelector('.live');
                        if(liveSpan){
                            if(line != null && !Number.isNaN(line)){
                                const delta = (Number(liveVal) - Number(line));
                                const sign = delta > 0 ? '+' : (delta < 0 ? '−' : '');
                                liveSpan.textContent = `Live: ${Number(liveVal).toFixed(1)} (${sign}${Math.abs(delta).toFixed(1)} vs ${Number(line).toFixed(1)})`;
                            } else {
                                liveSpan.textContent = `Live: ${Number(liveVal).toFixed(1)}`;
                            }
                        }
                    }
                });
                // Also apply cached live pitches/inning to the pitch-metrics header
                const metricsEl = card.querySelector(`.${side}-pitcher .pitch-metrics`);
                if(metricsEl && (cacheSide.live_pitches != null)){
                    let liveSpan = metricsEl.querySelector('.live');
                    const liveText = ` • Live: ${cacheSide.live_pitches}${cacheSide.inning ? ` (IP ${cacheSide.inning})` : ''}`;
                    if(liveSpan){ liveSpan.textContent = liveText; }
                    else { const s=document.createElement('span'); s.className='live'; s.textContent=liveText; metricsEl.appendChild(s); }
                }
            } catch(e){ /* no-op */ }
        }

    async function loadSummary() {
            try {
                const response = await fetch('/api/summary');
                const data = await response.json();
                
                if (data.success) {
            const summary = data.summary || {};
            const setText = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = val; };
            setText('total-games', summary.total_games ?? '');
            setText('completed-games', summary.completed_games ?? '');
            setText('prediction-accuracy', (summary.prediction_accuracy != null ? (summary.prediction_accuracy * 100).toFixed(2) + '%' : ''));
            setText('avg-error', (summary.avg_score_error != null ? Number(summary.avg_score_error).toFixed(2) : ''));
                }
            } catch (error) {
                console.error('Error loading summary:', error);
            }
        }

    async function loadTodaysGames() {
            const date = document.getElementById('game-date').value;
            const container = document.getElementById('games-container');
            
            console.log('Loading todays games for date:', date);
            container.innerHTML = '<div class="loading">Loading today\'s games...</div>';
            // Coordinated UI timeouts so we don't prematurely swap the spinner on slow networks
            let fetchTimeoutMs = 25000; // mobile-friendly first load
            const slowTimer = setTimeout(() => {
                const loading = container.querySelector('.loading');
                if (loading) loading.innerHTML = 'Loading today\'s games... (taking longer than usual)';
            }, 4000);
            const watchdog = setTimeout(() => {
                const loading = container.querySelector('.loading');
                if (loading) {
                    console.warn('Watchdog: load still in progress (slow network/server)');
                    loading.innerHTML = 'Loading today\'s games... (still working; slow network)';
                }
            }, Math.max(8000, fetchTimeoutMs - 2000));
            
            try {
                try { window.__PERF.mark('todayGames_fetch_start'); } catch(_){}
                const url = `/api/today-games?date=${encodeURIComponent(date || '')}`;
                let data;
                let attempt = 0;
                let lastErr = null;
                while (attempt < 3) {
                    try {
                        const endpoint = attempt === 2 ? '/api/today-games' : url; // final attempt without date
                        // Extend timeout for first loads and slow connections
                        try {
                            const et = navigator.connection?.effectiveType || '';
                            if (et && (et.includes('2g') || et === 'slow-2g')) {
                                fetchTimeoutMs = Math.max(fetchTimeoutMs, 35000);
                            }
                        } catch(_){ }
                        const response = await fetchWithTimeout(endpoint, {}, fetchTimeoutMs);
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        try {
                            const st = response.headers.get('Server-Timing');
                            if (st) console.info('[PERF] Server-Timing (today-games):', st);
                            const xr = response.headers.get('X-Response-Time');
                            if (xr) console.info('[PERF] X-Response-Time (today-games):', xr);
                        } catch(_){ }
                        data = await response.json();
                        break;
                    } catch (e) {
                        lastErr = e;
                        attempt += 1;
                        console.warn('today-games fetch attempt failed', attempt, e);
                        if ((e && (e.name === 'AbortError' || String(e).includes('aborted'))) && attempt < 3) {
                            fetchTimeoutMs = Math.min(fetchTimeoutMs + 10000, 45000);
                        }
                    }
                }
                try { window.__PERF.mark('todayGames_fetch_end'); } catch(_){}
                if (!data) throw lastErr || new Error('Failed to load today-games');
                
                console.log('API Response:', data);
                console.log('Games count:', data.games?.length);
                
                if (data.success && data.games.length > 0) {
                    try { window.__PERF.mark('render_start'); } catch(_){}
                    console.log('Processing games...');
                    
                    // Build a quick lookup of full games by game_id for later (finals UI)
                    window.__GAME_BY_ID = window.__GAME_BY_ID || {};
                    try {
                        data.games.forEach(g => { if (g && g.game_id != null) window.__GAME_BY_ID[g.game_id] = g; });
                    } catch(_){ }
                    
                    // Categorize games
                    const liveGames = [];
                    const upcomingGames = [];
                    const completedGames = [];
                    
                    // Track unique games to prevent duplicates
                    const uniqueGames = new Map();
                    
                    for (const game of data.games) {
                        const gameKey = `${game.away_team}_${game.home_team}_${game.date}`;
                        
                        // Only add if we haven't seen this game before
                        if (!uniqueGames.has(gameKey)) {
                            uniqueGames.set(gameKey, game);
                            
                            const liveStatus = game.live_status || {};
                            console.log(`Game: ${game.away_team} @ ${game.home_team}`);
                            console.log(`Live status:`, liveStatus);
                            
                            if (liveStatus.is_live) {
                                console.log(`Adding to live games`);
                                liveGames.push(game);
                            } else if (liveStatus.is_final) {
                                console.log(`Adding to completed games`);
                                completedGames.push(game);
                            } else {
                                console.log(`Adding to upcoming games`);
                                upcomingGames.push(game);
                            }
                        }
                    }
                    
                    // Sort games within each category
                    liveGames.sort((a, b) => {
                        // Live games: show by game time
                        const timeA = new Date(a.game_time || 0);
                        const timeB = new Date(b.game_time || 0);
                        return timeA - timeB;
                    });
                    
                    upcomingGames.sort((a, b) => {
                        // Upcoming: earliest games first using robust sort key
                        return gameSortKey(a) - gameSortKey(b);
                    });
                    
                    completedGames.sort((a, b) => {
                        // Completed: most recently finished first
                        const timeA = new Date(a.game_time || 0);
                        const timeB = new Date(b.game_time || 0);
                        return timeB - timeA;
                    });
                    
                    // Display each section
                    displayGameSection('live-games', liveGames);
                    displayGameSection('upcoming-games', upcomingGames);
                    displayGameSection('completed-games', completedGames);
                    
                    // Hide main container only after sections are populated
                    container.style.display = 'none';
                    
                    console.log(`Loaded games: ${liveGames.length} live, ${upcomingGames.length} upcoming, ${completedGames.length} completed`);

                    // Trigger an initial live update now that cards are rendered
                    updateLiveGames();
                    try {
                        window.__PERF.mark('render_end');
                        const m = window.__PERF.marks || {};
                        const t0 = window.__PERF.t0 || 0;
                        const fetchMs = (m.todayGames_fetch_end ?? 0) - (m.todayGames_fetch_start ?? 0);
                        const renderMs = (m.render_end ?? 0) - (m.render_start ?? 0);
                        const totalMs = (m.render_end ?? performance.now()) - t0;
                        const summary = { fetch: Math.max(0, fetchMs), render: Math.max(0, renderMs), total: Math.max(0, totalMs) };
                        window.__PERF.data.summary = summary;
                        console.info('[PERF] load summary:', summary);
                        window.__PERF.updateBadge(summary);
                    } catch(_){ }
                } else {
                    container.style.display = '';
                    container.innerHTML = '<div class="error">No games found for today.</div>';
                }
            } catch (error) {
                console.error('Error loading games:', error);
                container.style.display = '';
                container.innerHTML = `
                    <div class="error">
                        Error loading games: ${error.message || 'Network error'}<br/>
                        <button class="btn" style="margin-top:10px" onclick="loadTodaysGames()">Retry</button>
                    </div>`;
            }
            finally { clearTimeout(slowTimer); clearTimeout(watchdog); }
        }

        // Global JS error surface (so silent errors don’t leave spinner forever)
        window.addEventListener('error', (ev) => {
            try {
                const container = document.getElementById('games-container');
                if (!container) return;
                const hasLoading = !!container.querySelector('.loading');
                if (!hasLoading) return;
                container.style.display = '';
                container.innerHTML = `
                    <div class="error">
                        A script error occurred: ${ev.message || 'Unknown error'}<br/>
                        <small>${(ev.filename||'')}:${(ev.lineno||'')}</small><br/>
                        <button class="btn" style="margin-top:10px" onclick="loadTodaysGames()">Retry</button>
                    </div>`;
            } catch(_){}
        });

        function displayGameSection(sectionPrefix, games) {
            const section = document.getElementById(`${sectionPrefix}-section`);
            const container = document.getElementById(`${sectionPrefix}-container`);
            
            console.log(`Displaying ${sectionPrefix} with ${games.length} games`);
            
            if (games.length > 0) {
                console.log(`Showing section: ${sectionPrefix}-section`);
                section.style.display = 'block';
                container.innerHTML = '';
                
                games.forEach((game, index) => {
                    console.log(`Creating card ${index + 1} for ${game.away_team} @ ${game.home_team}`);
                    const gameCard = createGameCard(game);
                    container.appendChild(gameCard);
                });
                
                console.log(`Added ${games.length} game cards to ${sectionPrefix}-container`);
                // After cards render, attempt to rebuild prop sections if unified data is present
                try { rebuildAllGameCardPitcherProps(); } catch(_) {}
            } else {
                console.log(`Hiding section: ${sectionPrefix}-section (no games)`);
                section.style.display = 'none';
            }
        }

        // Keep the old loadGames function for historical page
        async function loadGames() {
            const date = document.getElementById('game-date').value;
            const container = document.getElementById('games-container');
            
            container.innerHTML = '<div class="loading">Loading games...</div>';
            
            try {
                const response = await fetch(`/api/today-games?date=${date}`);
                const data = await response.json();
                
                if (data.success && data.games.length > 0) {
                    // Clear container completely to prevent duplicates
                    container.innerHTML = '';
                    
                    const gamesGrid = document.createElement('div');
                    gamesGrid.className = 'games-grid';
                    
                    // Track unique games to prevent duplicates
                    const uniqueGames = new Map();
                    
                    for (const game of data.games) {
                        const gameKey = `${game.away_team}_${game.home_team}_${game.date}`;
                        
                        // Only add if we haven't seen this game before
                        if (!uniqueGames.has(gameKey)) {
                            uniqueGames.set(gameKey, game);
                            const gameCard = createGameCard(game);
                            gamesGrid.appendChild(gameCard);
                        }
                    }
                    
                    container.appendChild(gamesGrid);
                    console.log(`Loaded ${uniqueGames.size} unique games`);
                } else {
                    container.innerHTML = '<div class="error">No games found for this date.</div>';
                }
            } catch (error) {
                container.innerHTML = '<div class="error">Error loading games: ' + error.message + '</div>';
            }
        }

        function createGameCard(game) {
            const card = document.createElement('div');
            card.className = 'game-card';
            // Use a composite key that matches live-status lookups and add explicit team attributes
            const compositeId = `${game.away_team}_${game.home_team}_${game.date}`;
            card.setAttribute('data-game-id', compositeId);
            card.setAttribute('data-away-team', (game.away_team || '').toLowerCase());
            card.setAttribute('data-home-team', (game.home_team || '').toLowerCase());
            card.onclick = () => loadPrediction(game.away_team, game.home_team, game.date);
            
            // Debug: log the entire game object
            console.log(`🔍 CREATING CARD FOR: ${game.away_team} @ ${game.home_team}`);
            console.log('Full game object:', game);
            console.log('Pitcher data:', {
                away_pitcher: game.away_pitcher,
                home_pitcher: game.home_pitcher
            });
            console.log('Prediction data:', {
                predicted_away_score: game.predicted_away_score,
                predicted_home_score: game.predicted_home_score,
                predicted_total_runs: game.predicted_total_runs,
                away_win_probability: game.away_win_probability,
                home_win_probability: game.home_win_probability
            });
            
            // Get team assets for logos and colors
            const awayAssets = game.away_team_assets || { logo_url: game.away_logo };
            const homeAssets = game.home_team_assets || { logo_url: game.home_logo };
            
            // Get team colors for dynamic styling
            const awayColors = game.away_team_colors || { primary: '#333333', secondary: '#666666', text: '#FFFFFF' };
            const homeColors = game.home_team_colors || { primary: '#333333', secondary: '#666666', text: '#FFFFFF' };
            
            // Get live status information
            const liveStatus = game.live_status || {
                status: 'Scheduled',
                badge_class: 'scheduled',
                game_time: 'TBD',
                is_live: false,
                is_final: false
            };
            
            // Format game time - only show for scheduled games
            let displayTime = '';
            let displayStatus = liveStatus.status;
            
            // Only show time for scheduled games (not live or final)
            if (!liveStatus.is_live && !liveStatus.is_final) {
                // First, try to use the already-formatted time from live_status
                if (liveStatus.game_time && liveStatus.game_time !== 'TBD' && 
                    !liveStatus.game_time.includes('T') && !liveStatus.game_time.includes('Z')) {
                    // This is already a formatted time like "7:10 PM"
                    displayTime = liveStatus.game_time;
                } 
                // Otherwise, try to convert the raw game time
                else if (game.game_time && game.game_time !== 'TBD') {
                    try {
                        // Handle ISO or meridian strings like "10:45 PM ET"
                        let gameTimeString = game.game_time;
                        console.log('🕐 Processing game time:', gameTimeString);
                        if (/^(\d{1,2}):(\d{2})\s*(AM|PM)\s*ET$/i.test(gameTimeString)) {
                            displayTime = etToCtDisplay(gameTimeString);
                            console.log('✅ ET string converted to:', displayTime);
                        } else if (/(T|Z)/.test(gameTimeString)) {
                            const gameDate = new Date(gameTimeString);
                            if (isNaN(gameDate.getTime())) {
                                console.error('❌ Invalid date parsed:', gameTimeString);
                                displayTime = 'TBD';
                            } else {
                                displayTime = gameDate.toLocaleTimeString('en-US', {
                                    hour: 'numeric', minute: '2-digit', hour12: true, timeZone: 'America/Chicago'
                                }) + ' CT';
                                console.log('✅ Time converted successfully:', { original: gameTimeString, parsed: gameDate.toISOString(), central: displayTime });
                            }
                        } else if (/^(\d{1,2}):(\d{2})\s*(AM|PM)$/i.test(gameTimeString)) {
                            // Already a meridian string without TZ; display as-is
                            displayTime = gameTimeString.trim();
                            console.log('ℹ️ Using provided meridian string:', displayTime);
                        } else {
                            console.error('❌ Unrecognized time format:', gameTimeString);
                            displayTime = 'TBD';
                        }
                    } catch (error) {
                        console.error('❌ Error converting game time:', error);
                        displayTime = 'TBD';
                    }
                }
            }
            
            // For live games, enhance status with inning info if available
            if (liveStatus.is_live && liveStatus.inning && liveStatus.inning_state) {
                displayStatus = `${liveStatus.inning_state} ${liveStatus.inning}`;
            }
            
            // Get real betting lines data
            const realLines = game.real_betting_lines || {};
            const moneyline = realLines.moneyline || {};
            const totalRuns = realLines.total_runs || {};
            const runLine = realLines.run_line || {};
            
            let bettingLinesHtml = '';
            // Show betting lines if we have real betting lines data
            if (game.has_real_betting_lines && Object.keys(realLines).length > 0) {
                // Format moneyline odds with proper + sign for positive values
                const formatOdds = (odds) => {
                    if (!odds) return 'N/A';
                    return odds > 0 ? `+${odds}` : `${odds}`;
                };
                
                // Format run line with proper +/- signs - handle both string and numeric formats
                const formatRunLine = (line, odds, isAway = true) => {
                    if (!line) return 'N/A';
                    
                    // Handle string format like "-1.5 (+130)"
                    if (typeof odds === 'string') {
                        return odds;
                    }
                    
                    // Handle numeric format from OddsAPI
                    if (typeof odds === 'number') {
                        const lineStr = isAway ? (line > 0 ? `+${line}` : `${line}`) : (line > 0 ? `-${line}` : `+${Math.abs(line)}`);
                        const oddsStr = odds > 0 ? `+${odds}` : `${odds}`;
                        return `${lineStr} (${oddsStr})`;
                    }
                    
                    return 'N/A';
                };
                
                bettingLinesHtml = `
                    <div class="betting-lines">
                        <h4>DraftKings Betting Lines</h4>
                        <div class="betting-grid">
                            <div class="betting-item">
                                <div class="line-label">Moneyline</div>
                                <div class="line-value">
                                    <div class="moneyline-away">${game.away_team.substring(0, 3)}: ${formatOdds(moneyline.away)}</div>
                                    <div class="moneyline-home">${game.home_team.substring(0, 3)}: ${formatOdds(moneyline.home)}</div>
                                </div>
                            </div>
                            <div class="betting-item">
                                <div class="line-label">Over/Under</div>
                                <div class="line-value">
                                    ${totalRuns.line ? `${totalRuns.line}` : 'N/A'}<br>
                                    ${totalRuns.over && totalRuns.under ? `O: ${formatOdds(totalRuns.over)} / U: ${formatOdds(totalRuns.under)}` : ''}
                                </div>
                            </div>
                            <div class="betting-item">
                                <div class="line-label">Run Line</div>
                                <div class="line-value">
                                    <div class="moneyline-away">${game.away_team.substring(0, 3)}: ${formatRunLine(runLine.line, runLine.away, true)}</div>
                                    <div class="moneyline-home">${game.home_team.substring(0, 3)}: ${formatRunLine(runLine.line, runLine.home, false)}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Build Batter vs Pitcher line for live header (Top -> home pitcher, Bottom -> away pitcher)
            const liveVsLine = liveStatus.is_live ? buildBatterVsPitcher(
                liveStatus.current_batter,
                liveStatus.inning_state,
                (liveStatus.away_pitcher || game.away_pitcher),
                (liveStatus.home_pitcher || game.home_pitcher),
                typeof liveStatus.is_top_inning === 'boolean' ? liveStatus.is_top_inning : undefined
            ) : '';

            card.innerHTML = `
                <div class="game-header">
                    <div class="header-left game-teams">
                        <div class="team-info" style="background: linear-gradient(135deg, ${awayColors.primary}, ${awayColors.secondary}); color: ${awayColors.text}; border-radius: 8px; padding: 6px 8px;">
                            <img src="${awayAssets.logo_url || ''}" alt="${game.away_team}" class="team-logo" />
                            <span class="team-name">${game.away_team}</span>
                        </div>
                    </div>
                    <div class="header-center">
                        ${liveStatus.is_live ? `
                            <div class="live-header" data-dynamic="header-center">
                                ${(() => {
                                    const countChip = (liveStatus.balls != null && liveStatus.strikes != null) ? `<span class="count-chip">${liveStatus.balls} balls, ${liveStatus.strikes} strikes</span>` : '';
                                    if (liveVsLine) return `<div class="batter-line">${liveVsLine}${countChip ? ` ${countChip}` : ''}</div>`;
                                    if (liveStatus.current_batter) return `<div class="batter-line">${liveStatus.current_batter}${countChip ? ` ${countChip}` : ''}</div>`;
                                    return '';
                                })()}

                                ${liveStatus.last_play ? `<div class=\"last-play-line\">${liveStatus.last_play}</div>` : ''}
                            </div>
                        ` : `
                            ${displayTime ? `<div class=\"game-time\">${displayTime}</div>` : ''}
                            <span class=\"game-status-badge badge-${liveStatus.badge_class}\">${displayStatus}</span>
                        `}
                    </div>
                    <div class="header-right game-teams" style="justify-content: end;">
                        <div class="team-info" style="background: linear-gradient(135deg, ${homeColors.primary}, ${homeColors.secondary}); color: ${homeColors.text}; border-radius: 8px; padding: 6px 8px;">
                            <img src="${homeAssets.logo_url || ''}" alt="${game.home_team}" class="team-logo" />
                            <span class="team-name">${game.home_team}</span>
                        </div>
                    </div>
                </div>

                <div class="card-body">
                    <div class="card-section transparent">
                        <div class="starting-pitchers">
                            <div class="pitcher-matchup">
                                <div class="away-pitcher">
                                    <span class="pitcher-label">Starting Pitcher:</span>
                                    <span class="pitcher-name">${game.away_pitcher || 'TBD'}</span>
                                    <div class="pitch-metrics" id="pitch-metrics-away-${compositeId}">
                                        ${game.pitching_metrics && game.pitching_metrics.away ? `
                                        <span class="proj">Proj: ${game.pitching_metrics.away.projected_pitch_count ?? '-'}<span class="ppo"> (PPO ${game.pitching_metrics.away.pp_out ?? '-'})</span></span>
                                        ${game.pitching_metrics.away.live_pitches != null ? `<span class="live"> • Live: ${game.pitching_metrics.away.live_pitches}${game.pitching_metrics.away.inning ? ` (IP ${game.pitching_metrics.away.inning})` : ''}</span>` : ''}

                                        ` : ''}

                                    </div>
                                    ${buildUnifiedPropTrackersHTML(game.away_pitcher, 'away', compositeId)}
                                </div>
                                <span class="vs-separator">vs</span>
                                <div class="home-pitcher">
                                    <span class="pitcher-label">Starting Pitcher:</span>
                                    <span class="pitcher-name">${game.home_pitcher || 'TBD'}</span>
                                    <div class="pitch-metrics" id="pitch-metrics-home-${compositeId}">
                                        ${game.pitching_metrics && game.pitching_metrics.home ? `

                                        <span class="proj">Proj: ${game.pitching_metrics.home.projected_pitch_count ?? '-'}<span class="ppo"> (PPO ${game.pitching_metrics.home.pp_out ?? '-'})</span></span>
                                        ${game.pitching_metrics.home.live_pitches != null ? `<span class="live"> • Live: ${game.pitching_metrics.home.live_pitches}${game.pitching_metrics.home.inning ? ` (IP ${game.pitching_metrics.home.inning})` : ''}</span>` : ''}

                                        ` : ''}

                                    </div>
                                    ${buildUnifiedPropTrackersHTML(game.home_pitcher, 'home', compositeId)}
                                </div>
                            </div>
                        </div>
                        
                    </div>
                    <div class="card-section">
                        <div class="prediction-summary" id="summary-${game.game_id}">
                            ${createPredictionSummaryHtml(game)}
                        </div>
                        ${game.betting_recommendations ? createBettingRecommendationsHtml(game.betting_recommendations, game.away_team, game.home_team) : ''}
                        ${bettingLinesHtml}
                    </div>
                </div>
            `;
            
            return card;
        }

        function createPredictionSummaryHtml(game) {
            // Use prediction data directly from the game object
            const predictedAwayScore = game.predicted_away_score || 0;
            const predictedHomeScore = game.predicted_home_score || 0;
            const awayWinProb = game.away_win_probability || 0;
            const homeWinProb = game.home_win_probability || 0;
            const predictedWinner = game.predicted_winner || '';
            
            console.log('Creating prediction summary for:', game.away_team, '@', game.home_team);
            console.log('Prediction data:', { predictedAwayScore, predictedHomeScore, awayWinProb, homeWinProb });
            
            // If no prediction data, show placeholder
            if (!predictedAwayScore && !predictedHomeScore) {
                console.log('No prediction data found, showing placeholder');
                return `
                    <div class="prediction-item">
                        <div class="value">--</div>
                        <div class="label">No Prediction</div>
                    </div>
                `;
            }
            
            console.log('Creating prediction summary with data');
            return `
                <div class="prediction-item">
                    <div class="value">${predictedAwayScore}</div>
                    <div class="label">${game.away_team.split(' ').pop()}</div>
                </div>
                <div class="prediction-item">
                    <div class="value">${predictedHomeScore}</div>
                    <div class="label">${game.home_team.split(' ').pop()}</div>
                </div>
                <div class="prediction-item">
                    <div class="value">${homeWinProb.toFixed(2)}%</div>
                    <div class="label">Home Win</div>
                </div>
            `;
        }

    function createLiveScoreHtml(liveStatus, awayColors = null, homeColors = null) {
            // Only hide if scores are truly missing; show 0-0 as valid
            if (liveStatus.away_score == null && liveStatus.home_score == null) {
                return '';
            }
            
            // Default colors if not provided
            const defaultAwayColors = awayColors || { primary: '#333333', secondary: '#666666', text: '#FFFFFF' };
            const defaultHomeColors = homeColors || { primary: '#444444', secondary: '#777777', text: '#FFFFFF' };
            
            // Create inning display for live games
            let inningDisplay = 'LIVE';
            if (liveStatus.inning && liveStatus.inning_state) {
                inningDisplay = `${liveStatus.inning_state} ${liveStatus.inning}`;
            }
            const count = (liveStatus.balls != null && liveStatus.strikes != null) ? ` | ${liveStatus.balls} balls, ${liveStatus.strikes} strikes` : '';
            const bases = liveStatus.base_state ? ` | ${liveStatus.base_state}` : '';
            const outsVal = (liveStatus.outs != null) ? ` | Outs ${liveStatus.outs}` : '';
            // Optional runner dots
            const r1 = liveStatus.on_first ? '●' : '○';
            const r2 = liveStatus.on_second ? '●' : '○';
            const r3 = liveStatus.on_third ? '●' : '○';
            const runners = (liveStatus.on_first || liveStatus.on_second || liveStatus.on_third) ? ` | ${r1} ${r2} ${r3}` : '';
            const batter = liveStatus.current_batter ? ` | ${liveStatus.current_batter}` : '';
            
            return `
                <div class="live-score">
                    <div style="background: ${defaultAwayColors.primary}; color: ${defaultAwayColors.text}; padding: 4px 8px; border-radius: 4px; border: 1px solid ${defaultAwayColors.secondary};">
                        <span class="team-score">${liveStatus.away_score ?? 0}</span>
                    </div>
                    <div style="color: #dc3545; font-weight: bold; font-size: 0.9em;">${inningDisplay}${count}${outsVal}${bases}${runners}${liveStatus.current_batter ? ` | Hitter: ${liveStatus.current_batter}` : ''}</div>
                    ${liveStatus.last_play ? `<div style="grid-column: 1 / -1; font-size: 0.8rem; opacity: 0.9; margin-top: 4px;">Last play: ${liveStatus.last_play}</div>` : ''}
                    <div style="background: ${defaultHomeColors.primary}; color: ${defaultHomeColors.text}; padding: 4px 8px; border-radius: 4px; border: 1px solid ${defaultHomeColors.secondary};">
                        <span class="team-score">${liveStatus.home_score ?? 0}</span>
                    </div>
                </div>
            `;
        }

        function createFinalScoreHtml(liveStatus, game, awayColors = null, homeColors = null) {
            if (liveStatus.away_score == null && liveStatus.home_score == null) {
                return '';
            }
            
            // Default colors if not provided
            const defaultAwayColors = awayColors || { primary: '#333333', secondary: '#666666', text: '#FFFFFF' };
            const defaultHomeColors = homeColors || { primary: '#444444', secondary: '#777777', text: '#FFFFFF' };
            
            // Use game data directly as it contains prediction info
            const predictedAwayScore = game.predicted_away_score || 0;
            const predictedHomeScore = game.predicted_home_score || 0;
            const predictedTotalRuns = game.predicted_total_runs || (predictedAwayScore + predictedHomeScore);
            
            // Debug: Check what's happening with predicted total runs
            console.log(`🐛 DEBUGGING Total Runs for ${game.away_team} @ ${game.home_team}:`);
            console.log(`  - game.predicted_total_runs: ${game.predicted_total_runs}`);
            console.log(`  - predictedAwayScore: ${predictedAwayScore}`);
            console.log(`  - predictedHomeScore: ${predictedHomeScore}`);
            console.log(`  - calculated predictedTotalRuns: ${predictedTotalRuns}`);
            
            const actualAwayScore = liveStatus.away_score || 0;
            const actualHomeScore = liveStatus.home_score || 0;
            const actualTotalRuns = actualAwayScore + actualHomeScore;
            
            // Winner prediction accuracy
            const predictedWinner = predictedAwayScore > predictedHomeScore ? 'away' : 'home';
            const actualWinner = actualAwayScore > actualHomeScore ? 'away' : 'home';
            const winnerCorrect = predictedWinner === actualWinner;
            
            // Score difference analysis
            const awayScoreDiff = Math.abs(actualAwayScore - predictedAwayScore);
            const homeScoreDiff = Math.abs(actualHomeScore - predictedHomeScore);
            const avgScoreDiff = (awayScoreDiff + homeScoreDiff) / 2;
            
            // Total runs analysis
            const totalRunsDiff = Math.abs(actualTotalRuns - predictedTotalRuns);
            const totalRunsAccuracy = totalRunsDiff <= 1 ? 'Excellent' : 
                                     totalRunsDiff <= 2 ? 'Good' : 
                                     totalRunsDiff <= 3 ? 'Fair' : 'Poor';
            
            // Use the original bet_grade if available (from enhanced grading), otherwise calculate
            let grade = game.bet_grade || '';
            let gradePoints = 0;
            
            // If no bet_grade available, calculate traditional accuracy grade
            if (!grade) {
                if (winnerCorrect) gradePoints += 50;
                if (avgScoreDiff <= 1) gradePoints += 30;
                else if (avgScoreDiff <= 2) gradePoints += 20;
                else if (avgScoreDiff <= 3) gradePoints += 10;
                if (totalRunsDiff <= 1) gradePoints += 20;
                else if (totalRunsDiff <= 2) gradePoints += 15;
                else if (totalRunsDiff <= 3) gradePoints += 10;
                
                if (gradePoints >= 90) grade = 'A+';
                else if (gradePoints >= 80) grade = 'A';
                else if (gradePoints >= 70) grade = 'B+';
                else if (gradePoints >= 60) grade = 'B';
                else if (gradePoints >= 50) grade = 'C';
                else grade = 'D';
            }
            
            // Betting line analysis (if comprehensive analysis available)
            let bettingAnalysisHtml = '';
            const postGameAnalysis = game.post_game_analysis;
            if (postGameAnalysis && postGameAnalysis.betting_analysis) {
                const bettingAnalysis = postGameAnalysis.betting_analysis;
                
                let marketVsModelHtml = '';
                if (bettingAnalysis.betting_favorite) {
                    const favoriteWon = bettingAnalysis.favorite_won;
                    const modelBeatMarket = bettingAnalysis.model_beat_market;
                    
                    marketVsModelHtml = `
                        <div class="analysis-item ${favoriteWon ? 'analysis-correct' : 'analysis-incorrect'}">
                            <strong>Market Favorite:</strong> ${favoriteWon ? '✅ Won' : '❌ Lost'}
                        </div>
                        <div class="analysis-item ${modelBeatMarket ? 'analysis-correct' : 'analysis-incorrect'}">
                            <strong>Model vs Market:</strong> ${modelBeatMarket ? '✅ Beat Market' : '❌ Followed Market'}
                        </div>
                    `;
                }
                
                let totalBetHtml = '';
                if (bettingAnalysis.total_analysis) {
                    const totalAnalysis = bettingAnalysis.total_analysis;
                    const modelCorrectTotal = totalAnalysis.model_correct_total;
                    
                    totalBetHtml = `
                        <div class="analysis-item ${modelCorrectTotal ? 'analysis-correct' : 'analysis-incorrect'}">
                            <strong>Total Bet:</strong> ${modelCorrectTotal ? '✅ Correct' : '❌ Incorrect'} (Line: ${totalAnalysis.line})
                        </div>
                    `;
                }
                
                if (marketVsModelHtml || totalBetHtml) {
                    bettingAnalysisHtml = `
                        <div class="betting-comparison">
                            <h6>📈 Model vs Market Performance</h6>
                            <div class="betting-grid">
                                ${marketVsModelHtml}
                                ${totalBetHtml}
                            </div>
                        </div>
                    `;
                }
            }
            
            return `
                <div class="live-score">
                    <div>
                        <span style="color: #ff6b6b;">${liveStatus.away_team ? liveStatus.away_team.substring(0, 3) : 'AWAY'}</span>
                        <span class="team-score">${actualAwayScore}</span>
                    </div>
                    <div style="color: #28a745; font-weight: bold; font-size: 0.9em;">FINAL</div>
                    <div>
                        <span style="color: #4ecdc4;">${liveStatus.home_team ? liveStatus.home_team.substring(0, 3) : 'HOME'}</span>
                        <span class="team-score">${actualHomeScore}</span>
                    </div>
                </div>
                <div class="final-analysis">
                    <h5>📊 Prediction Analysis (Grade: ${grade})</h5>
                    <div class="analysis-grid">
                        <div class="analysis-item ${winnerCorrect ? 'analysis-correct' : 'analysis-incorrect'}">
                            <strong>Winner:</strong> ${winnerCorrect ? '✅ Correct' : '❌ Incorrect'}
                        </div>
                        <div class="analysis-item">
                            <strong>Score Error:</strong> ±${avgScoreDiff.toFixed(2)} runs
                        </div>
                        <div class="analysis-item">
                            <strong>Total Runs:</strong> ${actualTotalRuns} (predicted ${predictedTotalRuns})
                        </div>
                        <div class="analysis-item">
                            <strong>Total Accuracy:</strong> ±${totalRunsDiff} runs (${totalRunsAccuracy})
                        </div>
                    </div>
                    ${bettingAnalysisHtml}
                </div>
            `;
        }

        async function loadQuickPrediction(awayTeam, homeTeam, date, gameId) {
            try {
                const response = await fetch(`/api/prediction/${awayTeam}/${homeTeam}?date=${date}`);
                const data = await response.json();
                
                if (data.success) {
                    const pred = data.prediction;  // data is directly in prediction object
                    const meta = data.prediction.meta;
                    
                    const summaryElement = document.getElementById(`summary-${gameId}`);
                    if (summaryElement) {
                        // Get pitcher information for display
                        const awayPitcher = pred.away_pitcher || 'TBD';
                        const homePitcher = pred.home_pitcher || 'TBD';
                        
                        summaryElement.innerHTML = `
                            <div class="prediction-item">
                                <div class="value">${pred.predicted_away_score}</div>
                                <div class="label">${awayTeam.split(' ').pop()}</div>
                            </div>
                            <div class="prediction-item">
                                <div class="value">${pred.predicted_home_score}</div>
                                <div class="label">${homeTeam.split(' ').pop()}</div>
                            </div>
                            <div class="prediction-item">
                                <div class="value">${pred.home_win_probability.toFixed(2)}%</div>
                                <div class="label">Home Win</div>
                            </div>
                        `;
                        
                        // Add quick betting tip if available
                        const bettingRecs = data.betting_recommendations;  // Get from top level of data object
                        if (bettingRecs && bettingRecs.best_bet) {
                            const bestBet = bettingRecs.best_bet;
                            const icon = bestBet.edge_rating || '🎯';
                            summaryElement.innerHTML += `
                                <div class="prediction-item betting-tip" style="background: rgba(79, 209, 199, 0.2); border-left: 2px solid #4fd1c7;">
                                    <div class="value" style="font-size: 0.8em;">${icon} ${bestBet.recommendation || bestBet.bet || 'Value Bet'}</div>
                                    <div class="label" style="font-size: 0.7em;">Best Bet</div>
                                </div>
                            `;
                        }
                        
                        // Betting recommendations are now included in initial load, no need to add dynamically
                        // This prevents double display issues
                    }
                    
                    // Update betting lines if available (only if not already present)
                    const bettingData = data.prediction.betting_data;
                    if (bettingData) {
                        const gameCard = document.querySelector(`#summary-${gameId}`).closest('.game-card');
                        const existingLines = gameCard.querySelector('.betting-lines');
                        
                        if (gameCard && !existingLines) {
                            updateGameCardBetting(gameId, bettingData, awayTeam, homeTeam);
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading quick prediction:', error);
            }
        }

        function updateGameCardBetting(gameId, bettingData, awayTeam, homeTeam) {
            // Find the game card and check if it already has betting lines
            const gameCard = document.querySelector(`#summary-${gameId}`).closest('.game-card');
            
            // Double-check if betting lines already exist to prevent duplicates
            if (!gameCard || gameCard.querySelector('.betting-lines')) {
                return; // Already has betting lines or can't find game card
            }
            
            const moneyline = bettingData.moneyline || {};
            const total = bettingData.total || {};
            const spread = bettingData.spread || {};
            
            const bettingLinesHtml = `
                <div class="betting-lines">
                    <h4>Betting Lines</h4>
                    <div class="betting-grid">
                        <div class="betting-item">
                            <div class="line-label">Moneyline</div>
                            <div class="line-value">
                                <div class="moneyline-away">${awayTeam.substring(0, 3)}: ${moneyline.away || 'N/A'}</div>
                                <div class="moneyline-home">${homeTeam.substring(0, 3)}: ${moneyline.home || 'N/A'}</div>
                            </div>
                        </div>
                        <div class="betting-item">
                            <div class="line-label">Total</div>
                            <div class="line-value">
                                ${total.line ? `O/U ${total.line}` : 'N/A'}
                            </div>
                        </div>
                        <div class="betting-item">
                            <div class="line-label">Spread</div>
                            <div class="line-value">
                                ${spread.line ? `${spread.line > 0 ? '+' : ''}${spread.line}` : 'N/A'}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Insert betting lines after the prediction summary
            const summaryElement = document.getElementById(`summary-${gameId}`);
            summaryElement.insertAdjacentHTML('afterend', bettingLinesHtml);
        }

        function createBettingRecommendationsHtml(bettingRecs, awayTeam, homeTeam) {
            if (!bettingRecs) {
                return '';
            }

            let html = '<div class="betting-recommendations" data-added="true">';
            html += '<h4>💰 Betting Recommendations</h4>';
            
            // Add summary if available
            if (bettingRecs.summary) {
                html += `<div style="font-size: 0.9em; color: #888; margin-bottom: 10px;">${bettingRecs.summary}</div>`;
            }

            // Handle new enhanced format with value_bets array
            if (bettingRecs.value_bets && bettingRecs.value_bets.length > 0) {
                bettingRecs.value_bets.forEach(bet => {
                    const confidenceClass = bet.confidence === 'HIGH' ? 'high-confidence' : 
                                          bet.confidence === 'MEDIUM' ? 'medium-confidence' : 'low-confidence';
                    
                    // Add positive EV class if applicable
                    const isPositiveEV = bet.expected_value && bet.expected_value > 0;
                    const cssClasses = isPositiveEV ? `${confidenceClass} positive-ev` : confidenceClass;
                    
                    const icon = bet.edge_rating || (bet.confidence === 'HIGH' ? '🔥' : 
                               bet.confidence === 'MEDIUM' ? '⚡' : '💡');
                    
                    // Display the recommendation with enhanced formatting
                    const recommendation = bet.recommendation || `${bet.direction?.toUpperCase()} ${bet.line}`;
                    const edgeText = typeof bet.edge === 'number' ? `${bet.edge.toFixed(2)}% edge` : 
                                    bet.edge ? bet.edge : 
                                    bet.confidence ? `${bet.confidence} CONFIDENCE` : 'Value Bet';
                    
                    // Format Expected Value display - LIMITED TO 2 DECIMAL PLACES MAX
                    let evDisplay = '';
                    let evBadge = '';
                    if (bet.expected_value !== undefined && bet.expected_value !== null) {
                        const evPercent = (bet.expected_value * 100).toFixed(2);
                        const evColor = bet.expected_value > 0 ? '#4fd1c7' : '#ff6b6b';
                        const evSign = bet.expected_value > 0 ? '+' : '';
                        evDisplay = `<span style="color: ${evColor}; font-weight: bold;">EV: ${evSign}${evPercent}%</span>`;
                        
                        // Add +EV badge for positive expected value
                        if (bet.expected_value > 0) {
                            evBadge = `<span class="positive-ev-badge">+EV</span>`;
                        }
                    }
                    
                    html += `
                        <div class="value-bet ${cssClasses}" title="${bet.reasoning || 'No details available'}">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 5px;">
                                    <span>${icon}</span>
                                    <strong>${recommendation}</strong>
                                    ${evBadge}
                                </div>
                                <div style="display: flex; flex-direction: column; align-items: flex-end; font-size: 0.8em;">
                                    <span style="color: #4fd1c7;">${edgeText}</span>
                                    ${evDisplay ? `<div>${evDisplay}</div>` : ''}
                                    ${bet.estimated_odds && bet.estimated_odds !== 'N/A' ? `<span style="color: #888;">${bet.estimated_odds}</span>` : ''}
                                </div>
                            </div>
                            <div style="font-size: 0.85em; color: #ccc; margin-top: 3px; line-height: 1.2;">
                                ${bet.reasoning}
                            </div>
                        </div>
                    `;
                });
            }
            // Handle legacy format
            else if (bettingRecs.recommendations && bettingRecs.recommendations.length > 0) {
                bettingRecs.recommendations.forEach(rec => {
                    if (rec !== "No significant value bets identified") {
                        html += `<div class="value-bet medium-confidence">⚡ ${rec}</div>`;
                    }
                });
            }

            // If no value bets found
            const noValueBets = (!bettingRecs.value_bets || bettingRecs.value_bets.length === 0);
            const noLegacy = (!bettingRecs.recommendations || bettingRecs.recommendations.every(r => r.includes("No significant")));
            if (noValueBets && noLegacy) {
                html += '<div class="no-value-bet">💡 No strong value bets identified for this game yet. Lines or projections may still be updating.</div>';
            }

            // Add best bet highlight if available
            if (bettingRecs.best_bet) {
                html += `
                    <div style="margin-top: 10px; padding: 8px; background: rgba(79, 209, 199, 0.2); border-left: 3px solid #4fd1c7; border-radius: 4px;">
                        <strong>🎯 Best Bet:</strong> ${bettingRecs.best_bet.recommendation}
                    </div>
                `;
            }

            html += '</div>';
            return html;
        }

        async function loadPrediction(awayTeam, homeTeam, date) {
            document.getElementById('modal-body').innerHTML = 'Loading detailed prediction...';
            document.getElementById('prediction-modal').style.display = 'block';
            
            console.log(`🔍 Loading prediction for: ${awayTeam} @ ${homeTeam} on ${date}`);
            
            try {
                const url = `/api/prediction/${awayTeam}/${homeTeam}?date=${date}`;
                console.log('API URL:', url);
                
                const response = await fetch(url);
                const data = await response.json();
                
                console.log('Prediction API response:', data);
                
                if (data.success) {
                    const prediction = data.prediction;
                    
                    console.log('Betting recommendations in modal:', data.betting_recommendations);
                    
                    // Update modal title with team logos
                    const awayAssets = prediction.away_team_assets || { logo_url: data.game.away_logo };
                    const homeAssets = prediction.home_team_assets || { logo_url: data.game.home_logo };
                    
                    document.getElementById('modal-title').innerHTML = `
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <img src="${awayAssets.logo_url || ''}" alt="${awayTeam}" style="width: 24px; height: 24px;" />
                                <span>${awayTeam}</span>
                            </div>
                            <span>@</span>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <img src="${homeAssets.logo_url || ''}" alt="${homeTeam}" style="width: 24px; height: 24px;" />
                                <span>${homeTeam}</span>
                            </div>
                        </div>
                    `;
                    
                    displayPredictionDetails(data);
                } else {
                    document.getElementById('modal-body').innerHTML = 
                        '<div class="error">Error loading prediction: ' + data.error + '</div>';
                }
            } catch (error) {
                document.getElementById('modal-body').innerHTML = 
                    '<div class="error">Error loading prediction: ' + error.message + '</div>';
            }
        }

        function displayPredictionDetails(data) {
            console.log('🎯 displayPredictionDetails called with:', data);
            console.log('Betting recommendations:', data.betting_recommendations);
            
            const prediction = data.prediction;  // Extract prediction from data object
            const game = data.game;  // Extract game info from data object
            const pred = prediction;  // Keep this for backward compatibility with existing code
            const meta = prediction.meta || {
                execution_time_ms: 0,
                simulations_run: prediction.simulation_count || 5000,
                data_source: prediction.model_version || 'simulation'
            };
            const recs = prediction.recommendations || [];
            
            // Extract pitcher information from game data with real factors
            const awayPitcher = { 
                name: game.away_pitcher || 'TBD', 
                factor: game.away_pitcher_factor || 1.0
            };
            const homePitcher = { 
                name: game.home_pitcher || 'TBD', 
                factor: game.home_pitcher_factor || 1.0
            };
            
            // Get team names from game data
            const awayTeam = game.away_team;
            const homeTeam = game.home_team;
            
            // Get team assets for colors
            const awayAssets = prediction.away_team_assets || {};
            const homeAssets = prediction.home_team_assets || {};
            
            let html = `
                <div class="prediction-details">
                    <div class="prediction-summary">
                        <div class="prediction-item" style="background-color: ${awayAssets.primary_color || '#4fd1c7'}22; border-left: 3px solid ${awayAssets.primary_color || '#4fd1c7'};">
                            <div class="value">${pred.predicted_away_score}</div>
                            <div class="label">${awayTeam} Score</div>
                        </div>
                        <div class="prediction-item" style="background-color: ${homeAssets.primary_color || '#4fd1c7'}22; border-left: 3px solid ${homeAssets.primary_color || '#4fd1c7'};">
                            <div class="value">${pred.predicted_home_score}</div>
                            <div class="label">${homeTeam} Score</div>
                        </div>
                        <div class="prediction-item">
                            <div class="value">${pred.predicted_total_runs}</div>
                            <div class="label">Total Runs</div>
                        </div>
                        <div class="prediction-item">
                            <div class="value">${pred.home_win_probability.toFixed(2)}%</div>
                            <div class="label">Home Win Prob</div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px;">
                        <h3>Starting Pitchers</h3>
                        <p><strong>Away:</strong> ${awayPitcher.name || 'TBD'} (Quality Factor: ${(awayPitcher.factor || 1.0).toFixed(2)})</p>
                        <p><strong>Home:</strong> ${homePitcher.name || 'TBD'} (Quality Factor: ${(homePitcher.factor || 1.0).toFixed(2)})</p>
                        <div style="font-size: 0.9em; color: #888; margin-top: 10px;">
                            <em>Factor < 1.0 = Better pitcher (allows fewer runs), Factor > 1.0 = Weaker pitcher</em>
                        </div>
                    </div>
                    
                    <!-- Add comprehensive factors section -->
                    <div style="margin-top: 20px;">
                        <h3>📊 Model Factors</h3>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 10px;">
                            ${data.factors ? `
                                <!-- Team Strengths -->
                                <div style="padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid #4fd1c7;">
                                    <div style="font-weight: bold; color: #4fd1c7; margin-bottom: 8px;">Team Strengths</div>
                                    <div style="font-size: 0.9em;">
                                        <div style="color: #ff6b6b; margin-bottom: 4px;">${awayTeam}: ${data.factors.team_strengths ? (data.factors.team_strengths.away_strength > 0 ? '+' : '') + data.factors.team_strengths.away_strength.toFixed(3) : 'N/A'}</div>
                                        <div style="color: #4ecdc4;">${homeTeam}: ${data.factors.team_strengths ? (data.factors.team_strengths.home_strength > 0 ? '+' : '') + data.factors.team_strengths.home_strength.toFixed(3) : 'N/A'}</div>
                                    </div>
                                </div>
                                
                                <!-- Bullpen Quality -->
                                <div style="padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid #ffa726;">
                                    <div style="font-weight: bold; color: #ffa726; margin-bottom: 8px;">Bullpen Quality</div>
                                    <div style="font-size: 0.9em;">
                                        <div style="color: #ff6b6b; margin-bottom: 4px;">${awayTeam}: ${data.factors.bullpen_quality ? data.factors.bullpen_quality.away_bullpen.rating + ' (' + data.factors.bullpen_quality.away_bullpen.quality_factor.toFixed(2) + ')' : 'N/A'}</div>
                                        <div style="color: #4ecdc4;">${homeTeam}: ${data.factors.bullpen_quality ? data.factors.bullpen_quality.home_bullpen.rating + ' (' + data.factors.bullpen_quality.home_bullpen.quality_factor.toFixed(2) + ')' : 'N/A'}</div>
                                    </div>
                                </div>
                                
                                <!-- Weather & Park -->
                                ${data.factors.weather_park && Object.keys(data.factors.weather_park).length > 0 ? `
                                <div style="padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid #66bb6a; grid-column: 1 / -1;">
                                    <div style="font-weight: bold; color: #66bb6a; margin-bottom: 8px;">🌤️ Weather & Park Factors</div>
                                    <div style="font-size: 0.9em; display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                                        <div>Temp: ${data.factors.weather_park.temperature}°F</div>
                                        <div>Wind: ${data.factors.weather_park.wind_speed} mph</div>
                                        <div>Conditions: ${data.factors.weather_park.weather_condition}</div>
                                        <div>Park Factor: ${data.factors.weather_park.park_factor.toFixed(2)}</div>
                                        <div>Runs Factor: ${data.factors.weather_park.total_runs_factor.toFixed(2)}</div>
                                    </div>
                                </div>
                                ` : `
                                <div style="padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid #888; grid-column: 1 / -1;">
                                    <div style="font-weight: bold; color: #888; margin-bottom: 8px;">🌤️ Weather & Park Factors</div>
                                    <div style="font-size: 0.9em; color: #888; font-style: italic;">Weather data not available</div>
                                </div>
                                `}
                            ` : `
                                <div style="padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid #888; grid-column: 1 / -1;">
                                    <div style="font-weight: bold; color: #888; margin-bottom: 8px;">📊 Model Factors</div>
                                    <div style="font-size: 0.9em; color: #888; font-style: italic;">Factor details not available</div>
                                </div>
                            `}
                        </div>
                        <div style="font-size: 0.8em; color: #888; margin-top: 10px; text-align: center;">
                            <em>Higher team strength and bullpen factors = better performance expected</em>
                        </div>
                    </div>
            `;
            
            // Add betting lines section if available
            const bettingData = prediction.betting_data || prediction.closing_lines;
            if (bettingData) {
                const moneyline = bettingData.moneyline || {};
                const total = bettingData.total || {};
                const spread = bettingData.spread || {};
                
                html += `
                    <div style="margin-top: 20px;">
                        <h3>Betting Lines</h3>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-top: 10px;">
                            <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                                <div style="font-weight: bold; margin-bottom: 5px;">Moneyline</div>
                                <div style="font-size: 0.9rem;">
                                    <div style="color: #ff6b6b;">${awayTeam}: ${moneyline.away || 'N/A'}</div>
                                    <div style="color: #4ecdc4;">${homeTeam}: ${moneyline.home || 'N/A'}</div>
                                </div>
                            </div>
                            <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                                <div style="font-weight: bold; margin-bottom: 5px;">Total</div>
                                <div style="font-size: 0.9rem;">
                                    ${total.line ? `O/U ${total.line}` : 'N/A'}<br>
                                    ${total.over && total.under ? `${total.over}/${total.under}` : ''}
                                </div>
                            </div>
                            <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                                <div style="font-weight: bold; margin-bottom: 5px;">Spread</div>
                                <div style="font-size: 0.9rem;">
                                    ${spread.line ? `${spread.line > 0 ? '+' : ''}${spread.line}` : 'N/A'}<br>
                                    ${spread.away && spread.home ? `${spread.away}/${spread.home}` : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Add enhanced betting recommendations section
            const bettingRecs = data.betting_recommendations;  // Get from top level of data object
            if (bettingRecs && (bettingRecs.value_bets || bettingRecs.summary)) {
                html += '<div style="margin-top: 20px;"><h3>💰 Betting Recommendations</h3>';
                
                // Add summary if available
                if (bettingRecs.summary) {
                    html += `<div style="margin-bottom: 15px; padding: 10px; background: rgba(79, 209, 199, 0.1); border-radius: 6px; color: #4fd1c7; font-weight: bold;">${bettingRecs.summary}</div>`;
                }
                
                // Show value bets in enhanced format
                if (bettingRecs.value_bets && bettingRecs.value_bets.length > 0) {
                    bettingRecs.value_bets.forEach(bet => {
                        const confidenceColor = bet.confidence === 'HIGH' ? '#ff6b6b' : 
                                               bet.confidence === 'MEDIUM' ? '#ffa726' : '#66bb6a';
                        const icon = bet.edge_rating || (bet.confidence === 'HIGH' ? '🔥' : 
                                   bet.confidence === 'MEDIUM' ? '⚡' : '💡');
                        
                        // Format Expected Value for modal - LIMITED TO 2 DECIMAL PLACES MAX
                        let evModalDisplay = '';
                        if (bet.expected_value !== undefined && bet.expected_value !== null) {
                            const evPercent = (bet.expected_value * 100).toFixed(2);
                            const evColor = bet.expected_value > 0 ? '#4fd1c7' : '#ff6b6b';
                            const evSign = bet.expected_value > 0 ? '+' : '';
                            evModalDisplay = `<div style="color: ${evColor}; font-weight: bold; font-size: 0.95em;">EV: ${evSign}${evPercent}%</div>`;
                        }
                        
                        html += `
                            <div style="margin: 12px 0; padding: 15px; background: rgba(255,255,255,0.08); border-left: 4px solid ${confidenceColor}; border-radius: 8px;">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                                    <strong style="color: ${confidenceColor}; font-size: 1.1em;">${icon} ${bet.recommendation || bet.bet}</strong>
                                    <div style="text-align: right; font-size: 0.9em;">
                                        <div style="color: #4fd1c7; font-weight: bold;">${typeof bet.edge === 'number' ? bet.edge.toFixed(2) + '% edge' : bet.edge ? bet.edge : bet.confidence ? bet.confidence + ' CONFIDENCE' : 'Value Bet'}</div>
                                        ${evModalDisplay}
                                        ${bet.estimated_odds && bet.estimated_odds !== 'N/A' ? `<div style="color: #888;">${bet.estimated_odds}</div>` : ''}
                                    </div>
                                </div>
                                <div style="font-size: 0.9em; color: #ccc; line-height: 1.3;">${bet.reasoning}</div>
                                <div style="margin-top: 8px; font-size: 0.8em; color: #888;">
                                    <span style="background: rgba(${bet.confidence === 'HIGH' ? '255, 107, 107' : bet.confidence === 'MEDIUM' ? '255, 167, 38' : '102, 187, 106'}, 0.3); padding: 2px 6px; border-radius: 4px;">${bet.confidence} CONFIDENCE</span>
                                    <span style="margin-left: 10px;">${bet.type}</span>
                                </div>
                            </div>
                        `;
                    });
                    
                    // Highlight best bet if available
                    if (bettingRecs.best_bet) {
                        html += `
                            <div style="margin-top: 15px; padding: 12px; background: rgba(79, 209, 199, 0.2); border: 2px solid #4fd1c7; border-radius: 8px;">
                                <strong style="color: #4fd1c7;">🎯 Recommended Best Bet:</strong> ${bettingRecs.best_bet.recommendation || bettingRecs.best_bet.bet}
                            </div>
                        `;
                    }
                } else {
                    html += '<div style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px; font-style: italic; opacity: 0.8; text-align: center;">💡 No strong value bets identified - consider live betting opportunities</div>';
                }
                
                html += '</div>';
            }
            
            if (recs.length > 0) {
                // Legacy recommendations format - now using enhanced betting recommendations above
                console.log('Legacy recommendations found but using enhanced format instead');
            }
            
            html += `
                <div style="margin-top: 20px; font-size: 0.9rem; opacity: 0.8;">
                    ${meta.execution_time_ms > 0 ? `Execution Time: ${meta.execution_time_ms.toFixed(2)}ms | ` : ''}
                    Simulations: ${(meta.simulations_run || 5000).toLocaleString()} |
                    Data Source: ${meta.data_source || 'comprehensive_engine'}
                </div>
            `;
            
            document.getElementById('modal-body').innerHTML = html;
        }

        // Maintain global pitcher lines map for initial card render fallback
        window.__PITCHER_PROP_LINES = window.__PITCHER_PROP_LINES || {};

        // augment existing SSE script updateTracker to store global lines
        (function(){
          const origUpdateTracker = window.__updatePitcherTrackerFn; // none yet
        })();
        

    // === LIVE PITCHER PROP LINES (SSE) FOR INDEX PAGE ===
          const norm = normName;
          const MARKET_KEY_MAP = { 'outs':'outs','strikeouts':'strikeouts','hits_allowed':'hits_allowed','walks':'walks','earned_runs':'earned_runs' };
          function classifyEdge(edge){
            const a = Math.abs(edge);
            if(a >= 1.5) return 'edge-strong';
            if(a >= 1.0) return 'edge-medium';
            if(a >= 0.5) return 'edge-small';
            return '';
          }
          function ensureEdgeSpan(projSpan){
            let sp = projSpan.querySelector('span.edge');
            if(!sp){ sp = document.createElement('span'); sp.className='edge'; projSpan.appendChild(sp); }
            return sp;
          }
          let es;
          function updateTracker(pitcherKey, market, payload){
            const trackers = document.querySelectorAll('.prop-tracker');
            const pk = norm(pitcherKey);
            // Store globally for future renders
            window.__PITCHER_PROP_LINES = window.__PITCHER_PROP_LINES || {};
            const keyRaw = pitcherKey;
            const keyNorm = norm(pitcherKey);
            const store = window.__PITCHER_PROP_LINES[keyNorm] = window.__PITCHER_PROP_LINES[keyNorm] || {};
            const newLineValue = (payload.new_line !== undefined ? payload.new_line : (payload.line !== undefined ? payload.line : null));
            if(typeof newLineValue === 'number'){
               const prev = store[market];
               store[market] = newLineValue;
               if(prev == null){
                  // First time line appears: force re-render of any game card containing this pitcher
                  forceRepaintPitcherOnCards(pitcherKey);
               }
            }
            trackers.forEach(tr => {
              const attr = norm(tr.getAttribute('data-pitcher'));
              if(!attr) return;
              if(attr===pk || pk.includes(attr) || attr.includes(pk)){
                if(tr.getAttribute('data-prop-market') === market){
                  const newLine = (payload.new_line !== undefined ? payload.new_line : (payload.line !== undefined ? payload.line : null));
                  const overOdds = payload.new_over_odds || payload.over_odds || null;
                  const underOdds = payload.new_under_odds || payload.under_odds || null;
                  if(newLine!=null){
                    const lineSpan = tr.querySelector('.line');
                    if(lineSpan){
                      lineSpan.textContent = 'Line ' + Number(newLine).toFixed(1);
                      lineSpan.classList.add('line-updated');
                      setTimeout(()=> lineSpan && lineSpan.classList.remove('line-updated'), 3000);
                    }
                    tr.dataset.propLine = newLine;
                  }
                  if(overOdds || underOdds){
                    let oddsSpan = tr.querySelector('.odds');
                    if(!oddsSpan){ oddsSpan = document.createElement('span'); oddsSpan.className='odds'; tr.appendChild(oddsSpan); }
                    const fmt = o => o==null?'' : String(o).replace(/undefined|null/gi,'');
                    oddsSpan.textContent = `O ${fmt(overOdds)} / U ${fmt(underOdds)}`.trim();
                  }
                  // Recompute edge
                    try {
                      const projSpan = tr.querySelector('.proj');
                      if(projSpan){
                        const m = projSpan.textContent.match(/Proj\s+(\d+(?:\.\d+)?)/i);
                        const lineVal = parseFloat(tr.dataset.propLine);
                        if(m && !isNaN(lineVal)){
                          const projVal = parseFloat(m[1]);
                          const edge = projVal - lineVal;
                          let edgeSpan = ensureEdgeSpan(projSpan);
                          edgeSpan.textContent = `(${edge.toFixed(1)})`;
                          edgeSpan.className = 'edge ' + classifyEdge(edge) + (edge < 0 ? ' edge-negative' : '');
                        }
                      }
                    } catch(_e){}
                }
              }
            });
          }
                    // Force repaint for pitcher: rebuild trackers block inside any game card showing that pitcher
            window.forceRepaintPitcherOnCards = function(pitcher){
                try {
                    const pk = norm(pitcher);
                    const cards = document.querySelectorAll('.game-card');
                    cards.forEach(card => {
                        const spans = Array.from(card.querySelectorAll('.pitcher-name'));
                        const compositeId = card.getAttribute('data-game-id') || '';
                        spans.forEach(sp => {
                            if(norm(sp.textContent) !== pk) return;
                            const sideContainer = sp.closest('.away-pitcher, .home-pitcher');
                            if(!sideContainer) return;
                            const side = sideContainer.classList.contains('away-pitcher') ? 'away' : 'home';
                            const store = (window.__PITCHER_PROP_LINES||{})[pk] || {};
                            if(Object.keys(store).length===0) return;
                            let container = sideContainer.querySelector('.prop-trackers[data-pitcher="'+pk+'"]');
                            if(!container){
                                container = document.createElement('div');
                                container.className='prop-trackers';
                                container.setAttribute('data-pitcher', pk);
                                const metrics = sideContainer.querySelector('.pitch-metrics');
                                if(metrics){ metrics.insertAdjacentElement('afterend', container); }
                                else { sideContainer.appendChild(container); }
                            }
                            // Use unified dataset to populate projections/odds when available
                            const idx = window.__UNIFIED_NAME_INDEX || {};
                            const backendKey = idx[pk] || pk;
                            const bundle = (window.__UNIFIED_PITCHER_DATA || {})[backendKey] || {};
                            const uMarkets = bundle.markets || {};
                            const uProj = bundle.simple_projection || {};

                            Object.entries(store).forEach(([mkt,lineVal])=>{
                                const id = `prop-${mkt}-${side}-${compositeId}`;
                                let div = document.getElementById(id);
                                const label = (mkt==='strikeouts'?'K': mkt==='hits_allowed'?'H': mkt==='earned_runs'?'ER': mkt==='walks'?'BB': mkt==='outs'?'Outs': mkt);
                                const info = uMarkets[mkt] || {};
                                const projVal = (typeof info.proj === 'number') ? info.proj : (typeof uProj[mkt] === 'number' ? uProj[mkt] : null);
                                const overOdds = info.over_odds != null ? info.over_odds : null;
                                const underOdds = info.under_odds != null ? info.under_odds : null;
                                if(!div){
                                    div = document.createElement('div');
                                    div.className='prop-tracker';
                                    div.setAttribute('data-pitcher', pk);
                                    div.setAttribute('data-prop-market', mkt);
                                    div.setAttribute('data-prop-side', 'over');
                                    div.dataset.propLine=lineVal;
                                    div.id = id;
                                    const projText = projVal!=null? `Proj ${Number(projVal).toFixed(1)}` : 'Proj -';
                                    div.innerHTML = `<span class=\"label\">${label}</span>`+
                                                    `<span class=\"proj\">${projText}</span>`+
                                                    `<span class=\"line\">Line ${Number(lineVal).toFixed(1)}</span>`+
                                                    ` <span class=\"live\" data-live=\"${mkt}\">Live: —</span>`;
                                    container.appendChild(div);
                                } else {
                                    // Update line
                                    div.dataset.propLine = lineVal;
                                    const lineSpan = div.querySelector('.line');
                                    if(lineSpan){ lineSpan.textContent = `Line ${Number(lineVal).toFixed(1)}`; }
                                    // Update proj if known
                                    if(projVal!=null){
                                        const projSpan = div.querySelector('.proj');
                                        if(projSpan){ projSpan.textContent = `Proj ${Number(projVal).toFixed(1)}`; }
                                    }
                                }
                                // Update odds if known
                                if(overOdds!=null || underOdds!=null){
                                    let oddsSpan = div.querySelector('.odds');
                                    if(!oddsSpan){ oddsSpan = document.createElement('span'); oddsSpan.className='odds'; div.appendChild(oddsSpan); }
                                    const fmt = o => o==null?'' : String(o);
                                    oddsSpan.textContent = `O ${fmt(overOdds)} / U ${fmt(underOdds)}`.trim();
                                }
                                // Compute and stamp edge if we have proj
                                if(projVal!=null){
                                    const projSpan = div.querySelector('.proj');
                                    if(projSpan){
                                        const edge = Number(projVal) - Number(lineVal);
                                        let edgeSpan = projSpan.querySelector('span.edge');
                                        if(!edgeSpan){ edgeSpan = document.createElement('span'); edgeSpan.className='edge'; projSpan.appendChild(edgeSpan); }
                                        edgeSpan.textContent = `(${edge.toFixed(1)})`;
                                    }
                                }
                            });
                            // Re-apply cached live values for this side to avoid blanking
                            applyCachedLiveToTrackers(card, compositeId, side);
                        });
                    });
                } catch(e){ console.warn('forceRepaintPitcherOnCards failed', e); }
            }
          function handleEvent(ev){
            switch(ev.type){
              case 'line_initial':
              case 'line_move':
                updateTracker(ev.pitcher, ev.market, ev);
                break;
              default:
                break;
            }
          }
                    function startSSE(){
                        try {
                            es = new EventSource('/api/pitcher-props/stream');
                            try { document.getElementById('sseStatusDot').style.background = '#00c853'; } catch(_){ }
                            es.onmessage = (msg)=>{ if(!msg.data) return; try { const ev = JSON.parse(msg.data); if(ev && ev.type) handleEvent(ev); } catch(e){ console.warn('SSE parse', e); } };
                            es.onerror = ()=>{ try { es.close(); } catch(_){}; try { document.getElementById('sseStatusDot').style.background = '#bbb'; } catch(_){ } setTimeout(startSSE, 10000); };
                        } catch(e){ console.warn('SSE init failed', e); setTimeout(startSSE, 15000); }
                    }
                 async function primeFromUnified(){
                 try {
                     const selDate = document.getElementById('game-date')?.value || '';
                     console.debug('[UNIFIED] fetching unified props for date:', selDate);
                     const bust = `t=${Date.now()}`;
                     const q = selDate?`date=${encodeURIComponent(selDate)}&${bust}`:bust;
                     const r = await fetch(`/api/pitcher-props/unified?${q}`);
                     if(!r.ok) { console.warn('[UNIFIED] fetch not ok', r.status); return; }
                     const data = await r.json();
                     if(!data.success) { console.warn('[UNIFIED] response not successful', data); return; }
             // Store full unified dataset for sidebar + trackers
             window.__UNIFIED_PITCHER_DATA = data.data || {};
                 // Expose unified meta for health signal (e.g., source_date fallback)
                 window.__UNIFIED_PITCHER_META = data.meta || {};
                            console.debug('[UNIFIED] loaded pitchers:', Object.keys(window.__UNIFIED_PITCHER_DATA).length, 'meta:', data.meta);
                            // Build simple->backend key index for name normalization consistency
                            (function(){
                                const idx = {};
                                Object.keys(window.__UNIFIED_PITCHER_DATA).forEach(k=>{ idx[normName(k)] = k; });
                                window.__UNIFIED_NAME_INDEX = idx;
                            })();
                     window.__PITCHER_PROP_LINES = window.__PITCHER_PROP_LINES || {};
                     Object.entries(data.data || {}).forEach(([pk, bundle])=>{
                         const lines = bundle.lines || {};
                         const proj = bundle.simple_projection || {};
                         const nk = normName(pk);
                         const store = window.__PITCHER_PROP_LINES[nk] = window.__PITCHER_PROP_LINES[nk] || {};
                         Object.entries(lines).forEach(([mkt, info])=>{
                             if(info && typeof info.line === 'number'){
                                 if(store[mkt] == null){ store[mkt] = info.line; }
                             }
                         });
                         // If projections available, attempt to update any already-rendered trackers with proj values
                         const trackers = document.querySelectorAll('.prop-tracker[data-pitcher="'+nk+'"]');
                         trackers.forEach(tr=>{
                             const mkt = tr.getAttribute('data-prop-market');
                 const projVal = proj[mkt];
                             if(projVal!=null){
                                 const projSpan = tr.querySelector('.proj');
                                 if(projSpan){ projSpan.textContent = 'Proj '+Number(projVal).toFixed(1); }
                             }
                         });
                         // Ensure trackers exist for this pitcher if any lines
                         if(Object.keys(store).length>0){ forceRepaintPitcherOnCards(pk); }
                     });
            // After initial unified data load, rebuild once to enrich; avoid repeated rebuilds to prevent UI blanking
            window.__UNIFIED_INITIAL_REBUILD_DONE = window.__UNIFIED_INITIAL_REBUILD_DONE || false;
            if(!window.__UNIFIED_INITIAL_REBUILD_DONE){
                console.debug('[UNIFIED] initial rebuild of game card prop sections');
                rebuildAllGameCardPitcherProps();
                window.__UNIFIED_INITIAL_REBUILD_DONE = true;
            }
                 } catch(e){ console.warn('primeFromUnified failed', e); }
             }
          async function snapshotPatch(){
            try {
              const selDate = document.getElementById('game-date')?.value || '';
              const bust = `t=${Date.now()}`;
              const q = selDate?`?date=${encodeURIComponent(selDate)}&${bust}`:`?${bust}`;
              const r = await fetch('/api/pitcher-props/current' + q);
              if(r.ok){
                const data = await r.json();
                const props = data.pitcher_props || {};
                Object.entries(props).forEach(([p, mkts])=>{
                  Object.entries(mkts).forEach(([market, info])=>{
                    if(info && typeof info.line === 'number'){
                      updateTracker(p, market, { line: info.line, over_odds: info.over_odds, under_odds: info.under_odds });
                    }
                  });
                });
              }
            } catch(e){ console.warn('snapshot patch error', e); }
            finally { setTimeout(snapshotPatch, 300000); } // 5 min
          }
          document.addEventListener('DOMContentLoaded', ()=>{
              startSSE();
              snapshotPatch();
              // Defer unified props fetch slightly to avoid blocking first render
              setTimeout(()=>{
                  try { window.__PERF.mark('unified_fetch_start'); } catch(_){ }
                  primeFromUnified().finally(()=>{
                      try {
                          window.__PERF.mark('unified_fetch_end');
                          const m = window.__PERF.marks || {};
                          const dur = (m.unified_fetch_end ?? 0) - (m.unified_fetch_start ?? 0);
                          const s = window.__PERF.data.summary || {};
                          s.props = Math.max(0, dur);
                          window.__PERF.data.summary = s;
                          window.__PERF.updateBadge(s);
                          console.info('[PERF] unified props fetch duration:', dur.toFixed(1), 'ms');
                      } catch(_){ }
                  });
              }, 300);
          });
          // Periodic refresh every 60s to keep EV / Kelly / lines current
          setInterval(()=> { primeFromUnified(); }, 30000);
          
                    // === Props Health Polling ===
                    async function checkPropsHealth(){
                        try {
                            const selDate = document.getElementById('game-date')?.value || '';
                            const bust = `t=${Date.now()}`;
                            const q = selDate?`date=${encodeURIComponent(selDate)}&${bust}`:bust;
                            const r = await fetch(`/api/health/props-stream-stats?${q}`);
                            if(!r.ok) return;
                            const resp = await r.json();
                            const h = resp?.stats || {};
                            const banner = document.getElementById('propsHealthBanner');
                            const msg = document.getElementById('propsHealthMsg');
                            const selectedDate = (selDate || resp?.date || '').slice(0,10);

                            const latest = h.latest_props || {};
                            const latestMeta = latest.meta || {};
                            const latestDate = (latest.date || '').slice(0,10);
                            const latestPitchers = (typeof latestMeta.pitchers === 'number') ? latestMeta.pitchers : null;

                            const nonempty = h.latest_nonempty_props || {};
                            const nonEmptyMeta = nonempty.meta || {};
                            const nonEmptyDate = (nonempty.date || '').slice(0,10);
                            const nonEmptyPitchers = (typeof nonEmptyMeta.pitchers === 'number') ? nonEmptyMeta.pitchers : null;

                            // Determine if UI is using a fallback date (from unified meta)
                            const uiSourceDate = (window.__UNIFIED_PITCHER_META && window.__UNIFIED_PITCHER_META.source_date) ? String(window.__UNIFIED_PITCHER_META.source_date).slice(0,10) : null;

                            // Healthy conditions:
                            // - We have a non-empty props file for the selected date; OR
                            // - UI source date matches selected date.
                            const hasNonEmptyToday = (nonEmptyDate && nonEmptyDate === selectedDate && (nonEmptyPitchers ?? 0) > 0);
                            const uiAlignedWithSelected = (uiSourceDate && uiSourceDate === selectedDate);

                            let showBanner = false;
                            let note = '';

                            if (hasNonEmptyToday || uiAlignedWithSelected) {
                                showBanner = false; // clearly healthy
                            } else {
                                // Stale conditions:
                                // - Latest file for selected date exists but is empty AND we only have a prior non-empty file.
                                // - Or there's no latest/non-empty file matching selected date at all.
                                const latestIsTodayButEmpty = (latestDate === selectedDate && latestPitchers === 0);
                                const noTodayDataAtAll = (latestDate !== selectedDate && nonEmptyDate !== selectedDate);
                                if (latestIsTodayButEmpty || noTodayDataAtAll) {
                                    showBanner = true;
                                    if (nonEmptyDate && nonEmptyDate !== selectedDate) {
                                        note = ` Using ${nonEmptyDate} file.`;
                                    }
                                }
                            }

                            if (banner) banner.style.display = showBanner ? 'block' : 'none';
                            if (msg && showBanner) {
                                msg.textContent = `Showing last-known lines; live updates may be delayed.${note}`;
                            }
                        } catch(_e) { /* ignore */ }
                    }
                    // Kick off health checks
                    document.addEventListener('DOMContentLoaded', ()=>{ checkPropsHealth(); setInterval(checkPropsHealth, 60000); });
          // === Pitcher Sidebar Rendering ===
          function renderPitcherSidebar(){
             const root = document.getElementById('pitcherSidebarContent');
             if(!root) return;
             const filter = (document.getElementById('pitcherFilter')?.value||'').toLowerCase();
             const marketSel = document.getElementById('marketFilter')?.value||'';
             const data = window.__UNIFIED_PITCHER_DATA || {};
             const rows = [];
             Object.entries(data).forEach(([pk, meta])=>{
                 if(filter && !pk.includes(filter)) return;
                 const markets = meta.markets || {};
                 Object.entries(markets).forEach(([mkt, info])=>{
                     if(marketSel && mkt!==marketSel) return;
                     const edge = info.edge; const edgeCls = edge>=1.5?'#16a34a': edge>=1.0?'#2563eb': edge>=0.5?'#999': edge<=-1.0?'#dc2626':'#666';
                     rows.push(`<div style='padding:6px 4px;border-bottom:1px solid rgba(255,255,255,0.07);display:grid;grid-template-columns:86px 42px 42px 42px 42px 50px;gap:4px;align-items:center;'>
                         <span title='${pk}' style='white-space:nowrap;overflow:hidden;text-overflow:ellipsis;'>${pk}</span>
                         <span>${mkt}</span>
                         <span>${info.line!=null?Number(info.line).toFixed(1):''}</span>
                         <span>${info.proj!=null?Number(info.proj).toFixed(1):''}</span>
                         <span style='color:${edgeCls};'>${edge!=null?edge.toFixed(1):''}</span>
                         <span style='font-size:10px;line-height:1.1;'>PO ${info.p_over??''}<br>EV ${info.ev_over??''}<br>K ${info.kelly_over??''}</span>
                     </div>`);
                 });
             });
             root.innerHTML = `<div style='font-size:10px;color:#aaa;padding:2px 0 4px;'>Pitcher | Mkt | Line | Proj | Edge | Prob/EV/K</div>` + (rows.join('') || `<div style='padding:8px;color:#999;'>No matches</div>`);
          }
          document.getElementById('togglePitcherSidebar').addEventListener('click', ()=>{
                const el = document.getElementById('pitcher-sidebar');
                el.style.display = (el.style.display==='none'||!el.style.display)?'block':'none';
                if(el.style.display==='block') renderPitcherSidebar();
          });
          document.getElementById('closePitcherSidebar').addEventListener('click', ()=>{
                document.getElementById('pitcher-sidebar').style.display='none';
          });
          document.getElementById('pitcherFilter').addEventListener('input', ()=> renderPitcherSidebar());
          document.getElementById('marketFilter').addEventListener('change', ()=> renderPitcherSidebar());
          setInterval(()=>{ if(document.getElementById('pitcher-sidebar').style.display==='block'){ renderPitcherSidebar(); } }, 60000);
          // end LIVE PITCHER PROP LINES block
        // === END LIVE PITCHER PROP LINES ===
    </script>
    <script>
    // Lightweight DOM vs unified dataset audit (manual trigger: auditUnifiedPropTrackers())
    (function(){
        function num(v){ const n = parseFloat(v); return isNaN(n)? null : n; }
        window.auditUnifiedPropTrackers = function(){
            const data = window.__UNIFIED_PITCHER_DATA || {};
            const mismatches = [];
            document.querySelectorAll('.prop-tracker').forEach(tr => {
                const pk = (tr.getAttribute('data-pitcher')||'').trim();
                const market = (tr.getAttribute('data-prop-market')||'').trim();
                if(!pk || !market) return;
                const bundle = data[pk];
                if(!bundle){
                    mismatches.push({type:'missing_pitcher_in_data', pitcher: pk});
                    return;
                }
                const info = (bundle.markets||{})[market];
                if(!info){
                    mismatches.push({type:'missing_market_in_data', pitcher: pk, market});
                    return;
                }
                const lineSpan = tr.querySelector('.line');
                const projSpan = tr.querySelector('.proj');
                const lineDom = lineSpan? num(lineSpan.textContent.replace(/[^0-9.\-]+/g,'')) : null;
                const projDom = projSpan? num(projSpan.textContent.replace(/[^0-9.\-]+/g,'')) : null;
                if(info.line!=null && lineDom!=null && Math.abs(info.line - lineDom) > 0.05){
                    mismatches.push({type:'line_mismatch', pitcher: pk, market, data_line: info.line, dom_line: lineDom});
                }
                if(info.proj!=null && projDom!=null && Math.abs(info.proj - projDom) > 0.05){
                    mismatches.push({type:'proj_mismatch', pitcher: pk, market, data_proj: info.proj, dom_proj: projDom});
                }
            });
            console.log('[PropAudit] mismatches', mismatches);
            return mismatches;
        };
        if(window.ENABLE_PROP_AUDIT){
            setInterval(()=>{ try { window.auditUnifiedPropTrackers(); } catch(e){} }, 30000);
        }
    })();
    </script>
    
    <!-- Monitoring Widget -->
    <script src="{{ url_for('static', filename='js/monitoring-widget.js') }}"></script>
</body>
</html>
