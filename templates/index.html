<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MLB-Betting Prediction System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .clickable-stat {
            text-decoration: none;
            color: inherit;
            display: block;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .clickable-stat:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.15);
            border-color: #4fd1c7;
            box-shadow: 0 10px 25px rgba(79, 209, 199, 0.3);
        }

        .clickable-stat:hover h3 {
            color: #5ce1e6;
            text-shadow: 0 0 10px rgba(92, 225, 230, 0.5);
        }

        .stat-card h3 {
            font-size: 2rem;
            margin-bottom: 5px;
            color: #4fd1c7;
        }

        .stat-card p {
            opacity: 0.8;
        }

        .games-section {
            margin-top: 30px;
        }

        .games-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .date-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .date-selector input {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            background: #4fd1c7;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #45b7b8;
        }

        .btn-small {
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            background: #4fd1c7;
            color: white;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: background 0.3s;
        }

        .btn-small:hover {
            background: #45b7b8;
        }

        .games-grid {
            display: grid;
            gap: 15px;
        }

        .game-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
            overflow: hidden;
        }

        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .starting-pitchers {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .pitcher-matchup {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .away-pitcher, .home-pitcher {
            flex: 1;
            text-align: center;
        }

        .pitcher-label {
            display: block;
            font-size: 0.8rem;
            opacity: 0.7;
            margin-bottom: 2px;
        }

        .pitcher-name {
            display: block;
            font-weight: bold;
            color: #4fd1c7;
        }

        .pitcher-matchup .vs-separator {
            font-size: 0.8rem;
            opacity: 0.5;
            margin: 0 5px;
        }

        .game-teams {
            font-size: 1.2rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .team-info {
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .team-info:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .team-logo {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }

        .team-name {
            font-weight: bold;
        }

        .vs-separator {
            font-size: 0.9rem;
            opacity: 0.7;
            margin: 0 5px;
        }

        .game-time {
            opacity: 0.7;
            font-size: 0.9rem;
        }

        .prediction-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .betting-lines {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .betting-lines h4 {
            margin-bottom: 12px;
            font-size: 0.9rem;
            color: #ff6600;  /* DraftKings orange color */
            text-align: center;
            font-weight: bold;
        }

        .betting-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        .betting-item {
            text-align: center;
            padding: 10px 8px;
            background: rgba(79, 209, 199, 0.08);
            border-radius: 8px;
            border: 1px solid rgba(79, 209, 199, 0.2);
            transition: all 0.2s ease;
        }

        .betting-item:hover {
            background: rgba(79, 209, 199, 0.12);
            border-color: rgba(79, 209, 199, 0.3);
        }

        .betting-item .line-label {
            font-size: 0.72rem;
            opacity: 0.9;
            margin-bottom: 4px;
            color: #4fd1c7;
            font-weight: 600;
        }

        .betting-item .line-value {
            font-size: 0.8rem;
            font-weight: bold;
            line-height: 1.3;
        }

        .moneyline-away, .moneyline-home {
            font-size: 0.75rem;
            margin: 1px 0;
            font-weight: 600;
        }

        .moneyline-away {
            color: #ff8a80;
        }

        .moneyline-home {
            color: #81c784;
        }

        .betting-recommendations {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid #4fd1c7;
        }

        .betting-recommendations h4 {
            margin: 0 0 12px 0;
            color: #4fd1c7;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .value-bet {
            margin: 8px 0;
            padding: 12px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.08);
            border-left: 3px solid transparent;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .value-bet:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-1px);
        }

        .value-bet.high-confidence {
            border-left-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.15);
        }

        .value-bet.medium-confidence {
            border-left-color: #ffa726;
            background: rgba(255, 167, 38, 0.15);
        }

        .value-bet.low-confidence {
            border-left-color: #66bb6a;
            background: rgba(102, 187, 106, 0.15);
        }

        .best-bet {
            margin: 8px 0;
            padding: 12px;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .no-value {
            font-style: italic;
            opacity: 0.7;
            text-align: center;
            padding: 10px;
            color: #888;
        }

        .value-bet.low-confidence {
            border-left-color: #66bb6a;
            background: rgba(102, 187, 106, 0.15);
        }

        .value-bet.positive-ev {
            border-left-color: #4fd1c7;
            background: rgba(79, 209, 199, 0.2);
            box-shadow: 0 0 8px rgba(79, 209, 199, 0.3);
        }

        .positive-ev-badge {
            background: linear-gradient(45deg, #4fd1c7, #00d4aa);
            color: white;
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: bold;
            margin-left: 5px;
        }

        .no-value-bet {
            padding: 10px;
            text-align: center;
            color: #888;
            font-style: italic;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .edge-indicator {
            font-weight: bold;
            margin-left: 4px;
        }

        .game-status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
            margin-left: 8px;
        }

        .badge-scheduled {
            background: rgba(108, 117, 125, 0.2);
            color: #6c757d;
            border: 1px solid rgba(108, 117, 125, 0.3);
        }

        .badge-live {
            background: rgba(220, 53, 69, 0.2);
            color: #dc3545;
            border: 1px solid rgba(220, 53, 69, 0.4);
            animation: pulse 2s infinite;
        }

        .badge-final {
            background: rgba(40, 167, 69, 0.2);
            color: #28a745;
            border: 1px solid rgba(40, 167, 69, 0.4);
        }

        .badge-delayed {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.4);
        }

        .badge-unknown {
            background: rgba(255, 255, 255, 0.1);
            color: #adb5bd;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .game-time {
            font-size: 0.85rem;
            opacity: 0.8;
            margin-top: 4px;
        }

        .live-score {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            padding: 8px;
            background: rgba(220, 53, 69, 0.1);
            border-radius: 6px;
            border-left: 3px solid #dc3545;
        }

        .live-score .team-score {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .final-analysis {
            margin-top: 10px;
            padding: 10px;
            background: rgba(40, 167, 69, 0.1);
            border-radius: 8px;
            border-left: 3px solid #28a745;
        }

        .final-analysis h5 {
            color: #28a745;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .analysis-item {
            margin: 4px 0;
            font-size: 0.8rem;
            padding: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .analysis-correct {
            color: #28a745;
        }

        .analysis-incorrect {
            color: #dc3545;
        }

        .betting-comparison {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .betting-comparison h6 {
            margin: 5px 0 8px 0;
            font-size: 0.9rem;
            color: #ffd700;
        }

        .betting-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .section-title {
            color: #4fd1c7;
            font-size: 1.2rem;
            margin: 20px 0 15px 0;
            padding: 10px 15px;
            background: rgba(79, 209, 199, 0.1);
            border-left: 4px solid #4fd1c7;
            border-radius: 5px;
        }

        .btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn.secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .prediction-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .prediction-item .value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #4fd1c7;
        }

        .prediction-item .label {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2rem;
        }

        .error {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid rgba(255, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: white;
            cursor: pointer;
        }

        .recommendations {
            margin-top: 20px;
        }

        .recommendation {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .recommendation.high-confidence {
            border-left: 4px solid #4fd1c7;
        }

        .recommendation.medium-confidence {
            border-left: 4px solid #f39c12;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .games-header {
                flex-direction: column;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚öæ MLB-Betting</h1>
            <p>Advanced MLB Prediction System with Real-Time Betting Analysis</p>
            <p style="font-size: 0.9rem; opacity: 0.8; margin-top: 5px;">
                üìä Comprehensive Analysis Since August 7th ‚Ä¢ Updated Daily ‚Ä¢ {{ comprehensive_stats.total_games_analyzed or 0 }} Games Tracked
            </p>
            
            <!-- Admin Navigation -->
            <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                <a href="/admin" style="display: inline-block; padding: 8px 16px; background: rgba(255, 215, 0, 0.2); color: #FFD700; text-decoration: none; border-radius: 8px; border: 1px solid #FFD700; font-size: 0.9rem; font-weight: bold; transition: all 0.3s ease;" 
                   onmouseover="this.style.background='rgba(255, 215, 0, 0.3)'; this.style.transform='translateY(-2px)'" 
                   onmouseout="this.style.background='rgba(255, 215, 0, 0.2)'; this.style.transform='translateY(0)'">
                    üéØ Tuning Dashboard
                </a>
                <button id="run-automation-btn" onclick="runDailyAutomation()" style="padding: 8px 16px; background: rgba(79, 209, 199, 0.2); color: #4fd1c7; border: 1px solid #4fd1c7; border-radius: 8px; font-size: 0.9rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease;" 
                        onmouseover="this.style.background='rgba(79, 209, 199, 0.3)'; this.style.transform='translateY(-2px)'" 
                        onmouseout="this.style.background='rgba(79, 209, 199, 0.2)'; this.style.transform='translateY(0)'">
                    üöÄ Run Daily Update
                </button>
                <button id="refresh-stats-btn" onclick="refreshDashboardStats()" style="padding: 8px 16px; background: rgba(156, 163, 175, 0.2); color: #9ca3af; border: 1px solid #9ca3af; border-radius: 8px; font-size: 0.9rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease; margin-left: 8px;" 
                        onmouseover="this.style.background='rgba(156, 163, 175, 0.3)'; this.style.transform='translateY(-2px)'" 
                        onmouseout="this.style.background='rgba(156, 163, 175, 0.2)'; this.style.transform='translateY(0)'">
                    üìä Refresh Stats
                </button>
                <button id="init-system-btn" onclick="initializeSystem()" style="padding: 8px 16px; background: rgba(34, 197, 94, 0.2); color: #22c55e; border: 1px solid #22c55e; border-radius: 8px; font-size: 0.9rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease; margin-left: 8px;" 
                        onmouseover="this.style.background='rgba(34, 197, 94, 0.3)'; this.style.transform='translateY(-2px)'" 
                        onmouseout="this.style.background='rgba(34, 197, 94, 0.2)'; this.style.transform='translateY(0)'">
                    ‚ö° Load Real MLB Data
                </button>
            </div>
        </div>

        <div id="summary-stats" class="stats-grid">
            <a href="/historical-analysis" class="stat-card clickable-stat">
                <h3>{{ comprehensive_stats.total_games_analyzed or 0 }}</h3>
                <p>Total Games Tracked</p>
                <small>Since {{ comprehensive_stats.date_range.start or 'Aug 15' }} ({{ comprehensive_stats.date_range.days_of_data or 0 }} days)</small>
            </a>
            <a href="/historical-analysis" class="stat-card clickable-stat">
                <h3>{{ comprehensive_stats.betting_performance.winner_accuracy_pct or 0 }}%</h3>
                <p>Winner Prediction Accuracy</p>
                <small>{{ comprehensive_stats.betting_performance.winner_predictions_correct or 0 }}/{{ comprehensive_stats.betting_performance.games_analyzed or 0 }} correct predictions</small>
            </a>
            <a href="/historical-analysis" class="stat-card clickable-stat">
                <h3>${{ comprehensive_stats.betting_performance.total_profit or 0 }}</h3>
                <p>Total Profit (Since 8/15)</p>
                <small>{{ comprehensive_stats.betting_performance.roi_percentage or 0 }}% ROI on {{ comprehensive_stats.betting_performance.total_bets_placed or 0 }} bets</small>
            </a>
            <a href="/historical-analysis" class="stat-card clickable-stat">
                <h3>{{ comprehensive_stats.betting_performance.total_accuracy_pct or 0 }}%</h3>
                <p>Betting Recommendations</p>
                <small>{{ comprehensive_stats.betting_performance.total_predictions_correct or 0 }} winning bets of {{ comprehensive_stats.betting_performance.total_bets_placed or 0 }} placed</small>
            </a>
            <div class="stat-card" id="tbd-monitor-card">
                <h3 id="tbd-status-indicator">üîç</h3>
                <p>TBD Monitor</p>
                <small id="tbd-status-text">Loading...</small>
                <div style="margin-top: 8px;">
                    <button class="btn-small" onclick="checkTBD()" id="tbd-check-btn">Check Now</button>
                </div>
            </div>
        </div>

        <div class="games-section">
            <div class="games-header">
                <h2>Today's MLB Games</h2>
                <div class="date-selector">
                    <input type="date" id="game-date" style="display: none;" />
                    <button class="btn" onclick="loadToday()">Refresh</button>
                    <button class="btn secondary" onclick="refreshBettingLines()" id="refresh-betting-lines-btn">üí∞ Update Betting Lines</button>
                    <button class="btn secondary" onclick="goToHistoricalAnalysis()">üìä Historical Analysis</button>
                    <button class="btn secondary" onclick="goToBettingGuidance()">üéØ Betting Guidance</button>
                </div>
            </div>

            <!-- Live Games Section -->
            <div id="live-games-section" style="display: none;">
                <h3 class="section-title">üî¥ Live Games</h3>
                <div id="live-games-container" class="games-grid"></div>
            </div>

            <!-- Upcoming Games Section -->
            <div id="upcoming-games-section" style="display: none;">
                <h3 class="section-title">‚è∞ Upcoming Games</h3>
                <div id="upcoming-games-container" class="games-grid"></div>
            </div>

            <div id="games-container">
                <div class="loading">Loading today's games...</div>
            </div>

            <!-- Completed Games Section - Moved to bottom -->
            <div id="completed-games-section" style="display: none; margin-top: 30px;">
                <h3 class="section-title">‚úÖ Completed Games</h3>
                <div id="completed-games-container" class="games-grid"></div>
            </div>
        </div>
    </div>

    <!-- Prediction Modal -->
    <div id="prediction-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">Game Prediction</h2>
                <button class="close-btn" onclick="closeModal()">&times;</button>
            </div>
            <div id="modal-body">
                Loading prediction...
            </div>
        </div>
    </div>

    <script>
        // Get user's local date, not UTC date
        let currentDate = new Date();
        let localDateString = currentDate.getFullYear() + '-' + 
                              String(currentDate.getMonth() + 1).padStart(2, '0') + '-' + 
                              String(currentDate.getDate()).padStart(2, '0');
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('game-date').value = localDateString;
            loadSummary();
            loadTodaysGames();
            
            // Start live updates for games in progress
            startLiveUpdates();
            
            // Initialize TBD monitoring
            updateTBDStatus();
            
            // Initialize live dashboard stats
            loadLiveDashboardStats();
            
            // Update TBD status every 5 minutes
            setInterval(updateTBDStatus, 300000);
            
            // Update dashboard stats every 2 minutes
            setInterval(loadLiveDashboardStats, 120000);
        });

        // üî• LIVE DASHBOARD STATS WIDGET
        async function loadLiveDashboardStats() {
            try {
                console.log('üîÑ Loading live dashboard stats from historical analysis API...');
                
                const response = await fetch('/api/historical-analysis/cumulative');
                if (!response.ok) {
                    console.warn('‚ùå Historical analysis API not available, keeping server-side stats');
                    return;
                }
                
                const apiData = await response.json();
                if (!apiData.success || !apiData.data) {
                    console.warn('‚ùå Historical analysis API returned error:', apiData.message);
                    return;
                }
                
                const data = apiData.data;
                const betting = data.betting_performance || {};
                const analysis = data.analysis_period || '2025-08-15 to 2025-08-25';
                
                console.log('‚úÖ Live dashboard data loaded:', {
                    totalRecommendations: betting.total_recommendations,
                    accuracy: betting.overall_accuracy,
                    roi: betting.roi_percentage
                });
                
                // Update the dashboard stats with live data
                updateDashboardStat(0, {
                    value: betting.total_recommendations || 0,
                    subtitle: `Since ${analysis.split(' to ')[0]} (${data.total_dates_analyzed || 0} days)`
                });
                
                updateDashboardStat(1, {
                    value: `${(betting.overall_accuracy || 0).toFixed(2)}%`,
                    subtitle: `${betting.correct_recommendations || 0}/${betting.total_recommendations || 0} correct predictions`
                });
                
                updateDashboardStat(2, {
                    value: `$${(betting.net_profit || 0).toFixed(2)}`,
                    subtitle: `${(betting.roi_percentage || 0).toFixed(2)}% ROI on ${betting.total_recommendations || 0} bets`
                });
                
                updateDashboardStat(3, {
                    value: `${(betting.overall_accuracy || 0).toFixed(2)}%`,
                    subtitle: `${betting.correct_recommendations || 0} winning bets of ${betting.total_recommendations || 0} placed`
                });
                
                // Add visual indicator that data is live
                const header = document.querySelector('.header p');
                if (header && !header.textContent.includes('üî¥ LIVE')) {
                    header.innerHTML = header.innerHTML.replace('üìä Comprehensive Analysis', 'üî¥ LIVE Analysis');
                }
                
                console.log('‚úÖ Dashboard stats updated with live data');
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Could not load live dashboard stats:', error);
                // Keep server-side stats if API fails
            }
        }
        
        function updateDashboardStat(index, data) {
            const statCards = document.querySelectorAll('#summary-stats .stat-card h3');
            const subtitleCards = document.querySelectorAll('#summary-stats .stat-card small');
            
            if (statCards[index]) {
                statCards[index].textContent = data.value;
                // Add a subtle animation to show the update
                statCards[index].style.transition = 'all 0.3s ease';
                statCards[index].style.transform = 'scale(1.05)';
                statCards[index].style.color = '#4fd1c7';
                setTimeout(() => {
                    statCards[index].style.transform = 'scale(1)';
                    statCards[index].style.color = '';
                }, 300);
            }
            
            if (subtitleCards[index] && data.subtitle) {
                subtitleCards[index].textContent = data.subtitle;
            }
        }

        function goToHistoricalAnalysis() {
            // Navigate to historical analysis page
            window.location.href = '/historical-analysis';
        }

        function goToBettingGuidance() {
            // Navigate to improved analysis page with Kelly Criterion betting guidance
            window.location.href = '/improved-analysis';
        }

        function loadToday() {
            currentDate = new Date();
            localDateString = currentDate.getFullYear() + '-' + 
                              String(currentDate.getMonth() + 1).padStart(2, '0') + '-' + 
                              String(currentDate.getDate()).padStart(2, '0');
            document.getElementById('game-date').value = localDateString;
            loadTodaysGames();
        }

        // Betting Lines Refresh Function
        async function refreshBettingLines() {
            const btn = document.getElementById('refresh-betting-lines-btn');
            const originalText = btn.textContent;
            
            btn.textContent = '‚è≥ Updating...';
            btn.disabled = true;
            
            try {
                // Show loading notification
                showNotification('Fetching fresh betting lines from OddsAPI...', 'info', 0);
                
                const response = await fetch('/api/refresh-betting-lines', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const linesCount = data.data.fresh_lines_count;
                    const recsGenerated = data.data.recommendations_generated;
                    const recsCount = data.data.recommendations_count;
                    
                    let message = `‚úÖ Successfully updated ${linesCount} betting lines`;
                    if (recsGenerated) {
                        message += ` and regenerated recommendations for ${recsCount} games`;
                    }
                    
                    showNotification(message, 'success', 5000);
                    
                    // Refresh the games display to show updated lines
                    setTimeout(() => {
                        loadTodaysGames();
                    }, 1000);
                    
                } else {
                    showNotification(`‚ùå Failed to update betting lines: ${data.error}`, 'error', 8000);
                }
                
            } catch (error) {
                console.error('Error refreshing betting lines:', error);
                showNotification('‚ùå Network error while updating betting lines', 'error', 8000);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        // Notification function for user feedback
        function showNotification(message, type = 'info', duration = 5000) {
            // Remove existing notifications
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(notif => notif.remove());
            
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = message;
            
            // Styling
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                border-radius: 8px;
                font-weight: bold;
                max-width: 400px;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                transition: all 0.3s ease;
                transform: translateX(100%);
            `;
            
            // Type-specific styling
            if (type === 'success') {
                notification.style.background = 'rgba(16, 185, 129, 0.9)';
                notification.style.color = 'white';
                notification.style.border = '1px solid #10b981';
            } else if (type === 'error') {
                notification.style.background = 'rgba(239, 68, 68, 0.9)';
                notification.style.color = 'white';
                notification.style.border = '1px solid #ef4444';
            } else {
                notification.style.background = 'rgba(59, 130, 246, 0.9)';
                notification.style.color = 'white';
                notification.style.border = '1px solid #3b82f6';
            }
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            // Auto-remove if duration is set
            if (duration > 0) {
                setTimeout(() => {
                    notification.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }, duration);
            }
        }

        // TBD Monitoring Functions
        async function updateTBDStatus() {
            try {
                const response = await fetch('/api/tbd-status');
                const data = await response.json();
                
                if (data.success) {
                    const status = data.status;
                    const indicator = document.getElementById('tbd-status-indicator');
                    const statusText = document.getElementById('tbd-status-text');
                    
                    if (status.tbd_games_count > 0) {
                        indicator.textContent = '‚ö†Ô∏è';
                        statusText.textContent = `${status.tbd_games_count} games with TBD pitchers`;
                    } else {
                        indicator.textContent = '‚úÖ';
                        statusText.textContent = 'All pitchers confirmed';
                    }
                    
                    // Update last check time
                    const lastCheck = new Date(status.last_check);
                    const timeStr = lastCheck.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    statusText.innerHTML += `<br>Last checked: ${timeStr}`;
                }
            } catch (error) {
                console.error('Error updating TBD status:', error);
                document.getElementById('tbd-status-indicator').textContent = '‚ùå';
                document.getElementById('tbd-status-text').textContent = 'Monitor error';
            }
        }

        async function checkTBD() {
            const btn = document.getElementById('tbd-check-btn');
            const originalText = btn.textContent;
            
            btn.textContent = 'Checking...';
            btn.disabled = true;
            
            try {
                const response = await fetch('/api/tbd-check', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    if (data.updated) {
                        // Refresh the page to show updated recommendations
                        loadToday();
                        updateTBDStatus();
                        alert('Pitcher updates found! Recommendations refreshed.');
                    } else {
                        alert('No pitcher updates found.');
                    }
                } else {
                    alert('Error checking for updates: ' + data.error);
                }
            } catch (error) {
                console.error('Error checking TBD:', error);
                alert('Error checking for pitcher updates.');
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        // Daily Automation Function
        async function runDailyAutomation() {
            const btn = document.getElementById('run-automation-btn');
            const originalText = btn.textContent;
            
            try {
                btn.textContent = 'üîÑ Starting...';
                btn.disabled = true;
                
                const response = await fetch('/api/run-daily-automation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    btn.textContent = '‚úÖ Running...';
                    alert('Daily automation started! This will update all data including betting recommendations for today. Check the console logs for progress. The page will refresh in 30 seconds.');
                    
                    // Refresh the page after 30 seconds to show updated data
                    setTimeout(() => {
                        window.location.reload();
                    }, 30000);
                } else {
                    btn.textContent = originalText;
                    btn.disabled = false;
                    alert('Error starting automation: ' + data.error);
                }
            } catch (error) {
                console.error('Error starting automation:', error);
                btn.textContent = originalText;
                btn.disabled = false;
                alert('Error starting daily automation.');
            }
        }

        // Refresh Dashboard Stats Function
        async function refreshDashboardStats() {
            const btn = document.getElementById('refresh-stats-btn');
            const originalText = btn.textContent;
            
            try {
                btn.textContent = 'üîÑ Updating...';
                btn.disabled = true;
                
                const response = await fetch('/api/update-dashboard-stats');
                const data = await response.json();
                
                if (data.status === 'success') {
                    btn.textContent = '‚úÖ Updated!';
                    
                    // Update the stats display on the page
                    const totalGamesElement = document.querySelector('.stat-card h3');
                    if (totalGamesElement && data.stats) {
                        totalGamesElement.textContent = data.stats.total_games_analyzed || 0;
                    }
                    
                    // Refresh the page to show all updated stats
                    setTimeout(() => {
                        window.location.reload();
                    }, 1500);
                } else {
                    btn.textContent = '‚ùå Error';
                    alert('Error updating stats: ' + data.message);
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.disabled = false;
                    }, 2000);
                }
            } catch (error) {
                console.error('Error refreshing stats:', error);
                btn.textContent = '‚ùå Error';
                alert('Error refreshing dashboard statistics.');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 2000);
            }
        }

        async function initializeSystem() {
            const btn = document.getElementById('init-system-btn');
            const originalText = btn.textContent;
            
            try {
                btn.textContent = 'üîÑ Fetching Real MLB Data...';
                btn.disabled = true;
                
                showNotification('üöÄ Fetching real MLB games from API...', 'info', 5000);
                
                const response = await fetch('/api/initialize-system', {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.success) {
                    btn.textContent = '‚úÖ Success!';
                    showNotification(`‚úÖ Successfully loaded ${data.games_loaded} real MLB games!`, 'success', 5000);
                    
                    // Show the games that were loaded
                    if (data.real_games && data.real_games.length > 0) {
                        const gamesList = data.real_games.join(', ');
                        console.log('Real games loaded:', gamesList);
                    }
                    
                    // Refresh the page to show the real data
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                } else {
                    btn.textContent = '‚ùå Failed';
                    showNotification(`‚ùå Failed to load real data: ${data.error}`, 'error', 8000);
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.disabled = false;
                    }, 3000);
                }
            } catch (error) {
                console.error('Error initializing system:', error);
                btn.textContent = '‚ùå Failed';
                showNotification('‚ùå Error fetching real MLB data. Check console for details.', 'error', 8000);
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 3000);
            }
        }

        function startLiveUpdates() {
            // Check for live games every 30 seconds
            setInterval(updateLiveGames, 30000);
        }

        async function updateLiveGames() {
            try {
                const date = document.getElementById('game-date').value;
                const response = await fetch(`/api/live-status?date=${date}`);
                const data = await response.json();
                
                if (data.success) {
                    const liveGames = data.games.filter(game => game.is_live || game.is_final);
                    
                    for (const liveGame of liveGames) {
                        updateGameCard(liveGame);
                    }
                    
                    // Update timestamp
                    console.log(`Live update: ${new Date().toLocaleTimeString()} - ${liveGames.length} games updated`);
                }
            } catch (error) {
                console.error('Error updating live games:', error);
            }
        }

        function updateGameCard(liveGame) {
            // Find the corresponding game card by unique game ID
            const gameId = `${liveGame.away_team}_${liveGame.home_team}_${new Date().toISOString().split('T')[0]}`;
            
            // Debug logging
            console.log(`üîç Looking for live game: ${liveGame.away_team} @ ${liveGame.home_team}`);
            console.log(`   Status: ${liveGame.status}, Live: ${liveGame.is_live}, Scores: ${liveGame.away_score}-${liveGame.home_score}`);
            
            // Try multiple selection strategies for better team name matching
            let card = document.querySelector(`[data-game-id*="${liveGame.away_team}_${liveGame.home_team}"]`);
            
            // If not found, try with normalized team names (Athletics vs Oakland Athletics)
            if (!card) {
                const normalizedAway = liveGame.away_team.replace('Oakland ', '').replace(' Athletics', '').replace('Athletics', 'Athletics');
                const normalizedHome = liveGame.home_team.replace('Oakland ', '').replace(' Athletics', '').replace('Athletics', 'Athletics');
                card = document.querySelector(`[data-game-id*="${normalizedAway}"][data-game-id*="${normalizedHome}"]`);
                console.log(`   Trying normalized names: ${normalizedAway} @ ${normalizedHome}`);
            }
            
            // If still not found, try broader search
            if (!card) {
                // Look for cards containing both team names (partial match)
                const allCards = document.querySelectorAll('.game-card[data-game-id]');
                for (const gameCard of allCards) {
                    const cardId = gameCard.getAttribute('data-game-id');
                    if (cardId && cardId.includes('Tampa Bay') && cardId.includes('Athletics')) {
                        card = gameCard;
                        console.log(`   Found via partial match: ${cardId}`);
                        break;
                    }
                }
            }
            
            if (card) {
                console.log(`‚úÖ Found game card, updating live status`);
                // Update status badge
                const statusBadge = card.querySelector('.game-status-badge');
                if (statusBadge) {
                    statusBadge.className = `game-status-badge badge-${liveGame.badge_class}`;
                    statusBadge.textContent = liveGame.status;
                    console.log(`   Updated badge to: ${liveGame.status}`);
                }
                
                // Remove existing live/final content to prevent duplicates
                let existingScore = card.querySelector('.live-score');
                if (existingScore) {
                    existingScore.remove();
                }
                
                let existingAnalysis = card.querySelector('.final-analysis');
                if (existingAnalysis) {
                    existingAnalysis.remove();
                }
                
                const gameHeader = card.querySelector('.game-header');
                if (liveGame.is_live && (liveGame.away_score !== undefined || liveGame.home_score !== undefined)) {
                    const liveScoreHtml = createLiveScoreHtml(liveGame);
                    console.log(`   Adding live score HTML: ${liveScoreHtml}`);
                    gameHeader.insertAdjacentHTML('afterend', liveScoreHtml);
                } else if (liveGame.is_final && (liveGame.away_score !== undefined || liveGame.home_score !== undefined)) {
                    // Need to get prediction data for final analysis
                    const gameId = card.querySelector('[id^="summary-"]').id.replace('summary-', '');
                    const prediction = { /* We'd need to store this somehow */ };
                    const finalScoreHtml = createFinalScoreHtml(liveGame, { prediction });
                    gameHeader.insertAdjacentHTML('afterend', finalScoreHtml);
                }
            } else {
                console.log(`‚ùå Game card not found for ${liveGame.away_team} @ ${liveGame.home_team}`);
            }
        }

        async function loadSummary() {
            try {
                const response = await fetch('/api/summary');
                const data = await response.json();
                
                if (data.success) {
                    const summary = data.summary;
                    document.getElementById('total-games').textContent = summary.total_games;
                    document.getElementById('completed-games').textContent = summary.completed_games;
                    document.getElementById('prediction-accuracy').textContent = 
                        (summary.prediction_accuracy * 100).toFixed(2) + '%';
                    document.getElementById('avg-error').textContent = 
                        summary.avg_score_error.toFixed(2);
                }
            } catch (error) {
                console.error('Error loading summary:', error);
            }
        }

        async function loadTodaysGames() {
            const date = document.getElementById('game-date').value;
            const container = document.getElementById('games-container');
            
            console.log('Loading todays games for date:', date);
            container.innerHTML = '<div class="loading">Loading today\'s games...</div>';
            
            try {
                const response = await fetch(`/api/today-games?date=${date}`);
                const data = await response.json();
                
                console.log('API Response:', data);
                console.log('Games count:', data.games?.length);
                
                if (data.success && data.games.length > 0) {
                    console.log('Processing games...');
                    
                    // Categorize games
                    const liveGames = [];
                    const upcomingGames = [];
                    const completedGames = [];
                    
                    // Track unique games to prevent duplicates
                    const uniqueGames = new Map();
                    
                    for (const game of data.games) {
                        const gameKey = `${game.away_team}_${game.home_team}_${game.date}`;
                        
                        // Only add if we haven't seen this game before
                        if (!uniqueGames.has(gameKey)) {
                            uniqueGames.set(gameKey, game);
                            
                            const liveStatus = game.live_status || {};
                            console.log(`Game: ${game.away_team} @ ${game.home_team}`);
                            console.log(`Live status:`, liveStatus);
                            
                            if (liveStatus.is_live) {
                                console.log(`Adding to live games`);
                                liveGames.push(game);
                            } else if (liveStatus.is_final) {
                                console.log(`Adding to completed games`);
                                completedGames.push(game);
                            } else {
                                console.log(`Adding to upcoming games`);
                                upcomingGames.push(game);
                            }
                        }
                    }
                    
                    // Sort games within each category
                    liveGames.sort((a, b) => {
                        // Live games: show by game time
                        const timeA = new Date(a.game_time || 0);
                        const timeB = new Date(b.game_time || 0);
                        return timeA - timeB;
                    });
                    
                    upcomingGames.sort((a, b) => {
                        // Upcoming: earliest games first
                        const timeA = new Date(a.game_time || '9999-12-31');
                        const timeB = new Date(b.game_time || '9999-12-31');
                        return timeA - timeB;
                    });
                    
                    completedGames.sort((a, b) => {
                        // Completed: most recently finished first
                        const timeA = new Date(a.game_time || 0);
                        const timeB = new Date(b.game_time || 0);
                        return timeB - timeA;
                    });
                    
                    // Display each section
                    displayGameSection('live-games', liveGames);
                    displayGameSection('upcoming-games', upcomingGames);
                    displayGameSection('completed-games', completedGames);
                    
                    // Hide main container only after sections are populated
                    container.style.display = 'none';
                    
                    console.log(`Loaded games: ${liveGames.length} live, ${upcomingGames.length} upcoming, ${completedGames.length} completed`);
                } else {
                    container.innerHTML = '<div class="error">No games found for today.</div>';
                }
            } catch (error) {
                container.innerHTML = '<div class="error">Error loading games: ' + error.message + '</div>';
            }
        }

        function displayGameSection(sectionPrefix, games) {
            const section = document.getElementById(`${sectionPrefix}-section`);
            const container = document.getElementById(`${sectionPrefix}-container`);
            
            console.log(`Displaying ${sectionPrefix} with ${games.length} games`);
            
            if (games.length > 0) {
                console.log(`Showing section: ${sectionPrefix}-section`);
                section.style.display = 'block';
                container.innerHTML = '';
                
                games.forEach((game, index) => {
                    console.log(`Creating card ${index + 1} for ${game.away_team} @ ${game.home_team}`);
                    const gameCard = createGameCard(game);
                    container.appendChild(gameCard);
                });
                
                console.log(`Added ${games.length} game cards to ${sectionPrefix}-container`);
            } else {
                console.log(`Hiding section: ${sectionPrefix}-section (no games)`);
                section.style.display = 'none';
            }
        }

        // Keep the old loadGames function for historical page
        async function loadGames() {
            const date = document.getElementById('game-date').value;
            const container = document.getElementById('games-container');
            
            container.innerHTML = '<div class="loading">Loading games...</div>';
            
            try {
                const response = await fetch(`/api/today-games?date=${date}`);
                const data = await response.json();
                
                if (data.success && data.games.length > 0) {
                    // Clear container completely to prevent duplicates
                    container.innerHTML = '';
                    
                    const gamesGrid = document.createElement('div');
                    gamesGrid.className = 'games-grid';
                    
                    // Track unique games to prevent duplicates
                    const uniqueGames = new Map();
                    
                    for (const game of data.games) {
                        const gameKey = `${game.away_team}_${game.home_team}_${game.date}`;
                        
                        // Only add if we haven't seen this game before
                        if (!uniqueGames.has(gameKey)) {
                            uniqueGames.set(gameKey, game);
                            const gameCard = createGameCard(game);
                            gamesGrid.appendChild(gameCard);
                        }
                    }
                    
                    container.appendChild(gamesGrid);
                    console.log(`Loaded ${uniqueGames.size} unique games`);
                } else {
                    container.innerHTML = '<div class="error">No games found for this date.</div>';
                }
            } catch (error) {
                container.innerHTML = '<div class="error">Error loading games: ' + error.message + '</div>';
            }
        }

        function createGameCard(game) {
            const card = document.createElement('div');
            card.className = 'game-card';
            card.setAttribute('data-game-id', game.game_id); // Add unique identifier
            card.onclick = () => loadPrediction(game.away_team, game.home_team, game.date);
            
            // Debug: log the entire game object
            console.log(`üîç CREATING CARD FOR: ${game.away_team} @ ${game.home_team}`);
            console.log('Full game object:', game);
            console.log('Pitcher data:', {
                away_pitcher: game.away_pitcher,
                home_pitcher: game.home_pitcher
            });
            console.log('Prediction data:', {
                predicted_away_score: game.predicted_away_score,
                predicted_home_score: game.predicted_home_score,
                predicted_total_runs: game.predicted_total_runs,
                away_win_probability: game.away_win_probability,
                home_win_probability: game.home_win_probability
            });
            
            // Get team assets for logos and colors
            const awayAssets = game.away_team_assets || { logo_url: game.away_logo };
            const homeAssets = game.home_team_assets || { logo_url: game.home_logo };
            
            // Get team colors for dynamic styling
            const awayColors = game.away_team_colors || { primary: '#333333', secondary: '#666666', text: '#FFFFFF' };
            const homeColors = game.home_team_colors || { primary: '#333333', secondary: '#666666', text: '#FFFFFF' };
            
            // Get live status information
            const liveStatus = game.live_status || {
                status: 'Scheduled',
                badge_class: 'scheduled',
                game_time: 'TBD',
                is_live: false,
                is_final: false
            };
            
            // Format game time - only show for scheduled games
            let displayTime = '';
            let displayStatus = liveStatus.status;
            
            // Only show time for scheduled games (not live or final)
            if (!liveStatus.is_live && !liveStatus.is_final) {
                // First, try to use the already-formatted time from live_status
                if (liveStatus.game_time && liveStatus.game_time !== 'TBD' && 
                    !liveStatus.game_time.includes('T') && !liveStatus.game_time.includes('Z')) {
                    // This is already a formatted time like "7:10 PM"
                    displayTime = liveStatus.game_time;
                } 
                // Otherwise, try to convert the raw game time
                else if (game.game_time && game.game_time !== 'TBD') {
                    try {
                        // Handle enhanced data time format: "2025-08-14T17:05:00+00:00"
                        let gameTimeString = game.game_time;
                        
                        console.log('üïê Processing game time:', gameTimeString);
                        
                        // The enhanced data should already be in proper ISO format
                        // "2025-08-14T17:05:00+00:00" is valid ISO 8601
                        const gameDate = new Date(gameTimeString);
                        
                        // Verify the date was parsed correctly
                        if (isNaN(gameDate.getTime())) {
                            console.error('‚ùå Invalid date parsed:', gameTimeString);
                            displayTime = 'TBD';
                        } else {
                            // Always convert to Central Time for consistency
                            displayTime = gameDate.toLocaleTimeString('en-US', { 
                                hour: 'numeric', 
                                minute: '2-digit',
                                hour12: true,
                                timeZone: 'America/Chicago' // Central Time
                            });
                            
                            displayTime += ' CT'; // Central Time indicator
                            
                            console.log('‚úÖ Time converted successfully:', {
                                original: gameTimeString,
                                parsed: gameDate.toISOString(),
                                central: displayTime
                            });
                        }
                    } catch (error) {
                        console.error('‚ùå Error converting game time:', error);
                        displayTime = 'TBD';
                    }
                }
            }
            
            // For live games, enhance status with inning info if available
            if (liveStatus.is_live && liveStatus.inning && liveStatus.inning_state) {
                displayStatus = `${liveStatus.inning_state} ${liveStatus.inning}`;
            }
            
            // Get real betting lines data
            const realLines = game.real_betting_lines || {};
            const moneyline = realLines.moneyline || {};
            const totalRuns = realLines.total_runs || {};
            const runLine = realLines.run_line || {};
            
            let bettingLinesHtml = '';
            // Show betting lines if we have real betting lines data
            if (game.has_real_betting_lines && Object.keys(realLines).length > 0) {
                // Format moneyline odds with proper + sign for positive values
                const formatOdds = (odds) => {
                    if (!odds) return 'N/A';
                    return odds > 0 ? `+${odds}` : `${odds}`;
                };
                
                // Format run line with proper +/- signs - handle both string and numeric formats
                const formatRunLine = (line, odds, isAway = true) => {
                    if (!line) return 'N/A';
                    
                    // Handle string format like "-1.5 (+130)"
                    if (typeof odds === 'string') {
                        return odds;
                    }
                    
                    // Handle numeric format from OddsAPI
                    if (typeof odds === 'number') {
                        const lineStr = isAway ? (line > 0 ? `+${line}` : `${line}`) : (line > 0 ? `-${line}` : `+${Math.abs(line)}`);
                        const oddsStr = odds > 0 ? `+${odds}` : `${odds}`;
                        return `${lineStr} (${oddsStr})`;
                    }
                    
                    return 'N/A';
                };
                
                bettingLinesHtml = `
                    <div class="betting-lines">
                        <h4>DraftKings Betting Lines</h4>
                        <div class="betting-grid">
                            <div class="betting-item">
                                <div class="line-label">Moneyline</div>
                                <div class="line-value">
                                    <div class="moneyline-away">${game.away_team.substring(0, 3)}: ${formatOdds(moneyline.away)}</div>
                                    <div class="moneyline-home">${game.home_team.substring(0, 3)}: ${formatOdds(moneyline.home)}</div>
                                </div>
                            </div>
                            <div class="betting-item">
                                <div class="line-label">Over/Under</div>
                                <div class="line-value">
                                    ${totalRuns.line ? `${totalRuns.line}` : 'N/A'}<br>
                                    ${totalRuns.over && totalRuns.under ? `O: ${formatOdds(totalRuns.over)} / U: ${formatOdds(totalRuns.under)}` : ''}
                                </div>
                            </div>
                            <div class="betting-item">
                                <div class="line-label">Run Line</div>
                                <div class="line-value">
                                    <div class="moneyline-away">${game.away_team.substring(0, 3)}: ${formatRunLine(runLine.line, runLine.away, true)}</div>
                                    <div class="moneyline-home">${game.home_team.substring(0, 3)}: ${formatRunLine(runLine.line, runLine.home, false)}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            card.innerHTML = `
                <div class="game-header">
                    <div class="game-teams">
                        <div class="team-info" style="background: linear-gradient(135deg, ${awayColors.primary}, ${awayColors.secondary}); color: ${awayColors.text}; border-radius: 8px; padding: 8px; margin-right: 5px;">
                            <img src="${awayAssets.logo_url || ''}" alt="${game.away_team}" class="team-logo" />
                            <span class="team-name">${game.away_team}</span>
                        </div>
                        <span class="vs-separator">@</span>
                        <div class="team-info" style="background: linear-gradient(135deg, ${homeColors.primary}, ${homeColors.secondary}); color: ${homeColors.text}; border-radius: 8px; padding: 8px; margin-left: 5px;">
                            <img src="${homeAssets.logo_url || ''}" alt="${game.home_team}" class="team-logo" />
                            <span class="team-name">${game.home_team}</span>
                        </div>
                    </div>
                    <div class="game-info">
                        ${displayTime ? `<div class="game-time">${displayTime}</div>` : ''}
                        <span class="game-status-badge badge-${liveStatus.badge_class}">${displayStatus}</span>
                    </div>
                </div>
                <div class="starting-pitchers">
                    <div class="pitcher-matchup">
                        <div class="away-pitcher">
                            <span class="pitcher-label">Starting Pitcher:</span>
                            <span class="pitcher-name">${game.away_pitcher || 'TBD'}</span>
                        </div>
                        <span class="vs-separator">vs</span>
                        <div class="home-pitcher">
                            <span class="pitcher-label">Starting Pitcher:</span>
                            <span class="pitcher-name">${game.home_pitcher || 'TBD'}</span>
                        </div>
                    </div>
                </div>
                ${liveStatus.is_live ? createLiveScoreHtml(liveStatus, awayColors, homeColors) : ''}
                ${liveStatus.is_final ? createFinalScoreHtml(liveStatus, game, awayColors, homeColors) : ''}
                <div class="prediction-summary" id="summary-${game.game_id}">
                    ${createPredictionSummaryHtml(game)}
                </div>
                ${game.betting_recommendations && (game.betting_recommendations.value_bets || game.betting_recommendations.recommendations) ? createBettingRecommendationsHtml(game.betting_recommendations, game.away_team, game.home_team) : ''}
                ${bettingLinesHtml}
            `;
            
            return card;
        }

        function createPredictionSummaryHtml(game) {
            // Use prediction data directly from the game object
            const predictedAwayScore = game.predicted_away_score || 0;
            const predictedHomeScore = game.predicted_home_score || 0;
            const awayWinProb = game.away_win_probability || 0;
            const homeWinProb = game.home_win_probability || 0;
            const predictedWinner = game.predicted_winner || '';
            
            console.log('Creating prediction summary for:', game.away_team, '@', game.home_team);
            console.log('Prediction data:', { predictedAwayScore, predictedHomeScore, awayWinProb, homeWinProb });
            
            // If no prediction data, show placeholder
            if (!predictedAwayScore && !predictedHomeScore) {
                console.log('No prediction data found, showing placeholder');
                return `
                    <div class="prediction-item">
                        <div class="value">--</div>
                        <div class="label">No Prediction</div>
                    </div>
                `;
            }
            
            console.log('Creating prediction summary with data');
            return `
                <div class="prediction-item">
                    <div class="value">${predictedAwayScore}</div>
                    <div class="label">${game.away_team.split(' ').pop()}</div>
                </div>
                <div class="prediction-item">
                    <div class="value">${predictedHomeScore}</div>
                    <div class="label">${game.home_team.split(' ').pop()}</div>
                </div>
                <div class="prediction-item">
                    <div class="value">${homeWinProb.toFixed(2)}%</div>
                    <div class="label">Home Win</div>
                </div>
            `;
        }

        function createLiveScoreHtml(liveStatus, awayColors = null, homeColors = null) {
            if (!liveStatus.away_score && !liveStatus.home_score) {
                return '';
            }
            
            // Default colors if not provided
            const defaultAwayColors = awayColors || { primary: '#333333', secondary: '#666666', text: '#FFFFFF' };
            const defaultHomeColors = homeColors || { primary: '#444444', secondary: '#777777', text: '#FFFFFF' };
            
            // Create inning display for live games
            let inningDisplay = 'LIVE';
            if (liveStatus.inning && liveStatus.inning_state) {
                inningDisplay = `${liveStatus.inning_state} ${liveStatus.inning}`;
            }
            
            return `
                <div class="live-score">
                    <div style="background: ${defaultAwayColors.primary}; color: ${defaultAwayColors.text}; padding: 4px 8px; border-radius: 4px; border: 1px solid ${defaultAwayColors.secondary};">
                        <span class="team-score">${liveStatus.away_score || 0}</span>
                    </div>
                    <div style="color: #dc3545; font-weight: bold; font-size: 0.9em;">${inningDisplay}</div>
                    <div style="background: ${defaultHomeColors.primary}; color: ${defaultHomeColors.text}; padding: 4px 8px; border-radius: 4px; border: 1px solid ${defaultHomeColors.secondary};">
                        <span class="team-score">${liveStatus.home_score || 0}</span>
                    </div>
                </div>
            `;
        }

        function createFinalScoreHtml(liveStatus, game, awayColors = null, homeColors = null) {
            if (!liveStatus.away_score && !liveStatus.home_score) {
                return '';
            }
            
            // Default colors if not provided
            const defaultAwayColors = awayColors || { primary: '#333333', secondary: '#666666', text: '#FFFFFF' };
            const defaultHomeColors = homeColors || { primary: '#444444', secondary: '#777777', text: '#FFFFFF' };
            
            // Use game data directly as it contains prediction info
            const predictedAwayScore = game.predicted_away_score || 0;
            const predictedHomeScore = game.predicted_home_score || 0;
            const predictedTotalRuns = game.predicted_total_runs || (predictedAwayScore + predictedHomeScore);
            
            // Debug: Check what's happening with predicted total runs
            console.log(`üêõ DEBUGGING Total Runs for ${game.away_team} @ ${game.home_team}:`);
            console.log(`  - game.predicted_total_runs: ${game.predicted_total_runs}`);
            console.log(`  - predictedAwayScore: ${predictedAwayScore}`);
            console.log(`  - predictedHomeScore: ${predictedHomeScore}`);
            console.log(`  - calculated predictedTotalRuns: ${predictedTotalRuns}`);
            
            const actualAwayScore = liveStatus.away_score || 0;
            const actualHomeScore = liveStatus.home_score || 0;
            const actualTotalRuns = actualAwayScore + actualHomeScore;
            
            // Winner prediction accuracy
            const predictedWinner = predictedAwayScore > predictedHomeScore ? 'away' : 'home';
            const actualWinner = actualAwayScore > actualHomeScore ? 'away' : 'home';
            const winnerCorrect = predictedWinner === actualWinner;
            
            // Score difference analysis
            const awayScoreDiff = Math.abs(actualAwayScore - predictedAwayScore);
            const homeScoreDiff = Math.abs(actualHomeScore - predictedHomeScore);
            const avgScoreDiff = (awayScoreDiff + homeScoreDiff) / 2;
            
            // Total runs analysis
            const totalRunsDiff = Math.abs(actualTotalRuns - predictedTotalRuns);
            const totalRunsAccuracy = totalRunsDiff <= 1 ? 'Excellent' : 
                                     totalRunsDiff <= 2 ? 'Good' : 
                                     totalRunsDiff <= 3 ? 'Fair' : 'Poor';
            
            // Use the original bet_grade if available (from enhanced grading), otherwise calculate
            let grade = game.bet_grade || '';
            let gradePoints = 0;
            
            // If no bet_grade available, calculate traditional accuracy grade
            if (!grade) {
                if (winnerCorrect) gradePoints += 50;
                if (avgScoreDiff <= 1) gradePoints += 30;
                else if (avgScoreDiff <= 2) gradePoints += 20;
                else if (avgScoreDiff <= 3) gradePoints += 10;
                if (totalRunsDiff <= 1) gradePoints += 20;
                else if (totalRunsDiff <= 2) gradePoints += 15;
                else if (totalRunsDiff <= 3) gradePoints += 10;
                
                if (gradePoints >= 90) grade = 'A+';
                else if (gradePoints >= 80) grade = 'A';
                else if (gradePoints >= 70) grade = 'B+';
                else if (gradePoints >= 60) grade = 'B';
                else if (gradePoints >= 50) grade = 'C';
                else grade = 'D';
            }
            
            // Betting line analysis (if comprehensive analysis available)
            let bettingAnalysisHtml = '';
            const postGameAnalysis = game.post_game_analysis;
            if (postGameAnalysis && postGameAnalysis.betting_analysis) {
                const bettingAnalysis = postGameAnalysis.betting_analysis;
                
                let marketVsModelHtml = '';
                if (bettingAnalysis.betting_favorite) {
                    const favoriteWon = bettingAnalysis.favorite_won;
                    const modelBeatMarket = bettingAnalysis.model_beat_market;
                    
                    marketVsModelHtml = `
                        <div class="analysis-item ${favoriteWon ? 'analysis-correct' : 'analysis-incorrect'}">
                            <strong>Market Favorite:</strong> ${favoriteWon ? '‚úÖ Won' : '‚ùå Lost'}
                        </div>
                        <div class="analysis-item ${modelBeatMarket ? 'analysis-correct' : 'analysis-incorrect'}">
                            <strong>Model vs Market:</strong> ${modelBeatMarket ? '‚úÖ Beat Market' : '‚ùå Followed Market'}
                        </div>
                    `;
                }
                
                let totalBetHtml = '';
                if (bettingAnalysis.total_analysis) {
                    const totalAnalysis = bettingAnalysis.total_analysis;
                    const modelCorrectTotal = totalAnalysis.model_correct_total;
                    
                    totalBetHtml = `
                        <div class="analysis-item ${modelCorrectTotal ? 'analysis-correct' : 'analysis-incorrect'}">
                            <strong>Total Bet:</strong> ${modelCorrectTotal ? '‚úÖ Correct' : '‚ùå Incorrect'} (Line: ${totalAnalysis.line})
                        </div>
                    `;
                }
                
                if (marketVsModelHtml || totalBetHtml) {
                    bettingAnalysisHtml = `
                        <div class="betting-comparison">
                            <h6>üìà Model vs Market Performance</h6>
                            <div class="betting-grid">
                                ${marketVsModelHtml}
                                ${totalBetHtml}
                            </div>
                        </div>
                    `;
                }
            }
            
            return `
                <div class="live-score">
                    <div>
                        <span style="color: #ff6b6b;">${liveStatus.away_team ? liveStatus.away_team.substring(0, 3) : 'AWAY'}</span>
                        <span class="team-score">${actualAwayScore}</span>
                    </div>
                    <div style="color: #28a745; font-weight: bold;">FINAL</div>
                    <div>
                        <span style="color: #4ecdc4;">${liveStatus.home_team ? liveStatus.home_team.substring(0, 3) : 'HOME'}</span>
                        <span class="team-score">${actualHomeScore}</span>
                    </div>
                </div>
                <div class="final-analysis">
                    <h5>üìä Prediction Analysis (Grade: ${grade})</h5>
                    <div class="analysis-grid">
                        <div class="analysis-item ${winnerCorrect ? 'analysis-correct' : 'analysis-incorrect'}">
                            <strong>Winner:</strong> ${winnerCorrect ? '‚úÖ Correct' : '‚ùå Incorrect'}
                        </div>
                        <div class="analysis-item">
                            <strong>Score Error:</strong> ¬±${avgScoreDiff.toFixed(2)} runs
                        </div>
                        <div class="analysis-item">
                            <strong>Total Runs:</strong> ${actualTotalRuns} (predicted ${predictedTotalRuns})
                        </div>
                        <div class="analysis-item">
                            <strong>Total Accuracy:</strong> ¬±${totalRunsDiff} runs (${totalRunsAccuracy})
                        </div>
                    </div>
                    ${bettingAnalysisHtml}
                </div>
            `;
        }

        async function loadQuickPrediction(awayTeam, homeTeam, date, gameId) {
            try {
                const response = await fetch(`/api/prediction/${awayTeam}/${homeTeam}?date=${date}`);
                const data = await response.json();
                
                if (data.success) {
                    const pred = data.prediction;  // data is directly in prediction object
                    const meta = data.prediction.meta;
                    
                    const summaryElement = document.getElementById(`summary-${gameId}`);
                    if (summaryElement) {
                        // Get pitcher information for display
                        const awayPitcher = pred.away_pitcher || 'TBD';
                        const homePitcher = pred.home_pitcher || 'TBD';
                        
                        summaryElement.innerHTML = `
                            <div class="prediction-item">
                                <div class="value">${pred.predicted_away_score}</div>
                                <div class="label">${awayTeam.split(' ').pop()}</div>
                            </div>
                            <div class="prediction-item">
                                <div class="value">${pred.predicted_home_score}</div>
                                <div class="label">${homeTeam.split(' ').pop()}</div>
                            </div>
                            <div class="prediction-item">
                                <div class="value">${pred.home_win_probability.toFixed(2)}%</div>
                                <div class="label">Home Win</div>
                            </div>
                        `;
                        
                        // Add quick betting tip if available
                        const bettingRecs = data.betting_recommendations;  // Get from top level of data object
                        if (bettingRecs && bettingRecs.best_bet) {
                            const bestBet = bettingRecs.best_bet;
                            const icon = bestBet.edge_rating || 'üéØ';
                            summaryElement.innerHTML += `
                                <div class="prediction-item betting-tip" style="background: rgba(79, 209, 199, 0.2); border-left: 2px solid #4fd1c7;">
                                    <div class="value" style="font-size: 0.8em;">${icon} ${bestBet.recommendation || bestBet.bet || 'Value Bet'}</div>
                                    <div class="label" style="font-size: 0.7em;">Best Bet</div>
                                </div>
                            `;
                        }
                        
                        // Betting recommendations are now included in initial load, no need to add dynamically
                        // This prevents double display issues
                    }
                    
                    // Update betting lines if available (only if not already present)
                    const bettingData = data.prediction.betting_data;
                    if (bettingData) {
                        const gameCard = document.querySelector(`#summary-${gameId}`).closest('.game-card');
                        const existingLines = gameCard.querySelector('.betting-lines');
                        
                        if (gameCard && !existingLines) {
                            updateGameCardBetting(gameId, bettingData, awayTeam, homeTeam);
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading quick prediction:', error);
            }
        }

        function updateGameCardBetting(gameId, bettingData, awayTeam, homeTeam) {
            // Find the game card and check if it already has betting lines
            const gameCard = document.querySelector(`#summary-${gameId}`).closest('.game-card');
            
            // Double-check if betting lines already exist to prevent duplicates
            if (!gameCard || gameCard.querySelector('.betting-lines')) {
                return; // Already has betting lines or can't find game card
            }
            
            const moneyline = bettingData.moneyline || {};
            const total = bettingData.total || {};
            const spread = bettingData.spread || {};
            
            const bettingLinesHtml = `
                <div class="betting-lines">
                    <h4>Betting Lines</h4>
                    <div class="betting-grid">
                        <div class="betting-item">
                            <div class="line-label">Moneyline</div>
                            <div class="line-value">
                                <div class="moneyline-away">${awayTeam.substring(0, 3)}: ${moneyline.away || 'N/A'}</div>
                                <div class="moneyline-home">${homeTeam.substring(0, 3)}: ${moneyline.home || 'N/A'}</div>
                            </div>
                        </div>
                        <div class="betting-item">
                            <div class="line-label">Total</div>
                            <div class="line-value">
                                ${total.line ? `O/U ${total.line}` : 'N/A'}
                            </div>
                        </div>
                        <div class="betting-item">
                            <div class="line-label">Spread</div>
                            <div class="line-value">
                                ${spread.line ? `${spread.line > 0 ? '+' : ''}${spread.line}` : 'N/A'}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Insert betting lines after the prediction summary
            const summaryElement = document.getElementById(`summary-${gameId}`);
            summaryElement.insertAdjacentHTML('afterend', bettingLinesHtml);
        }

        function createBettingRecommendationsHtml(bettingRecs, awayTeam, homeTeam) {
            if (!bettingRecs || (!bettingRecs.value_bets && !bettingRecs.recommendations)) {
                return '';
            }

            let html = '<div class="betting-recommendations" data-added="true">';
            html += '<h4>üí∞ Betting Recommendations</h4>';
            
            // Add summary if available
            if (bettingRecs.summary) {
                html += `<div style="font-size: 0.9em; color: #888; margin-bottom: 10px;">${bettingRecs.summary}</div>`;
            }

            // Handle new enhanced format with value_bets array
            if (bettingRecs.value_bets && bettingRecs.value_bets.length > 0) {
                bettingRecs.value_bets.forEach(bet => {
                    const confidenceClass = bet.confidence === 'HIGH' ? 'high-confidence' : 
                                          bet.confidence === 'MEDIUM' ? 'medium-confidence' : 'low-confidence';
                    
                    // Add positive EV class if applicable
                    const isPositiveEV = bet.expected_value && bet.expected_value > 0;
                    const cssClasses = isPositiveEV ? `${confidenceClass} positive-ev` : confidenceClass;
                    
                    const icon = bet.edge_rating || (bet.confidence === 'HIGH' ? 'üî•' : 
                               bet.confidence === 'MEDIUM' ? '‚ö°' : 'üí°');
                    
                    // Display the recommendation with enhanced formatting
                    const recommendation = bet.recommendation || `${bet.direction?.toUpperCase()} ${bet.line}`;
                    const edgeText = typeof bet.edge === 'number' ? `${bet.edge.toFixed(2)}% edge` : 
                                    bet.edge ? bet.edge : 
                                    bet.confidence ? `${bet.confidence} CONFIDENCE` : 'Value Bet';
                    
                    // Format Expected Value display - LIMITED TO 2 DECIMAL PLACES MAX
                    let evDisplay = '';
                    let evBadge = '';
                    if (bet.expected_value !== undefined && bet.expected_value !== null) {
                        const evPercent = (bet.expected_value * 100).toFixed(2);
                        const evColor = bet.expected_value > 0 ? '#4fd1c7' : '#ff6b6b';
                        const evSign = bet.expected_value > 0 ? '+' : '';
                        evDisplay = `<span style="color: ${evColor}; font-weight: bold;">EV: ${evSign}${evPercent}%</span>`;
                        
                        // Add +EV badge for positive expected value
                        if (bet.expected_value > 0) {
                            evBadge = `<span class="positive-ev-badge">+EV</span>`;
                        }
                    }
                    
                    html += `
                        <div class="value-bet ${cssClasses}" title="${bet.reasoning || 'No details available'}">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 5px;">
                                    <span>${icon}</span>
                                    <strong>${recommendation}</strong>
                                    ${evBadge}
                                </div>
                                <div style="display: flex; flex-direction: column; align-items: flex-end; font-size: 0.8em;">
                                    <span style="color: #4fd1c7;">${edgeText}</span>
                                    ${evDisplay ? `<div>${evDisplay}</div>` : ''}
                                    ${bet.estimated_odds && bet.estimated_odds !== 'N/A' ? `<span style="color: #888;">${bet.estimated_odds}</span>` : ''}
                                </div>
                            </div>
                            <div style="font-size: 0.85em; color: #ccc; margin-top: 3px; line-height: 1.2;">
                                ${bet.reasoning}
                            </div>
                        </div>
                    `;
                });
            }
            // Handle legacy format
            else if (bettingRecs.recommendations && bettingRecs.recommendations.length > 0) {
                bettingRecs.recommendations.forEach(rec => {
                    if (rec !== "No significant value bets identified") {
                        html += `<div class="value-bet medium-confidence">‚ö° ${rec}</div>`;
                    }
                });
            }

            // If no value bets found
            if ((!bettingRecs.value_bets || bettingRecs.value_bets.length === 0) && 
                (!bettingRecs.recommendations || bettingRecs.recommendations.every(r => r.includes("No significant")))) {
                html += '<div class="no-value-bet">üí° No significant value bets identified - consider live betting opportunities</div>';
            }

            // Add best bet highlight if available
            if (bettingRecs.best_bet) {
                html += `
                    <div style="margin-top: 10px; padding: 8px; background: rgba(79, 209, 199, 0.2); border-left: 3px solid #4fd1c7; border-radius: 4px;">
                        <strong>üéØ Best Bet:</strong> ${bettingRecs.best_bet.recommendation}
                    </div>
                `;
            }

            html += '</div>';
            return html;
        }

        async function loadPrediction(awayTeam, homeTeam, date) {
            document.getElementById('modal-body').innerHTML = 'Loading detailed prediction...';
            document.getElementById('prediction-modal').style.display = 'block';
            
            console.log(`üîç Loading prediction for: ${awayTeam} @ ${homeTeam} on ${date}`);
            
            try {
                const url = `/api/prediction/${awayTeam}/${homeTeam}?date=${date}`;
                console.log('API URL:', url);
                
                const response = await fetch(url);
                const data = await response.json();
                
                console.log('Prediction API response:', data);
                
                if (data.success) {
                    const prediction = data.prediction;
                    
                    console.log('Betting recommendations in modal:', data.betting_recommendations);
                    
                    // Update modal title with team logos
                    const awayAssets = prediction.away_team_assets || { logo_url: data.game.away_logo };
                    const homeAssets = prediction.home_team_assets || { logo_url: data.game.home_logo };
                    
                    document.getElementById('modal-title').innerHTML = `
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <img src="${awayAssets.logo_url || ''}" alt="${awayTeam}" style="width: 24px; height: 24px;" />
                                <span>${awayTeam}</span>
                            </div>
                            <span>@</span>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <img src="${homeAssets.logo_url || ''}" alt="${homeTeam}" style="width: 24px; height: 24px;" />
                                <span>${homeTeam}</span>
                            </div>
                        </div>
                    `;
                    
                    displayPredictionDetails(data);
                } else {
                    document.getElementById('modal-body').innerHTML = 
                        '<div class="error">Error loading prediction: ' + data.error + '</div>';
                }
            } catch (error) {
                document.getElementById('modal-body').innerHTML = 
                    '<div class="error">Error loading prediction: ' + error.message + '</div>';
            }
        }

        function displayPredictionDetails(data) {
            console.log('üéØ displayPredictionDetails called with:', data);
            console.log('Betting recommendations:', data.betting_recommendations);
            
            const prediction = data.prediction;  // Extract prediction from data object
            const game = data.game;  // Extract game info from data object
            const pred = prediction;  // Keep this for backward compatibility with existing code
            const meta = prediction.meta || {
                execution_time_ms: 0,
                simulations_run: prediction.simulation_count || 5000,
                data_source: prediction.model_version || 'simulation'
            };
            const recs = prediction.recommendations || [];
            
            // Extract pitcher information from game data with real factors
            const awayPitcher = { 
                name: game.away_pitcher || 'TBD', 
                factor: game.away_pitcher_factor || 1.0
            };
            const homePitcher = { 
                name: game.home_pitcher || 'TBD', 
                factor: game.home_pitcher_factor || 1.0
            };
            
            // Get team names from game data
            const awayTeam = game.away_team;
            const homeTeam = game.home_team;
            
            // Get team assets for colors
            const awayAssets = prediction.away_team_assets || {};
            const homeAssets = prediction.home_team_assets || {};
            
            let html = `
                <div class="prediction-details">
                    <div class="prediction-summary">
                        <div class="prediction-item" style="background-color: ${awayAssets.primary_color || '#4fd1c7'}22; border-left: 3px solid ${awayAssets.primary_color || '#4fd1c7'};">
                            <div class="value">${pred.predicted_away_score}</div>
                            <div class="label">${awayTeam} Score</div>
                        </div>
                        <div class="prediction-item" style="background-color: ${homeAssets.primary_color || '#4fd1c7'}22; border-left: 3px solid ${homeAssets.primary_color || '#4fd1c7'};">
                            <div class="value">${pred.predicted_home_score}</div>
                            <div class="label">${homeTeam} Score</div>
                        </div>
                        <div class="prediction-item">
                            <div class="value">${pred.predicted_total_runs}</div>
                            <div class="label">Total Runs</div>
                        </div>
                        <div class="prediction-item">
                            <div class="value">${pred.home_win_probability.toFixed(2)}%</div>
                            <div class="label">Home Win Prob</div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px;">
                        <h3>Starting Pitchers</h3>
                        <p><strong>Away:</strong> ${awayPitcher.name || 'TBD'} (Quality Factor: ${(awayPitcher.factor || 1.0).toFixed(2)})</p>
                        <p><strong>Home:</strong> ${homePitcher.name || 'TBD'} (Quality Factor: ${(homePitcher.factor || 1.0).toFixed(2)})</p>
                        <div style="font-size: 0.9em; color: #888; margin-top: 10px;">
                            <em>Factor < 1.0 = Better pitcher (allows fewer runs), Factor > 1.0 = Weaker pitcher</em>
                        </div>
                    </div>
                    
                    <!-- Add comprehensive factors section -->
                    <div style="margin-top: 20px;">
                        <h3>üìä Model Factors</h3>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 10px;">
                            ${data.factors ? `
                                <!-- Team Strengths -->
                                <div style="padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid #4fd1c7;">
                                    <div style="font-weight: bold; color: #4fd1c7; margin-bottom: 8px;">Team Strengths</div>
                                    <div style="font-size: 0.9em;">
                                        <div style="color: #ff6b6b; margin-bottom: 4px;">${awayTeam}: ${data.factors.team_strengths ? (data.factors.team_strengths.away_strength > 0 ? '+' : '') + data.factors.team_strengths.away_strength.toFixed(3) : 'N/A'}</div>
                                        <div style="color: #4ecdc4;">${homeTeam}: ${data.factors.team_strengths ? (data.factors.team_strengths.home_strength > 0 ? '+' : '') + data.factors.team_strengths.home_strength.toFixed(3) : 'N/A'}</div>
                                    </div>
                                </div>
                                
                                <!-- Bullpen Quality -->
                                <div style="padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid #ffa726;">
                                    <div style="font-weight: bold; color: #ffa726; margin-bottom: 8px;">Bullpen Quality</div>
                                    <div style="font-size: 0.9em;">
                                        <div style="color: #ff6b6b; margin-bottom: 4px;">${awayTeam}: ${data.factors.bullpen_quality ? data.factors.bullpen_quality.away_bullpen.rating + ' (' + data.factors.bullpen_quality.away_bullpen.quality_factor.toFixed(2) + ')' : 'N/A'}</div>
                                        <div style="color: #4ecdc4;">${homeTeam}: ${data.factors.bullpen_quality ? data.factors.bullpen_quality.home_bullpen.rating + ' (' + data.factors.bullpen_quality.home_bullpen.quality_factor.toFixed(2) + ')' : 'N/A'}</div>
                                    </div>
                                </div>
                                
                                <!-- Weather & Park -->
                                ${data.factors.weather_park && Object.keys(data.factors.weather_park).length > 0 ? `
                                <div style="padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid #66bb6a; grid-column: 1 / -1;">
                                    <div style="font-weight: bold; color: #66bb6a; margin-bottom: 8px;">üå§Ô∏è Weather & Park Factors</div>
                                    <div style="font-size: 0.9em; display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                                        <div>Temp: ${data.factors.weather_park.temperature}¬∞F</div>
                                        <div>Wind: ${data.factors.weather_park.wind_speed} mph</div>
                                        <div>Conditions: ${data.factors.weather_park.weather_condition}</div>
                                        <div>Park Factor: ${data.factors.weather_park.park_factor.toFixed(2)}</div>
                                        <div>Runs Factor: ${data.factors.weather_park.total_runs_factor.toFixed(2)}</div>
                                    </div>
                                </div>
                                ` : `
                                <div style="padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid #888; grid-column: 1 / -1;">
                                    <div style="font-weight: bold; color: #888; margin-bottom: 8px;">üå§Ô∏è Weather & Park Factors</div>
                                    <div style="font-size: 0.9em; color: #888; font-style: italic;">Weather data not available</div>
                                </div>
                                `}
                            ` : `
                                <div style="padding: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; border-left: 3px solid #888; grid-column: 1 / -1;">
                                    <div style="font-weight: bold; color: #888; margin-bottom: 8px;">üìä Model Factors</div>
                                    <div style="font-size: 0.9em; color: #888; font-style: italic;">Factor details not available</div>
                                </div>
                            `}
                        </div>
                        <div style="font-size: 0.8em; color: #888; margin-top: 10px; text-align: center;">
                            <em>Higher team strength and bullpen factors = better performance expected</em>
                        </div>
                    </div>
            `;
            
            // Add betting lines section if available
            const bettingData = prediction.betting_data || prediction.closing_lines;
            if (bettingData) {
                const moneyline = bettingData.moneyline || {};
                const total = bettingData.total || {};
                const spread = bettingData.spread || {};
                
                html += `
                    <div style="margin-top: 20px;">
                        <h3>Betting Lines</h3>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-top: 10px;">
                            <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                                <div style="font-weight: bold; margin-bottom: 5px;">Moneyline</div>
                                <div style="font-size: 0.9rem;">
                                    <div style="color: #ff6b6b;">${awayTeam}: ${moneyline.away || 'N/A'}</div>
                                    <div style="color: #4ecdc4;">${homeTeam}: ${moneyline.home || 'N/A'}</div>
                                </div>
                            </div>
                            <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                                <div style="font-weight: bold; margin-bottom: 5px;">Total</div>
                                <div style="font-size: 0.9rem;">
                                    ${total.line ? `O/U ${total.line}` : 'N/A'}<br>
                                    ${total.over && total.under ? `${total.over}/${total.under}` : ''}
                                </div>
                            </div>
                            <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                                <div style="font-weight: bold; margin-bottom: 5px;">Spread</div>
                                <div style="font-size: 0.9rem;">
                                    ${spread.line ? `${spread.line > 0 ? '+' : ''}${spread.line}` : 'N/A'}<br>
                                    ${spread.away && spread.home ? `${spread.away}/${spread.home}` : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Add enhanced betting recommendations section
            const bettingRecs = data.betting_recommendations;  // Get from top level of data object
            if (bettingRecs && (bettingRecs.value_bets || bettingRecs.summary)) {
                html += '<div style="margin-top: 20px;"><h3>üí∞ Betting Recommendations</h3>';
                
                // Add summary if available
                if (bettingRecs.summary) {
                    html += `<div style="margin-bottom: 15px; padding: 10px; background: rgba(79, 209, 199, 0.1); border-radius: 6px; color: #4fd1c7; font-weight: bold;">${bettingRecs.summary}</div>`;
                }
                
                // Show value bets in enhanced format
                if (bettingRecs.value_bets && bettingRecs.value_bets.length > 0) {
                    bettingRecs.value_bets.forEach(bet => {
                        const confidenceColor = bet.confidence === 'HIGH' ? '#ff6b6b' : 
                                               bet.confidence === 'MEDIUM' ? '#ffa726' : '#66bb6a';
                        const icon = bet.edge_rating || (bet.confidence === 'HIGH' ? 'üî•' : 
                                   bet.confidence === 'MEDIUM' ? '‚ö°' : 'üí°');
                        
                        // Format Expected Value for modal - LIMITED TO 2 DECIMAL PLACES MAX
                        let evModalDisplay = '';
                        if (bet.expected_value !== undefined && bet.expected_value !== null) {
                            const evPercent = (bet.expected_value * 100).toFixed(2);
                            const evColor = bet.expected_value > 0 ? '#4fd1c7' : '#ff6b6b';
                            const evSign = bet.expected_value > 0 ? '+' : '';
                            evModalDisplay = `<div style="color: ${evColor}; font-weight: bold; font-size: 0.95em;">EV: ${evSign}${evPercent}%</div>`;
                        }
                        
                        html += `
                            <div style="margin: 12px 0; padding: 15px; background: rgba(255,255,255,0.08); border-left: 4px solid ${confidenceColor}; border-radius: 8px;">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                                    <strong style="color: ${confidenceColor}; font-size: 1.1em;">${icon} ${bet.recommendation || bet.bet}</strong>
                                    <div style="text-align: right; font-size: 0.9em;">
                                        <div style="color: #4fd1c7; font-weight: bold;">${typeof bet.edge === 'number' ? bet.edge.toFixed(2) + '% edge' : bet.edge ? bet.edge : bet.confidence ? bet.confidence + ' CONFIDENCE' : 'Value Bet'}</div>
                                        ${evModalDisplay}
                                        ${bet.estimated_odds && bet.estimated_odds !== 'N/A' ? `<div style="color: #888;">${bet.estimated_odds}</div>` : ''}
                                    </div>
                                </div>
                                <div style="font-size: 0.9em; color: #ccc; line-height: 1.3;">${bet.reasoning}</div>
                                <div style="margin-top: 8px; font-size: 0.8em; color: #888;">
                                    <span style="background: rgba(${bet.confidence === 'HIGH' ? '255, 107, 107' : bet.confidence === 'MEDIUM' ? '255, 167, 38' : '102, 187, 106'}, 0.3); padding: 2px 6px; border-radius: 4px;">${bet.confidence} CONFIDENCE</span>
                                    <span style="margin-left: 10px;">${bet.type}</span>
                                </div>
                            </div>
                        `;
                    });
                    
                    // Highlight best bet if available
                    if (bettingRecs.best_bet) {
                        html += `
                            <div style="margin-top: 15px; padding: 12px; background: rgba(79, 209, 199, 0.2); border: 2px solid #4fd1c7; border-radius: 8px;">
                                <strong style="color: #4fd1c7;">üéØ Recommended Best Bet:</strong> ${bettingRecs.best_bet.recommendation || bettingRecs.best_bet.bet}
                            </div>
                        `;
                    }
                } else {
                    html += '<div style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px; font-style: italic; opacity: 0.8; text-align: center;">üí° No strong value bets identified - consider live betting opportunities</div>';
                }
                
                html += '</div>';
            }
            
            if (recs.length > 0) {
                // Legacy recommendations format - now using enhanced betting recommendations above
                console.log('Legacy recommendations found but using enhanced format instead');
            }
            
            html += `
                <div style="margin-top: 20px; font-size: 0.9rem; opacity: 0.8;">
                    ${meta.execution_time_ms > 0 ? `Execution Time: ${meta.execution_time_ms.toFixed(2)}ms | ` : ''}
                    Simulations: ${(meta.simulations_run || 5000).toLocaleString()} |
                    Data Source: ${meta.data_source || 'comprehensive_engine'}
                </div>
            `;
            
            document.getElementById('modal-body').innerHTML = html;
        }

        function loadToday() {
            document.getElementById('game-date').value = new Date().toISOString().split('T')[0];
            loadTodaysGames();
        }

        function closeModal() {
            document.getElementById('prediction-modal').style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('prediction-modal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        }
    </script>
    
    <!-- Monitoring Widget -->
    <script src="{{ url_for('static', filename='js/monitoring-widget.js') }}"></script>
</body>
</html>
