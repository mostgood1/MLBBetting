<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MLB-Betting Prediction System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        /* Modal removed */
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .clickable-stat {
            text-decoration: none;
            color: inherit;
            display: block;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .clickable-stat:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.15);
            border-color: #4fd1c7;
            box-shadow: 0 10px 25px rgba(79, 209, 199, 0.3);
        }

        .clickable-stat:hover h3 {
            color: #5ce1e6;
            text-shadow: 0 0 10px rgba(92, 225, 230, 0.5);
        }

        .stat-card h3 {
            font-size: 2rem;
            margin-bottom: 5px;
            color: #4fd1c7;
        }

        .stat-card p {
            opacity: 0.8;
        }

        .games-section {
            margin-top: 30px;
        }

        .games-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .date-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .date-selector input {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            background: #4fd1c7;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #45b7b8;
        }

        .btn-small {
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            background: #4fd1c7;
            color: white;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: background 0.3s;
        }

        .btn-small:hover {
            background: #45b7b8;
        }

        .games-grid {
            display: grid;
            gap: 12px;
        }

        .game-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
            overflow: hidden;
        }

        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

    /* Compact factor cards under SPs */
    .factor-cards { margin-top: 8px; display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px; }
    @media (min-width: 900px) { .factor-cards { grid-template-columns: repeat(4, minmax(0, 1fr)); } }
    .factor-card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 8px; padding: 8px; }
    .factor-card h5 { margin-bottom: 6px; font-size: 0.86rem; color: #aeefff; }
    .factor-kv { display:flex; justify-content:space-between; font-size: 0.85rem; margin: 2px 0; }
    .factor-sub { font-size: 0.78rem; opacity: 0.85; }

        /* Inline Details panel to reduce modal reliance */
        .details-toggle {
            margin-top: 10px;
            display: inline-flex;
            gap: 6px;
            align-items: center;
            cursor: pointer;
            font-size: 0.9rem;
            color: #5ce1e6;
        }
        .details-toggle .chev { transition: transform 0.2s ease; }
    .details-panel { margin-top: 6px; display: none; }
        .details-panel.open { display: block; }
        .details-grid {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 8px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 8px;
            padding: 6px;
        }
        .details-item h5 { font-size: 0.86rem; color: #aeefff; margin-bottom: 3px; }
        .details-item .kv { font-size: 0.82rem; opacity: 0.95; }
        .chip { display:inline-block; padding:2px 6px; border-radius:12px; background: rgba(255,255,255,0.12); margin-right:6px; }
        @media (max-width: 720px) { .details-grid { grid-template-columns: 1fr; } }

    .game-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }

        .starting-pitchers {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .pitcher-matchup {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .away-pitcher, .home-pitcher {
            flex: 1;
            text-align: center;
        }

        .pitcher-label {
            display: block;
            font-size: 0.8rem;
            opacity: 0.7;
            margin-bottom: 2px;
        }

        .pitcher-name {
            display: block;
            font-weight: bold;
            color: #4fd1c7;
        }

        .pitcher-matchup .vs-separator {
            font-size: 0.8rem;
            opacity: 0.5;
            margin: 0 5px;
        }

    .game-teams { font-size:1.05rem; font-weight:700; display:flex; align-items:center; gap:10px; }

        .team-info {
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .team-info:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .team-logo {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }

        .team-name {
            font-weight: bold;
        }

        .vs-separator {
            font-size: 0.9rem;
            opacity: 0.7;
            margin: 0 5px;
        }

    .game-time { opacity: 0.75; font-size: 0.8rem; }

    .prediction-summary { display: grid; grid-template-columns: repeat(3, minmax(80px, 1fr)); gap: 6px; margin-top: 6px; }

    .betting-lines { margin-top: 8px; }

        .betting-lines h4 {
            margin-bottom: 12px;
            font-size: 0.9rem;
            color: #ff6600;  /* DraftKings orange color */
            text-align: center;
            font-weight: bold;
        }

    .betting-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }

    .betting-item { text-align: center; padding: 8px 6px; background: rgba(79, 209, 199, 0.08); border-radius: 6px; border: 1px solid rgba(79, 209, 199, 0.2); transition: all 0.2s ease; }
        
    /* Compact card grid */
    .card-grid { display:grid; grid-template-columns: 1.1fr 1.2fr 1.7fr; gap: 8px; align-items:start; }
    @media (max-width: 980px) { .card-grid { grid-template-columns: 1fr; } }
    .live-inline { font-size: 0.76rem; opacity: 0.95; display:flex; align-items:center; gap:6px; margin-top:6px; }
    .live-pill { background: rgba(220,53,69,0.18); border:1px solid rgba(220,53,69,0.35); color:#ff6b6b; padding:2px 6px; border-radius:10px; font-weight:700; }
    .final-pill { background: rgba(40,167,69,0.18); border:1px solid rgba(40,167,69,0.35); color:#66bb6a; padding:2px 6px; border-radius:10px; font-weight:700; }

        .betting-item:hover {
            background: rgba(79, 209, 199, 0.12);
            border-color: rgba(79, 209, 199, 0.3);
        }

        .betting-item .line-label {
            font-size: 0.72rem;
            opacity: 0.9;
            margin-bottom: 4px;
            color: #4fd1c7;
            font-weight: 600;
        }

        .betting-item .line-value {
            font-size: 0.8rem;
            font-weight: bold;
            line-height: 1.3;
        }

        .moneyline-away, .moneyline-home {
            font-size: 0.75rem;
            margin: 1px 0;
            font-weight: 600;
        }

        .moneyline-away {
            color: #ff8a80;
        }

        .moneyline-home {
            color: #81c784;
        }

        .betting-recommendations {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid #4fd1c7;
        }

        .betting-recommendations h4 {
            margin: 0 0 12px 0;
            color: #4fd1c7;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .value-bet {
            margin: 8px 0;
            padding: 12px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.08);
            border-left: 3px solid transparent;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .value-bet:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-1px);
        }

        .value-bet.high-confidence {
            border-left-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.15);
        }

        .value-bet.medium-confidence {
            border-left-color: #ffa726;
            background: rgba(255, 167, 38, 0.15);
        }

        .value-bet.low-confidence {
            border-left-color: #66bb6a;
            background: rgba(102, 187, 106, 0.15);
        }

        .best-bet {
            margin: 8px 0;
            padding: 12px;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .no-value {
            font-style: italic;
            opacity: 0.7;
            text-align: center;
            padding: 10px;
            color: #888;
        }

        .value-bet.low-confidence {
            border-left-color: #66bb6a;
            background: rgba(102, 187, 106, 0.15);
        }

        .value-bet.positive-ev {
            border-left-color: #4fd1c7;
            background: rgba(79, 209, 199, 0.2);
            box-shadow: 0 0 8px rgba(79, 209, 199, 0.3);
        }

        .positive-ev-badge {
            background: linear-gradient(45deg, #4fd1c7, #00d4aa);
            color: white;
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: bold;
            margin-left: 5px;
        }

        .no-value-bet {
            padding: 10px;
            text-align: center;
            color: #888;
            font-style: italic;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .edge-indicator {
            font-weight: bold;
            margin-left: 4px;
        }

        .game-status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
            margin-left: 8px;
        }

        .badge-scheduled {
            background: rgba(108, 117, 125, 0.2);
            color: #6c757d;
            border: 1px solid rgba(108, 117, 125, 0.3);
        }

        .badge-live {
            background: rgba(220, 53, 69, 0.2);
            color: #dc3545;
            border: 1px solid rgba(220, 53, 69, 0.4);
            animation: pulse 2s infinite;
        }

        .badge-final {
            background: rgba(40, 167, 69, 0.2);
            color: #28a745;
            border: 1px solid rgba(40, 167, 69, 0.4);
        }

        .badge-delayed {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.4);
        }

        .badge-unknown {
            background: rgba(255, 255, 255, 0.1);
            color: #adb5bd;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .game-time {
            font-size: 0.85rem;
            opacity: 0.8;
            margin-top: 4px;
        }

        .live-score {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            padding: 8px;
            background: rgba(220, 53, 69, 0.1);
            border-radius: 6px;
            border-left: 3px solid #dc3545;
        }

        .live-score .team-score {
            font-weight: bold;
            font-size: 1.1rem;
        }

        /* Compact pitcher props row */
        .pitcher-props {
            margin-top: 10px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
        }
        .prop-chip {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.15);
            font-size: 0.85rem;
        }
        .prop-chip .left {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        .prop-chip .odds {
            font-weight: 600;
        }
        .prop-chip.high { border-left: 3px solid #ff6b6b; }
        .prop-chip.medium { border-left: 3px solid #ffa726; }
        .prop-chip.low { border-left: 3px solid #66bb6a; }
        .prop-chip .ev { color: #4fd1c7; font-weight: 600; }

        /* Live prop progress styling */
        .live-prop-progress {
            margin-top: 8px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 6px;
        }
        .live-prop-item {
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 6px;
            padding: 6px 8px;
            font-size: 0.8rem;
        }
        .live-prop-item .hdr { display:flex; justify-content:space-between; margin-bottom:4px; }
        .live-prop-bar {
            height: 6px;
            background: rgba(255,255,255,0.12);
            border-radius: 6px;
            overflow: hidden;
        }
        .live-prop-fill { height: 100%; background: linear-gradient(90deg, #4fd1c7, #00d4aa); width: 0%; }
        
    /* Pitcher props panel (compact redesign) */
    .pitcher-props-panel { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 8px; }
    .pitcher-column { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 8px; padding: 8px; }
    .pitcher-col-header { display:flex; align-items:center; justify-content:space-between; margin-bottom:6px; }
    .pitcher-col-header .name { font-weight: 700; color: #4fd1c7; }
    .props-table { display: grid; gap: 6px; }
    .pitcher-col-subhdr { font-size: 0.82rem; opacity: 0.9; margin: 2px 0 6px; }
    .pitcher-col-subhdr .live-pc { color: #ffd166; margin-left: 4px; }
    .prop-row { background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.1); border-radius:6px; padding:6px; }
    .prop-row .meta { display:flex; flex-wrap:wrap; gap:8px; font-size:0.78rem; opacity:0.95; margin-bottom:4px; }
    .prop-row .bar { height:6px; background: rgba(255,255,255,0.12); border-radius:6px; overflow:hidden; }
    .prop-row .fill { height:100%; width:0%; background: linear-gradient(90deg, #66bb6a, #4caf50); transition: width 0.3s ease; }
    .prop-row .current { margin-top:2px; font-size:0.75rem; opacity:0.9; display:flex; justify-content:space-between; }
    /* Hit state & badge */
    .prop-row.hit .fill { animation: hitPulse 1.2s ease-in-out 2; }
    .hit-badge { display:none; margin-left:8px; padding:2px 6px; border-radius:10px; font-size:0.7rem; border:1px solid transparent; }
    .hit-badge.good { background: rgba(76,175,80,0.18); color:#c8e6c9; border-color:#4caf50; }
    .hit-badge.bad { background: rgba(229,57,53,0.18); color:#ffcdd2; border-color:#e53935; }
    .hit-badge.neutral { background: rgba(253,216,53,0.18); color:#fff59d; border-color:#fdd835; }
    @keyframes hitPulse { 0% { box-shadow: 0 0 0px rgba(255,255,255,0.0); } 50% { box-shadow: 0 0 10px rgba(255,255,255,0.7); } 100% { box-shadow: 0 0 0px rgba(255,255,255,0.0); } }
    /* Recommendation badge */
    .rec-badge { padding: 2px 6px; border-radius: 999px; font-size: 0.72rem; font-weight: 700; letter-spacing: 0.2px; }
    .rec-badge.over { background: rgba(76, 175, 80, 0.15); border: 1px solid #4caf50; color: #b9f6ca; }
    .rec-badge.under { background: rgba(244, 67, 54, 0.15); border: 1px solid #e57373; color: #ff8a80; }
    .rec-badge.low { opacity: 0.8; }
    .rec-badge.medium { box-shadow: 0 0 8px rgba(255,255,255,0.06) inset; }
    .rec-badge.high { box-shadow: 0 0 0 1px rgba(255,255,255,0.2) inset; }
    @media (max-width: 800px) { .pitcher-props-panel { grid-template-columns: 1fr; } }

        .final-analysis {
            margin-top: 10px;
            padding: 10px;
            background: rgba(40, 167, 69, 0.1);
            border-radius: 8px;
            border-left: 3px solid #28a745;
        }

        .final-analysis h5 {
            color: #28a745;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .analysis-item {
            margin: 4px 0;
            font-size: 0.8rem;
            padding: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .analysis-correct {
            color: #28a745;
        }

        .analysis-incorrect {
            color: #dc3545;
        }

        .betting-comparison {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .betting-comparison h6 {
            margin: 5px 0 8px 0;
            font-size: 0.9rem;
            color: #ffd700;
        }

        .betting-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .section-title {
            color: #4fd1c7;
            font-size: 1.2rem;
            margin: 20px 0 15px 0;
            padding: 10px 15px;
            background: rgba(79, 209, 199, 0.1);
            border-left: 4px solid #4fd1c7;
            border-radius: 5px;
        }

        .btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn.secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .prediction-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .prediction-item .value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #4fd1c7;
        }

        .prediction-item .label {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2rem;
        }

        .error {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid rgba(255, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: white;
            cursor: pointer;
        }

        .recommendations {
            margin-top: 20px;
        }

        .recommendation {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .recommendation.high-confidence {
            border-left: 4px solid #4fd1c7;
        }

        .recommendation.medium-confidence {
            border-left: 4px solid #f39c12;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .games-header {
                flex-direction: column;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>⚾ MLB-Betting</h1>
            <p>Advanced MLB Prediction System with Real-Time Betting Analysis</p>
            <p style="font-size: 0.9rem; opacity: 0.8; margin-top: 5px;">
                📊 Comprehensive Analysis Since August 7th • Updated Daily • {{ comprehensive_stats.total_games_analyzed or 0 }} Games Tracked
            </p>
            
            <!-- Admin Navigation -->
            <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                <a href="/admin" style="display: inline-block; padding: 8px 16px; background: rgba(255, 215, 0, 0.2); color: #FFD700; text-decoration: none; border-radius: 8px; border: 1px solid #FFD700; font-size: 0.9rem; font-weight: bold; transition: all 0.3s ease;" 
                   onmouseover="this.style.background='rgba(255, 215, 0, 0.3)'; this.style.transform='translateY(-2px)'" 
                   onmouseout="this.style.background='rgba(255, 215, 0, 0.2)'; this.style.transform='translateY(0)'">
                    🎯 Tuning Dashboard
                </a>
                <button id="run-automation-btn" onclick="runDailyAutomation()" style="padding: 8px 16px; background: rgba(79, 209, 199, 0.2); color: #4fd1c7; border: 1px solid #4fd1c7; border-radius: 8px; font-size: 0.9rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease;" 
                        onmouseover="this.style.background='rgba(79, 209, 199, 0.3)'; this.style.transform='translateY(-2px)'" 
                        onmouseout="this.style.background='rgba(79, 209, 199, 0.2)'; this.style.transform='translateY(0)'">
                    🚀 Run Daily Update
                </button>
                <button id="refresh-stats-btn" onclick="refreshDashboardStats()" style="padding: 8px 16px; background: rgba(156, 163, 175, 0.2); color: #9ca3af; border: 1px solid #9ca3af; border-radius: 8px; font-size: 0.9rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease; margin-left: 8px;" 
                        onmouseover="this.style.background='rgba(156, 163, 175, 0.3)'; this.style.transform='translateY(-2px)'" 
                        onmouseout="this.style.background='rgba(156, 163, 175, 0.2)'; this.style.transform='translateY(0)'">
                    📊 Refresh Stats
                </button>
                <button id="init-system-btn" onclick="initializeSystem()" style="padding: 8px 16px; background: rgba(34, 197, 94, 0.2); color: #22c55e; border: 1px solid #22c55e; border-radius: 8px; font-size: 0.9rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease; margin-left: 8px;" 
                        onmouseover="this.style.background='rgba(34, 197, 94, 0.3)'; this.style.transform='translateY(-2px)'" 
                        onmouseout="this.style.background='rgba(34, 197, 94, 0.2)'; this.style.transform='translateY(0)'">
                    ⚡ Load Real MLB Data
                </button>
            </div>
        </div>

        <div id="summary-stats" class="stats-grid">
            <div class="stat-card" id="tbd-monitor-card">
                <h3 id="tbd-status-indicator">🔍</h3>
                <p>TBD Monitor</p>
                <small id="tbd-status-text">Loading...</small>
                <div style="margin-top: 8px;">
                    <button class="btn-small" onclick="checkTBD()" id="tbd-check-btn">Check Now</button>
                </div>
            </div>
            <div class="stat-card">
                <h3>🎯 Pitcher Proj</h3>
                <p>Now shown on game cards</p>
            </div>
        </div>

        <div class="games-section">
            <div class="games-header">
                <h2>Today's MLB Games</h2>
                <div class="date-selector">
                    <input type="date" id="game-date" style="display: none;" />
                    <button class="btn" onclick="loadToday()">Refresh</button>
                    <button class="btn secondary" onclick="refreshBettingLines()" id="refresh-betting-lines-btn">💰 Update Betting Lines</button>
                    <button class="btn secondary" onclick="goToHistoricalAnalysis()">📊 Historical Analysis</button>
                    <button class="btn secondary" onclick="goToBettingGuidance()">🎯 Betting Guidance</button>
                </div>
            </div>

            <!-- Live Games Section -->
            <div id="live-games-section" style="display: none;">
                <h3 class="section-title">🔴 Live Games</h3>
                <div id="live-games-container" class="games-grid"></div>
            </div>

            <!-- Upcoming Games Section -->
            <div id="upcoming-games-section" style="display: none;">
                <h3 class="section-title">⏰ Upcoming Games</h3>
                <div id="upcoming-games-container" class="games-grid"></div>
            </div>

            <div id="games-container">
                <div class="loading">Loading today's games...</div>
            </div>

            <!-- Completed Games Section - Moved to bottom -->
            <div id="completed-games-section" style="display: none; margin-top: 30px;">
                <h3 class="section-title">✅ Completed Games</h3>
                <div id="completed-games-container" class="games-grid"></div>
            </div>
        </div>
    </div>

    <!-- Modal removed -->

    <script>
        function createLiveBadgeHtml(liveStatus) {
            if (!liveStatus) return '';
            if (liveStatus.is_final) {
                const as = liveStatus.away_score ?? '-';
                const hs = liveStatus.home_score ?? '-';
                return `<span class="final-pill">Final ${as}-${hs}</span>`;
            }
            if (!liveStatus.is_live) return `<span class="badge-scheduled game-status-badge">${liveStatus.status || 'Scheduled'}</span>`;
            let inningDisplay = 'LIVE';
            if (liveStatus.inning && liveStatus.inning_state) inningDisplay = `${liveStatus.inning_state} ${liveStatus.inning}`;
            const counts = (liveStatus.balls != null && liveStatus.strikes != null && liveStatus.outs != null)
                ? ` • B:${liveStatus.balls} S:${liveStatus.strikes} O:${liveStatus.outs}` : '';
            const bases = liveStatus.base_state ? ` • ${liveStatus.base_state}` : '';
            const as = liveStatus.away_score ?? 0, hs = liveStatus.home_score ?? 0;
            return `<span class="live-pill">${inningDisplay}</span> <span>${as}-${hs}${counts}${bases}</span>`;
        }

        // Get user's local date, not UTC date
        let currentDate = new Date();
        let localDateString = currentDate.getFullYear() + '-' + 
                              String(currentDate.getMonth() + 1).padStart(2, '0') + '-' + 
                              String(currentDate.getDate()).padStart(2, '0');
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('game-date').value = localDateString;
            loadSummary();
            loadTodaysGames();
            
            // Start live updates for games in progress
            startLiveUpdates();
            
            // Initialize TBD monitoring
            updateTBDStatus();
            
            // Initialize live dashboard stats
            loadLiveDashboardStats();
            
            // Update TBD status every 5 minutes
            setInterval(updateTBDStatus, 300000);
            
            // Update dashboard stats every 2 minutes
            setInterval(loadLiveDashboardStats, 120000);
        });

        // 🔥 LIVE DASHBOARD STATS WIDGET
        async function loadLiveDashboardStats() {
            try {
                console.log('🔄 Loading live dashboard stats from historical analysis API...');
                
                const response = await fetch('/api/historical-analysis/cumulative');
                if (!response.ok) {
                    console.warn('❌ Historical analysis API not available, keeping server-side stats');
                    return;
                }
                
                const apiData = await response.json();
                if (!apiData.success || !apiData.data) {
                    console.warn('❌ Historical analysis API returned error:', apiData.message);
                    return;
                }
                
                const data = apiData.data;
                const betting = data.betting_performance || {};
                const analysis = data.analysis_period || '2025-08-15 to 2025-08-25';
                
                console.log('✅ Live dashboard data loaded:', {
                    totalRecommendations: betting.total_recommendations,
                    accuracy: betting.overall_accuracy,
                    roi: betting.roi_percentage
                });
                
                // Update the dashboard stats with live data
                updateDashboardStat(0, {
                    value: betting.total_recommendations || 0,
                    subtitle: `Since ${analysis.split(' to ')[0]} (${data.total_dates_analyzed || 0} days)`
                });
                
                updateDashboardStat(1, {
                    value: `${(betting.overall_accuracy || 0).toFixed(2)}%`,
                    subtitle: `${betting.correct_recommendations || 0}/${betting.total_recommendations || 0} correct predictions`
                });
                
                updateDashboardStat(2, {
                    value: `$${(betting.net_profit || 0).toFixed(2)}`,
                    subtitle: `${(betting.roi_percentage || 0).toFixed(2)}% ROI on ${betting.total_recommendations || 0} bets`
                });
                
                updateDashboardStat(3, {
                    value: `${(betting.overall_accuracy || 0).toFixed(2)}%`,
                    subtitle: `${betting.correct_recommendations || 0} winning bets of ${betting.total_recommendations || 0} placed`
                });
                
                // Add visual indicator that data is live
                const header = document.querySelector('.header p');
                if (header && !header.textContent.includes('🔴 LIVE')) {
                    header.innerHTML = header.innerHTML.replace('📊 Comprehensive Analysis', '🔴 LIVE Analysis');
                }
                
                console.log('✅ Dashboard stats updated with live data');
                
            } catch (error) {
                console.warn('⚠️ Could not load live dashboard stats:', error);
                // Keep server-side stats if API fails
            }
        }
        
        function updateDashboardStat(index, data) {
            const statCards = document.querySelectorAll('#summary-stats .stat-card h3');
            const subtitleCards = document.querySelectorAll('#summary-stats .stat-card small');
            
            if (statCards[index]) {
                statCards[index].textContent = data.value;
                // Add a subtle animation to show the update
                statCards[index].style.transition = 'all 0.3s ease';
                statCards[index].style.transform = 'scale(1.05)';
                statCards[index].style.color = '#4fd1c7';
                setTimeout(() => {
                    statCards[index].style.transform = 'scale(1)';
                    statCards[index].style.color = '';
                }, 300);
            }
            
            if (subtitleCards[index] && data.subtitle) {
                subtitleCards[index].textContent = data.subtitle;
            }
        }

        function goToHistoricalAnalysis() {
            // Navigate to model performance/accuracy page
            window.location.href = '/historical-performance';
        }

        function goToBettingGuidance() {
            // Navigate to Kelly-based betting guidance page
            window.location.href = '/betting-guidance';
        }

        function loadToday() {
            currentDate = new Date();
            localDateString = currentDate.getFullYear() + '-' + 
                              String(currentDate.getMonth() + 1).padStart(2, '0') + '-' + 
                              String(currentDate.getDate()).padStart(2, '0');
            document.getElementById('game-date').value = localDateString;
            loadTodaysGames();
        }

        // Betting Lines Refresh Function
        async function refreshBettingLines() {
            const btn = document.getElementById('refresh-betting-lines-btn');
            const originalText = btn.textContent;
            
            btn.textContent = '⏳ Updating...';
            btn.disabled = true;
            
            try {
                // Show loading notification
                showNotification('Fetching fresh betting lines from OddsAPI...', 'info', 0);
                
                const response = await fetch('/api/refresh-betting-lines', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const linesCount = data.data.fresh_lines_count;
                    const recsGenerated = data.data.recommendations_generated;
                    const recsCount = data.data.recommendations_count;
                    
                    let message = `✅ Successfully updated ${linesCount} betting lines`;
                    if (recsGenerated) {
                        message += ` and regenerated recommendations for ${recsCount} games`;
                    }
                    
                    showNotification(message, 'success', 5000);
                    
                    // Refresh the games display to show updated lines
                    setTimeout(() => {
                        loadTodaysGames();
                    }, 1000);
                    
                } else {
                    showNotification(`❌ Failed to update betting lines: ${data.error}`, 'error', 8000);
                }
                
            } catch (error) {
                console.error('Error refreshing betting lines:', error);
                showNotification('❌ Network error while updating betting lines', 'error', 8000);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        // Notification function for user feedback
        function showNotification(message, type = 'info', duration = 5000) {
            // Remove existing notifications
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(notif => notif.remove());
            
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = message;
            
            // Styling
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                border-radius: 8px;
                font-weight: bold;
                max-width: 400px;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                transition: all 0.3s ease;
                transform: translateX(100%);
            `;
            
            // Type-specific styling
            if (type === 'success') {
                notification.style.background = 'rgba(16, 185, 129, 0.9)';
                notification.style.color = 'white';
                notification.style.border = '1px solid #10b981';
            } else if (type === 'error') {
                notification.style.background = 'rgba(239, 68, 68, 0.9)';
                notification.style.color = 'white';
                notification.style.border = '1px solid #ef4444';
            } else {
                notification.style.background = 'rgba(59, 130, 246, 0.9)';
                notification.style.color = 'white';
                notification.style.border = '1px solid #3b82f6';
            }
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            // Auto-remove if duration is set
            if (duration > 0) {
                setTimeout(() => {
                    notification.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }, duration);
            }
        }

        // TBD Monitoring Functions
        async function updateTBDStatus() {
            try {
                const response = await fetch('/api/tbd-status');
                const data = await response.json();
                
                if (data.success) {
                    const status = data.status;
                    const indicator = document.getElementById('tbd-status-indicator');
                    const statusText = document.getElementById('tbd-status-text');
                    
                    if (status.tbd_games_count > 0) {
                        indicator.textContent = '⚠️';
                        statusText.textContent = `${status.tbd_games_count} games with TBD pitchers`;
                    } else {
                        indicator.textContent = '✅';
                        statusText.textContent = 'All pitchers confirmed';
                    }
                    
                    // Update last check time
                    const lastCheck = new Date(status.last_check);
                    const timeStr = lastCheck.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    statusText.innerHTML += `<br>Last checked: ${timeStr}`;
                }
            } catch (error) {
                console.error('Error updating TBD status:', error);
                document.getElementById('tbd-status-indicator').textContent = '❌';
                document.getElementById('tbd-status-text').textContent = 'Monitor error';
            }
        }

        async function checkTBD() {
            const btn = document.getElementById('tbd-check-btn');
            const originalText = btn.textContent;
            
            btn.textContent = 'Checking...';
            btn.disabled = true;
            
            try {
                const response = await fetch('/api/tbd-check', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    if (data.updated) {
                        // Refresh the page to show updated recommendations
                        loadToday();
                        updateTBDStatus();
                        alert('Pitcher updates found! Recommendations refreshed.');
                    } else {
                        alert('No pitcher updates found.');
                    }
                } else {
                    alert('Error checking for updates: ' + data.error);
                }
            } catch (error) {
                console.error('Error checking TBD:', error);
                alert('Error checking for pitcher updates.');
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        // Daily Automation Function
        async function runDailyAutomation() {
            const btn = document.getElementById('run-automation-btn');
            const originalText = btn.textContent;
            
            try {
                btn.textContent = '🔄 Starting...';
                btn.disabled = true;
                
                const response = await fetch('/api/run-daily-automation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    btn.textContent = '✅ Running...';
                    alert('Daily automation started! This will update all data including betting recommendations for today. Check the console logs for progress. The page will refresh in 30 seconds.');
                    
                    // Refresh the page after 30 seconds to show updated data
                    setTimeout(() => {
                        window.location.reload();
                    }, 30000);
                } else {
                    btn.textContent = originalText;
                    btn.disabled = false;
                    alert('Error starting automation: ' + data.error);
                }
            } catch (error) {
                console.error('Error starting automation:', error);
                btn.textContent = originalText;
                btn.disabled = false;
                alert('Error starting daily automation.');
            }
        }

        // Refresh Dashboard Stats Function
        async function refreshDashboardStats() {
            const btn = document.getElementById('refresh-stats-btn');
            const originalText = btn.textContent;
            
            try {
                btn.textContent = '🔄 Updating...';
                btn.disabled = true;
                
                const response = await fetch('/api/update-dashboard-stats');
                const data = await response.json();
                
                if (data.status === 'success') {
                    btn.textContent = '✅ Updated!';
                    
                    // Update the stats display on the page
                    const totalGamesElement = document.querySelector('.stat-card h3');
                    if (totalGamesElement && data.stats) {
                        totalGamesElement.textContent = data.stats.total_games_analyzed || 0;
                    }
                    
                    // Refresh the page to show all updated stats
                    setTimeout(() => {
                        window.location.reload();
                    }, 1500);
                } else {
                    btn.textContent = '❌ Error';
                    alert('Error updating stats: ' + data.message);
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.disabled = false;
                    }, 2000);
                }
            } catch (error) {
                console.error('Error refreshing stats:', error);
                btn.textContent = '❌ Error';
                alert('Error refreshing dashboard statistics.');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 2000);
            }
        }

        async function initializeSystem() {
            const btn = document.getElementById('init-system-btn');
            const originalText = btn.textContent;
            
            try {
                btn.textContent = '🔄 Fetching Real MLB Data...';
                btn.disabled = true;
                
                showNotification('🚀 Fetching real MLB games from API...', 'info', 5000);
                
                const response = await fetch('/api/initialize-system', {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.success) {
                    btn.textContent = '✅ Success!';
                    showNotification(`✅ Successfully loaded ${data.games_loaded} real MLB games!`, 'success', 5000);
                    
                    // Show the games that were loaded
                    if (data.real_games && data.real_games.length > 0) {
                        const gamesList = data.real_games.join(', ');
                        console.log('Real games loaded:', gamesList);
                    }
                    
                    // Refresh the page to show the real data
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                } else {
                    btn.textContent = '❌ Failed';
                    showNotification(`❌ Failed to load real data: ${data.error}`, 'error', 8000);
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.disabled = false;
                    }, 3000);
                }
            } catch (error) {
                console.error('Error initializing system:', error);
                btn.textContent = '❌ Failed';
                showNotification('❌ Error fetching real MLB data. Check console for details.', 'error', 8000);
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 3000);
            }
        }

        function startLiveUpdates() {
            // Check for live games more frequently (every 10 seconds)
            setInterval(updateLiveGames, 10000);
        }

    async function updateLiveGames() {
            try {
                const date = document.getElementById('game-date').value;
                const response = await fetch(`/api/live-status?date=${date}`);
                const data = await response.json();
                
                if (data.success) {
                    const liveGames = data.games.filter(game => game.is_live || game.is_final);
                    
                    for (const liveGame of liveGames) {
                        updateGameCard(liveGame);
                    }
                    
                    // Update timestamp
                    console.log(`Live update: ${new Date().toLocaleTimeString()} - ${liveGames.length} games updated`);
                }
            } catch (error) {
                console.error('Error updating live games:', error);
            }
        }

    function updateGameCard(liveGame) {
            // Find the corresponding game card by composite ID using the selected date
            const dateStr = document.getElementById('game-date').value;
            const compositeId = `${liveGame.away_team}_${liveGame.home_team}_${dateStr}`;
            
            // Debug logging
            console.log(`🔍 Looking for live game: ${liveGame.away_team} @ ${liveGame.home_team}`);
            console.log(`   Status: ${liveGame.status}, Live: ${liveGame.is_live}, Scores: ${liveGame.away_score}-${liveGame.home_score}`);
            
            // Primary: exact match on data-game-id
            let card = document.querySelector(`[data-game-id="${compositeId}"]`);
            
            // Fallback: match by explicit team attributes
            if (!card) {
                const awayKey = (liveGame.away_team || '').toLowerCase();
                const homeKey = (liveGame.home_team || '').toLowerCase();
                card = document.querySelector(`.game-card[data-away-team="${awayKey}"][data-home-team="${homeKey}"]`);
            }
            
            // Fallback: normalized names in composite if formatting differs
            if (!card) {
                const normalizedAway = liveGame.away_team.replace('Oakland ', '').replace(' Athletics', '');
                const normalizedHome = liveGame.home_team.replace('Oakland ', '').replace(' Athletics', '');
                card = document.querySelector(`[data-game-id*="${normalizedAway}"][data-game-id*="${normalizedHome}"]`);
                console.log(`   Trying normalized names: ${normalizedAway} @ ${normalizedHome}`);
            }
            
            if (card) {
                console.log(`✅ Found game card, updating live status`);
                // Update status badge
                const statusBadge = card.querySelector('.game-status-badge');
                if (statusBadge) {
                    statusBadge.className = `game-status-badge badge-${liveGame.badge_class}`;
                    statusBadge.textContent = liveGame.status;
                    console.log(`   Updated badge to: ${liveGame.status}`);
                }
                
                // Target the existing inline live container to avoid duplicates
                const liveInline = card.querySelector('.live-inline');
                if (liveInline) {
                    // Clear any previous content we injected
                    liveInline.innerHTML = '';
                }

                if (liveGame.is_live && (liveGame.away_score != null || liveGame.home_score != null)) {
                    const liveScoreHtml = createLiveScoreHtml(liveGame);
                    console.log(`   Rendering live score inline`);
                    if (liveInline) {
                        liveInline.innerHTML = liveScoreHtml;
                    }

                    // Kick off live prop poll/update for this game
                    try {
                        const away = encodeURIComponent(liveGame.away_team);
                        const home = encodeURIComponent(liveGame.home_team);
                        pollAndRenderLiveProps(card, away, home);
                    } catch (e) { console.warn('live props poll init failed', e); }
                } else if (liveGame.is_final && (liveGame.away_score != null || liveGame.home_score != null)) {
                    // Render final analysis inline and stop any live polling timers
                    const gameId = card.querySelector('[id^="summary-"]').id.replace('summary-', '');
                    const finalScoreHtml = createFinalScoreHtml(liveGame, { prediction: {} });
                    if (liveInline) {
                        liveInline.innerHTML = finalScoreHtml;
                    }
                    // Stop live props intervals on final
                    const panel = card.querySelector('.pitcher-props-panel');
                    if (panel && panel._livePropsInterval) {
                        clearInterval(panel._livePropsInterval);
                        panel._livePropsInterval = null;
                    }
                }
            } else {
                console.log(`❌ Game card not found for ${liveGame.away_team} @ ${liveGame.home_team}`);
            }
        }

        async function pollAndRenderLiveProps(cardEl, awayTeam, homeTeam) {
            const date = document.getElementById('game-date').value;
            const panel = cardEl.querySelector('.pitcher-props-panel');
            if (!panel) return;
            const awayName = (panel.getAttribute('data-away-pitcher')||'').trim();
            const homeName = (panel.getAttribute('data-home-pitcher')||'').trim();
            const doFetch = async () => {
                try {
                    const resp = await fetch(`/api/live-props/${awayTeam}/${homeTeam}?date=${encodeURIComponent(date)}`);
                    const data = await resp.json();
                    if (!data || !data.success) return;
                    renderLivePropsIntoPanel(panel, awayName, homeName, data.props || []);
                    // Render live pitch counts if available
                    if (data.live_pitch_counts) {
                        const fmtInnings = (arr) => {
                            if (!arr || !Array.isArray(arr) || arr.length === 0) return '';
                            // Show last up to 3 innings for compactness
                            const last = arr.slice(-3).map(v => parseInt(v,10)).join('-');
                            return ` | ${last}`;
                        };
                        const awayLive = data.live_pitch_counts[awayName] || {};
                        const homeLive = data.live_pitch_counts[homeName] || {};
                        const awayPc = (awayLive.pitch_count ?? awayLive.pitches);
                        const homePc = (homeLive.pitch_count ?? homeLive.pitches);
                        const awayPI = fmtInnings(awayLive.pitches_by_inning);
                        const homePI = fmtInnings(homeLive.pitches_by_inning);
                        const awayEl = panel.querySelector(`#${panel.id}-away-pc-live`);
                        const homeEl = panel.querySelector(`#${panel.id}-home-pc-live`);
                        if (awayEl) awayEl.textContent = (awayPc != null) ? ` (${awayPc} live${awayPI})` : '';
                        if (homeEl) homeEl.textContent = (homePc != null) ? ` (${homePc} live${homePI})` : '';
                    }
                } catch (e) { /* ignore transient */ }
            };
            // Initial and periodic
            doFetch();
            // Store interval on element to avoid duplicates
            if (!panel._livePropsInterval) {
                panel._livePropsInterval = setInterval(doFetch, 15000);
            }
        }
        
        function renderLivePropsIntoPanel(panel, awayName, homeName, props) {
            if (!Array.isArray(props)) return;
            const nameToSide = (nm) => (nm===awayName) ? 'away' : (nm===homeName) ? 'home' : null;
            const goodGrad = 'linear-gradient(90deg,#66bb6a,#4caf50)';
            const badGrad  = 'linear-gradient(90deg,#ef5350,#e53935)';
            const neutralGrad = 'linear-gradient(90deg,#fbc02d,#fdd835)';
            const defaultColor = (pct) => pct >= 100 ? badGrad : goodGrad; // legacy fallback
            for (const p of props) {
                const side = nameToSide(p.pitcher_name||'');
                if (!side) continue;
                const stat = p.stat;
                const base = `${panel.id}-${side}-${stat}`;
                const curEl = panel.querySelector(`#${CSS.escape(base)}-cur`);
                const barEl = panel.querySelector(`#${CSS.escape(base)}-bar`);
                if (curEl) curEl.textContent = `${p.current ?? 0}`;
                if (barEl) {
                    const pct = Math.max(0, Math.min(100, Math.round((p.progress || 0) * 100)));
                    barEl.style.width = pct + '%';
                    // Determine recommendation side from the row's data-rec attribute
                    const rowEl = panel.querySelector(`.prop-row[data-side="${side}"][data-stat="${stat}"]`);
                    const rec = (rowEl && rowEl.getAttribute('data-rec') || '').toUpperCase();
                    const cur = Number(p.current);
                    const line = Number(p.line);
                    let color;
                    if (rec === 'OVER' && isFinite(cur) && isFinite(line)) {
                        // OVER: red until we hit/past the number, then green
                        color = cur >= line ? goodGrad : badGrad;
                    } else if (rec === 'UNDER' && isFinite(cur) && isFinite(line)) {
                        // UNDER: green until we hit the number (>=), then red
                        color = cur >= line ? badGrad : goodGrad;
                    } else if (!rec) {
                        // No recommendation: neutral yellow
                        color = neutralGrad;
                    } else {
                        // No rec available: use default behavior (green <100%, red at 100%)
                        color = defaultColor(pct);
                    }
                    barEl.style.background = color;
                    // Hit reaction
                    const rowForHit = rowEl;
                    const hitEl = panel.querySelector(`#${CSS.escape(base)}-hit`);
                    const isHit = isFinite(cur) && isFinite(line) && cur >= line;
                    if (rowForHit) rowForHit.classList.toggle('hit', !!isHit);
                    if (hitEl) {
                        if (isHit) {
                            hitEl.classList.remove('good','bad','neutral');
                            if (rec === 'OVER') { hitEl.classList.add('good'); hitEl.textContent = 'HIT ✓'; }
                            else if (rec === 'UNDER') { hitEl.classList.add('bad'); hitEl.textContent = 'LINE REACHED'; }
                            else { hitEl.classList.add('neutral'); hitEl.textContent = 'REACHED'; }
                            hitEl.style.display = 'inline-block';
                        } else {
                            hitEl.style.display = 'none';
                        }
                    }
                }
            }
        }

        async function loadSummary() {
            try {
                const response = await fetch('/api/summary');
                const data = await response.json();
                
                if (data.success) {
                    const summary = data.summary;
                    const totalEl = document.getElementById('total-games');
                    const compEl = document.getElementById('completed-games');
                    const accEl = document.getElementById('prediction-accuracy');
                    const errEl = document.getElementById('avg-error');
                    if (totalEl) totalEl.textContent = summary.total_games;
                    if (compEl) compEl.textContent = summary.completed_games;
                    if (accEl) accEl.textContent = (summary.prediction_accuracy * 100).toFixed(2) + '%';
                    if (errEl) errEl.textContent = summary.avg_score_error.toFixed(2);
                }
            } catch (error) {
                console.error('Error loading summary:', error);
            }
        }

        async function loadTodaysGames() {
            const date = document.getElementById('game-date').value;
            const container = document.getElementById('games-container');
            
            console.log('Loading todays games for date:', date);
            container.innerHTML = '<div class="loading">Loading today\'s games...</div>';
            
            try {
                const response = await fetch(`/api/today-games?date=${date}`);
                const data = await response.json();
                
                console.log('API Response:', data);
                console.log('Games count:', data.games?.length);
                
                if (data.success && data.games.length > 0) {
                    console.log('Processing games...');
                    
                    // Categorize games
                    const liveGames = [];
                    const upcomingGames = [];
                    const completedGames = [];
                    
                    // Track unique games to prevent duplicates
                    const uniqueGames = new Map();
                    
                    for (const game of data.games) {
                        const gameKey = `${game.away_team}_${game.home_team}_${game.date}`;
                        
                        // Only add if we haven't seen this game before
                        if (!uniqueGames.has(gameKey)) {
                            uniqueGames.set(gameKey, game);
                            
                            const liveStatus = game.live_status || {};
                            console.log(`Game: ${game.away_team} @ ${game.home_team}`);
                            console.log(`Live status:`, liveStatus);
                            
                            if (liveStatus.is_live) {
                                console.log(`Adding to live games`);
                                liveGames.push(game);
                            } else if (liveStatus.is_final) {
                                console.log(`Adding to completed games`);
                                completedGames.push(game);
                            } else {
                                console.log(`Adding to upcoming games`);
                                upcomingGames.push(game);
                            }
                        }
                    }
                    
                    // Sort games within each category
                    liveGames.sort((a, b) => {
                        // Live games: show by game time
                        const timeA = new Date(a.game_time || 0);
                        const timeB = new Date(b.game_time || 0);
                        return timeA - timeB;
                    });
                    
                    upcomingGames.sort((a, b) => {
                        // Upcoming: earliest games first
                        const timeA = new Date(a.game_time || '9999-12-31');
                        const timeB = new Date(b.game_time || '9999-12-31');
                        return timeA - timeB;
                    });
                    
                    completedGames.sort((a, b) => {
                        // Completed: most recently finished first
                        const timeA = new Date(a.game_time || 0);
                        const timeB = new Date(b.game_time || 0);
                        return timeB - timeA;
                    });
                    
                    // Display each section
                    displayGameSection('live-games', liveGames);
                    displayGameSection('upcoming-games', upcomingGames);
                    displayGameSection('completed-games', completedGames);
                    
                    // Hide main container only after sections are populated
                    container.style.display = 'none';
                    
                    console.log(`Loaded games: ${liveGames.length} live, ${upcomingGames.length} upcoming, ${completedGames.length} completed`);

                    // Trigger an initial live update now that cards are rendered
                    updateLiveGames();
                } else {
                    container.innerHTML = '<div class="error">No games found for today.</div>';
                }
            } catch (error) {
                container.innerHTML = '<div class="error">Error loading games: ' + error.message + '</div>';
            }
        }

        function displayGameSection(sectionPrefix, games) {
            const section = document.getElementById(`${sectionPrefix}-section`);
            const container = document.getElementById(`${sectionPrefix}-container`);
            
            console.log(`Displaying ${sectionPrefix} with ${games.length} games`);
            
            if (games.length > 0) {
                console.log(`Showing section: ${sectionPrefix}-section`);
                section.style.display = 'block';
                container.innerHTML = '';
                
                games.forEach((game, index) => {
                    console.log(`Creating card ${index + 1} for ${game.away_team} @ ${game.home_team}`);
                    const gameCard = createGameCard(game);
                    container.appendChild(gameCard);
                });
                
                console.log(`Added ${games.length} game cards to ${sectionPrefix}-container`);
            } else {
                console.log(`Hiding section: ${sectionPrefix}-section (no games)`);
                section.style.display = 'none';
            }
        }

        // Keep the old loadGames function for historical page
        async function loadGames() {
            const date = document.getElementById('game-date').value;
            const container = document.getElementById('games-container');
            
            container.innerHTML = '<div class="loading">Loading games...</div>';
            
            try {
                const response = await fetch(`/api/today-games?date=${date}`);
                const data = await response.json();
                
                if (data.success && data.games.length > 0) {
                    // Clear container completely to prevent duplicates
                    container.innerHTML = '';
                    
                    const gamesGrid = document.createElement('div');
                    gamesGrid.className = 'games-grid';
                    
                    // Track unique games to prevent duplicates
                    const uniqueGames = new Map();
                    
                    for (const game of data.games) {
                        const gameKey = `${game.away_team}_${game.home_team}_${game.date}`;
                        
                        // Only add if we haven't seen this game before
                        if (!uniqueGames.has(gameKey)) {
                            uniqueGames.set(gameKey, game);
                            const gameCard = createGameCard(game);
                            gamesGrid.appendChild(gameCard);
                        }
                    }
                    
                    container.appendChild(gamesGrid);
                    console.log(`Loaded ${uniqueGames.size} unique games`);
                } else {
                    container.innerHTML = '<div class="error">No games found for this date.</div>';
                }
            } catch (error) {
                container.innerHTML = '<div class="error">Error loading games: ' + error.message + '</div>';
            }
        }

        function createGameCard(game) {
            const card = document.createElement('div');
            card.className = 'game-card';
            // Use a composite key that matches live-status lookups and add explicit team attributes
            const compositeId = `${game.away_team}_${game.home_team}_${game.date}`;
            card.setAttribute('data-game-id', compositeId);
            card.setAttribute('data-away-team', (game.away_team || '').toLowerCase());
            card.setAttribute('data-home-team', (game.home_team || '').toLowerCase());
            // Modal disabled: keep interactions inline
            // card.onclick = () => loadPrediction(game.away_team, game.home_team, game.date);
            
            // Debug: log the entire game object
            console.log(`🔍 CREATING CARD FOR: ${game.away_team} @ ${game.home_team}`);
            console.log('Full game object:', game);
            console.log('Pitcher data:', {
                away_pitcher: game.away_pitcher,
                home_pitcher: game.home_pitcher
            });
            console.log('Prediction data:', {
                predicted_away_score: game.predicted_away_score,
                predicted_home_score: game.predicted_home_score,
                predicted_total_runs: game.predicted_total_runs,
                away_win_probability: game.away_win_probability,
                home_win_probability: game.home_win_probability
            });
            
            // Get team assets for logos and colors
            const awayAssets = game.away_team_assets || { logo_url: game.away_logo };
            const homeAssets = game.home_team_assets || { logo_url: game.home_logo };
            
            // Get team colors for dynamic styling
            const awayColors = game.away_team_colors || { primary: '#333333', secondary: '#666666', text: '#FFFFFF' };
            const homeColors = game.home_team_colors || { primary: '#333333', secondary: '#666666', text: '#FFFFFF' };
            
            // Get live status information
            const liveStatus = game.live_status || {
                status: 'Scheduled',
                badge_class: 'scheduled',
                game_time: 'TBD',
                is_live: false,
                is_final: false
            };
            
            // Format game time - only show for scheduled games
            let displayTime = '';
            let displayStatus = liveStatus.status;
            
            // Only show time for scheduled games (not live or final)
            if (!liveStatus.is_live && !liveStatus.is_final) {
                // First, try to use the already-formatted time from live_status
                if (liveStatus.game_time && liveStatus.game_time !== 'TBD' && 
                    !liveStatus.game_time.includes('T') && !liveStatus.game_time.includes('Z')) {
                    // This is already a formatted time like "7:10 PM"
                    displayTime = liveStatus.game_time;
                } 
                // Otherwise, try to convert the raw game time
                else if (game.game_time && game.game_time !== 'TBD') {
                    try {
                        // Handle enhanced data time format: "2025-08-14T17:05:00+00:00"
                        let gameTimeString = game.game_time;
                        
                        console.log('🕐 Processing game time:', gameTimeString);
                        
                        // The enhanced data should already be in proper ISO format
                        // "2025-08-14T17:05:00+00:00" is valid ISO 8601
                        const gameDate = new Date(gameTimeString);
                        
                        // Verify the date was parsed correctly
                        if (isNaN(gameDate.getTime())) {
                            console.error('❌ Invalid date parsed:', gameTimeString);
                            displayTime = 'TBD';
                        } else {
                            // Always convert to Central Time for consistency
                            displayTime = gameDate.toLocaleTimeString('en-US', { 
                                hour: 'numeric', 
                                minute: '2-digit',
                                hour12: true,
                                timeZone: 'America/Chicago' // Central Time
                            });
                            
                            displayTime += ' CT'; // Central Time indicator
                            
                            console.log('✅ Time converted successfully:', {
                                original: gameTimeString,
                                parsed: gameDate.toISOString(),
                                central: displayTime
                            });
                        }
                    } catch (error) {
                        console.error('❌ Error converting game time:', error);
                        displayTime = 'TBD';
                    }
                }
            }
            
            // For live games, enhance status with inning info if available
            if (liveStatus.is_live && liveStatus.inning && liveStatus.inning_state) {
                displayStatus = `${liveStatus.inning_state} ${liveStatus.inning}`;
            }
            
            // Get real betting lines data
            const realLines = game.real_betting_lines || {};
            const moneyline = realLines.moneyline || {};
            const totalRuns = realLines.total_runs || {};
            const runLine = realLines.run_line || {};
            
            let bettingLinesHtml = '';
            // Show betting lines if we have real betting lines data
            if (game.has_real_betting_lines && Object.keys(realLines).length > 0) {
                // Format moneyline odds with proper + sign for positive values
                const formatOdds = (odds) => {
                    if (!odds) return 'N/A';
                    return odds > 0 ? `+${odds}` : `${odds}`;
                };
                
                // Format run line with proper +/- signs - handle both string and numeric formats
                const formatRunLine = (line, odds, isAway = true) => {
                    if (!line) return 'N/A';
                    
                    // Handle string format like "-1.5 (+130)"
                    if (typeof odds === 'string') {
                        return odds;
                    }
                    
                    // Handle numeric format from OddsAPI
                    if (typeof odds === 'number') {
                        const lineStr = isAway ? (line > 0 ? `+${line}` : `${line}`) : (line > 0 ? `-${line}` : `+${Math.abs(line)}`);
                        const oddsStr = odds > 0 ? `+${odds}` : `${odds}`;
                        return `${lineStr} (${oddsStr})`;
                    }
                    
                    return 'N/A';
                };
                
                bettingLinesHtml = `
                    <div class="betting-lines">
                        <h4>DraftKings Betting Lines</h4>
                        <div class="betting-grid">
                            <div class="betting-item">
                                <div class="line-label">Moneyline</div>
                                <div class="line-value">
                                    <div class="moneyline-away">${game.away_team.substring(0, 3)}: ${formatOdds(moneyline.away)}</div>
                                    <div class="moneyline-home">${game.home_team.substring(0, 3)}: ${formatOdds(moneyline.home)}</div>
                                </div>
                            </div>
                            <div class="betting-item">
                                <div class="line-label">Over/Under</div>
                                <div class="line-value">
                                    ${totalRuns.line ? `${totalRuns.line}` : 'N/A'}<br>
                                    ${totalRuns.over && totalRuns.under ? `O: ${formatOdds(totalRuns.over)} / U: ${formatOdds(totalRuns.under)}` : ''}
                                </div>
                            </div>
                            <div class="betting-item">
                                <div class="line-label">Run Line</div>
                                <div class="line-value">
                                    <div class="moneyline-away">${game.away_team.substring(0, 3)}: ${formatRunLine(runLine.line, runLine.away, true)}</div>
                                    <div class="moneyline-home">${game.home_team.substring(0, 3)}: ${formatRunLine(runLine.line, runLine.home, false)}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            card.innerHTML = `
                <div class="card-grid">
                    <div class="teams-col">
                        <div class="game-header">
                            <div class="game-teams">
                                <div class="team-info" style="background: linear-gradient(135deg, ${awayColors.primary}, ${awayColors.secondary}); color: ${awayColors.text}; border-radius: 6px; padding: 6px;">
                                    <img src="${awayAssets.logo_url || ''}" alt="${game.away_team}" class="team-logo" />
                                    <span class="team-name">${game.away_team}</span>
                                </div>
                                <span class="vs-separator">@</span>
                                <div class="team-info" style="background: linear-gradient(135deg, ${homeColors.primary}, ${homeColors.secondary}); color: ${homeColors.text}; border-radius: 6px; padding: 6px;">
                                    <img src="${homeAssets.logo_url || ''}" alt="${game.home_team}" class="team-logo" />
                                    <span class="team-name">${game.home_team}</span>
                                </div>
                            </div>
                        </div>
                        <div class="live-inline">${liveStatus.is_live || liveStatus.is_final ? createLiveBadgeHtml(liveStatus) : `<span class=\"game-status-badge badge-${liveStatus.badge_class}\">${displayStatus}</span>`}</div>
                        <div class="game-time">${displayTime || ''}</div>
                        <div class="starting-pitchers" style="margin-top:8px;">
                            <div class="pitcher-matchup">
                                <div class="away-pitcher"><span class="pitcher-label">SP:</span> <span class="pitcher-name">${game.away_pitcher || 'TBD'}</span></div>
                                <span class="vs-separator">vs</span>
                                <div class="home-pitcher"><span class="pitcher-label">SP:</span> <span class="pitcher-name">${game.home_pitcher || 'TBD'}</span></div>
                            </div>
                        </div>
                        ${createFactorCardsHtml(game)}
                    </div>
                    <div class="middle-col">
                        <div class="prediction-summary" id="summary-${game.game_id}">
                            ${createPredictionSummaryHtml(game)}
                        </div>
                        ${bettingLinesHtml}
                        ${game.betting_recommendations && (game.betting_recommendations.value_bets || game.betting_recommendations.recommendations) ? createBettingRecommendationsHtml(game.betting_recommendations, game.away_team, game.home_team) : ''}
                    </div>
                    <div class="props-col">
                        ${createPitcherPropsPanelHtml(game)}
                    </div>
                </div>
                
            `;
            
            return card;
        }

        function createInlineDetailsHtml(game) {
            try {
                const cf = game.card_factors || {};
                const ts = cf.team_strengths || {}; const bp = cf.bullpen || {}; const wx = cf.weather || {};
                const fmt = (x, d='—') => (x==null || x==='') ? d : x;
                const pct = (x) => (typeof x==='number' ? `${(x*100).toFixed(0)}%` : '—');
                const qf = (x) => (typeof x==='number' ? x.toFixed(2) : '—');
                const wxParts = [];
                if (wx.temperature!=null) wxParts.push(`${wx.temperature}°`);
                if (wx.wind_speed!=null) wxParts.push(`Wind ${wx.wind_speed} mph`);
                if (wx.conditions) wxParts.push(`${wx.conditions}`);
                const wxLine = wxParts.join(' • ');

                const id = `details-${(game.away_team||'').replace(/\s+/g,'_')}-${(game.home_team||'').replace(/\s+/g,'_')}-${game.date}`;
                return `
                    <div class="details">
                        <div class="details-toggle" onclick="(function(btn){ const p = document.getElementById('${id}'); const isOpen = p.classList.toggle('open'); const chev = btn.querySelector('.chev'); chev.style.transform = isOpen ? 'rotate(90deg)' : 'rotate(0deg)'; })(this)">
                            <span class="chev">▶</span>
                            <span>Details</span>
                            <span class="chip">Total ${fmt(game.over_under_total, 'N/A')}</span>
                        </div>
                        <div id="${id}" class="details-panel">
                            <div class="details-grid">
                                <div class="details-item">
                                    <h5>Team Strengths</h5>
                                    <div class="kv">${game.away_team.split(' ').pop()}: <strong>${qf(ts.away)}</strong></div>
                                    <div class="kv">${game.home_team.split(' ').pop()}: <strong>${qf(ts.home)}</strong></div>
                                </div>
                                <div class="details-item">
                                    <h5>Bullpen</h5>
                                    <div class="kv">${game.away_team.split(' ').pop()}: <strong>${fmt(bp.away?.rating)}</strong> <span style="opacity:.8">(${qf(bp.away?.quality_factor)})</span></div>
                                    <div class="kv">${game.home_team.split(' ').pop()}: <strong>${fmt(bp.home?.rating)}</strong> <span style="opacity:.8">(${qf(bp.home?.quality_factor)})</span></div>
                                </div>
                                <div class="details-item">
                                    <h5>Weather & Park</h5>
                                    <div class="kv">${wxLine || '—'}</div>
                                    <div class="kv">Park factor: <strong>${qf(wx.park_factor)}</strong> • Total factor: <strong>${qf(wx.total_factor)}</strong></div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            } catch (e) {
                console.warn('createInlineDetailsHtml failed', e);
                return '';
            }
        }

        function createPredictionSummaryHtml(game) {
            // Use prediction data directly from the game object
            const predictedAwayScore = game.predicted_away_score || 0;
            const predictedHomeScore = game.predicted_home_score || 0;
            const awayWinProb = game.away_win_probability || 0;
            const homeWinProb = game.home_win_probability || 0;
            const predictedWinner = game.predicted_winner || '';
            
            console.log('Creating prediction summary for:', game.away_team, '@', game.home_team);
            console.log('Prediction data:', { predictedAwayScore, predictedHomeScore, awayWinProb, homeWinProb });
            
            // If no prediction data, show placeholder
            if (!predictedAwayScore && !predictedHomeScore) {
                console.log('No prediction data found, showing placeholder');
                return `
                    <div class="prediction-item">
                        <div class="value">--</div>
                        <div class="label">No Prediction</div>
                    </div>
                `;
            }
            
            console.log('Creating prediction summary with data');
            return `
                <div class="prediction-item">
                    <div class="value">${predictedAwayScore}</div>
                    <div class="label">${game.away_team.split(' ').pop()}</div>
                </div>
                <div class="prediction-item">
                    <div class="value">${predictedHomeScore}</div>
                    <div class="label">${game.home_team.split(' ').pop()}</div>
                </div>
                <div class="prediction-item">
                    <div class="value">${homeWinProb.toFixed(2)}%</div>
                    <div class="label">Home Win</div>
                </div>
            `;
        }

        function createFactorCardsHtml(game) {
            try {
                const cf = game.card_factors || {};
                const ts = cf.team_strengths || {}; const bp = cf.bullpen || {}; const wx = cf.weather || {};
                const fmt = (x, d='—') => (x==null || x==='') ? d : x;
                const qf = (x) => (typeof x==='number' ? x.toFixed(2) : '—');
                const wxParts = [];
                if (wx.temperature!=null) wxParts.push(`${wx.temperature}°`);
                if (wx.wind_speed!=null) wxParts.push(`Wind ${wx.wind_speed} mph`);
                if (wx.conditions) wxParts.push(`${wx.conditions}`);
                const wxLine = wxParts.join(' • ');

                // Pitcher Score: simple compact derived hint from props edge if available
                const pitchers = game.pitchers || {}; const away = pitchers.away || {}; const home = pitchers.home || {};
                const projEdge = (p) => {
                    try {
                        const L = (p&&p.lines)||{};
                        const stats = ['strikeouts','outs','earned_runs','hits_allowed','walks'];
                        let sum = 0, n = 0;
                        for (const st of stats) {
                            const ln = L[st]?.line; const pj = p[`projected_${st}`];
                            if (ln!=null && pj!=null && isFinite(Number(ln)) && isFinite(Number(pj))) { sum += (Number(pj)-Number(ln)); n++; }
                        }
                        return n? (sum/n) : null;
                    } catch { return null; }
                };
                const awayPS = projEdge(away); const homePS = projEdge(home);

                return `
                    <div class="factor-cards">
                        <div class="factor-card">
                            <h5>Team Strengths</h5>
                            <div class="factor-kv"><span>${game.away_team.split(' ').pop()}</span><span><strong>${qf(ts.away)}</strong></span></div>
                            <div class="factor-kv"><span>${game.home_team.split(' ').pop()}</span><span><strong>${qf(ts.home)}</strong></span></div>
                        </div>
                        <div class="factor-card">
                            <h5>Bullpen</h5>
                            <div class="factor-kv"><span>${game.away_team.split(' ').pop()}</span><span><strong>${fmt(bp.away?.rating)}</strong></span></div>
                            <div class="factor-sub">QF ${qf(bp.away?.quality_factor)}</div>
                            <div class="factor-kv"><span>${game.home_team.split(' ').pop()}</span><span><strong>${fmt(bp.home?.rating)}</strong></span></div>
                            <div class="factor-sub">QF ${qf(bp.home?.quality_factor)}</div>
                        </div>
                        <div class="factor-card">
                            <h5>Weather & Park</h5>
                            <div class="factor-kv"><span>Weather</span><span>${wxLine || '—'}</span></div>
                            <div class="factor-kv"><span>Park</span><span>${qf(wx.park_factor)}</span></div>
                            <div class="factor-kv"><span>Total</span><span>${qf(wx.total_factor)}</span></div>
                        </div>
                        <div class="factor-card">
                            <h5>Pitcher Score</h5>
                            <div class="factor-kv"><span>${game.away_pitcher || 'Away SP'}</span><span>${awayPS==null? '—' : (awayPS>0?'+':'') + awayPS.toFixed(2)}</span></div>
                            <div class="factor-kv"><span>${game.home_pitcher || 'Home SP'}</span><span>${homePS==null? '—' : (homePS>0?'+':'') + homePS.toFixed(2)}</span></div>
                        </div>
                    </div>
                `;
            } catch (e) {
                console.warn('createFactorCardsHtml failed', e);
                return '';
            }
        }

        function createLiveScoreHtml(liveStatus, awayColors = null, homeColors = null) {
            // Only hide if scores are truly missing; show 0-0 as valid
            if (liveStatus.away_score == null && liveStatus.home_score == null) {
                return '';
            }
            
            // Default colors if not provided
            const defaultAwayColors = awayColors || { primary: '#333333', secondary: '#666666', text: '#FFFFFF' };
            const defaultHomeColors = homeColors || { primary: '#444444', secondary: '#777777', text: '#FFFFFF' };
            
            // Create inning display for live games
            let inningDisplay = 'LIVE';
            if (liveStatus.inning && liveStatus.inning_state) {
                inningDisplay = `${liveStatus.inning_state} ${liveStatus.inning}`;
            }
            
            const counts = (liveStatus.balls != null && liveStatus.strikes != null && liveStatus.outs != null)
                ? `<div style="font-size: 0.8em; opacity: 0.85;">B:${liveStatus.balls} S:${liveStatus.strikes} O:${liveStatus.outs}</div>`
                : '';
            const bases = liveStatus.base_state ? `<div style="font-size: 0.8em; opacity: 0.85;">${liveStatus.base_state}</div>` : '';
            return `
                <div class="live-score" style="display:flex; gap:8px; align-items:center;">
                    <div style="background: ${defaultAwayColors.primary}; color: ${defaultAwayColors.text}; padding: 4px 8px; border-radius: 4px; border: 1px solid ${defaultAwayColors.secondary};">
                        <span class="team-score">${liveStatus.away_score ?? 0}</span>
                    </div>
                    <div style="color: #dc3545; font-weight: bold; font-size: 0.9em; min-width: 90px;">${inningDisplay}</div>
                    <div style="display:flex; gap:10px; align-items:center;">
                        ${counts}
                        ${bases}
                    </div>
                    <div style="margin-left:auto; background: ${defaultHomeColors.primary}; color: ${defaultHomeColors.text}; padding: 4px 8px; border-radius: 4px; border: 1px solid ${defaultHomeColors.secondary};">
                        <span class="team-score">${liveStatus.home_score ?? 0}</span>
                    </div>
                </div>
            `;
        }

        function createPitcherPropsPanelHtml(game) {
            try {
                const panelId = `ppanel-${(game.away_team||'').replace(/\s+/g,'_')}-${(game.home_team||'').replace(/\s+/g,'_')}-${game.date}`;
                const pitchers = game.pitchers || {};
                const away = pitchers.away || {};
                const home = pitchers.home || {};
                // Build a quick lookup of snapshot prop plays for recommendation/confidence when available
                const plays = Array.isArray(game.pitcher_prop_plays) ? game.pitcher_prop_plays : [];
                const key = (name, stat) => `${String(name||'').trim().toLowerCase()}|${stat}`;
                const playsMap = new Map();
                for (const e of plays) {
                    const k = key(e.pitcher_name, e.stat);
                    if (!playsMap.has(k)) playsMap.set(k, e);
                }
                const fmt = (n) => (n==null || isNaN(Number(n))) ? '-' : (Math.round(Number(n)*10)/10).toFixed(1).replace(/\.0$/, '');
                const edge = (proj, line) => {
                    const pn = Number(proj), ln = Number(line);
                    if (isNaN(pn) || isNaN(ln)) return '';
                    const d = Math.round((pn - ln)*10)/10;
                    if (!isFinite(d)) return '';
                    const s = d>0?`+${d}`:`${d}`;
                    return `Edge ${s}`;
                };
                const oddsStr = (o) => {
                    if (!o) return '—';
                    const ov = o.over_odds, un = o.under_odds;
                    const f = (x) => (x==null||x==='')? 'N/A' : (Number(x)>0?`+${x}`:`${x}`);
                    if (ov==null && un==null) return '—';
                    return `O ${f(ov)} / U ${f(un)}`;
                };
                const hasAnyLines = (p) => {
                    try {
                        const L = (p&&p.lines)||{};
                        const stats = ['strikeouts','outs','earned_runs','hits_allowed','walks'];
                        return stats.some(st => L[st] && (L[st].line!=null || L[st].over_odds!=null || L[st].under_odds!=null));
                    } catch { return false; }
                };
                const row = (teamSide, p, stat, label, projKey) => {
                    const lines = (p.lines||{});
                    const lineObj = lines[stat] || {};
                    const line = lineObj.line;
                    const proj = p[projKey];
                    const lineFmt = fmt(line); const projFmt = fmt(proj);
                    const eid = `${panelId}-${teamSide}-${stat}`;
                    // Determine recommendation & confidence from snapshot plays if present, else fall back to proj vs line
                    let recSide = null; // 'OVER' | 'UNDER'
                    let confLabel = null; // 'HIGH' | 'MEDIUM' | 'LOW'
                    const playHit = playsMap.get(key(p.pitcher_name, stat));
                    if (playHit && (playHit.side || playHit.recommendation)) {
                        recSide = (playHit.side || playHit.recommendation || '').toUpperCase();
                        confLabel = (playHit.confidence || playHit.confidence_label || '').toUpperCase();
                    } else {
                        const pn = Number(proj), ln = Number(line);
                        if (!isNaN(pn) && !isNaN(ln)) {
                            recSide = pn > ln ? 'OVER' : 'UNDER';
                            // Heuristic confidence from diff magnitude vs stat-specific threshold
                            try {
                                const thr = { strikeouts:0.7, outs:2.0, earned_runs:0.6, hits_allowed:0.8, walks:0.6 }[stat] || 0.7;
                                const norm = Math.abs(pn - ln) / Math.max(1e-6, thr);
                                if (norm >= 1.5) confLabel = 'HIGH';
                                else if (norm >= 0.9) confLabel = 'MEDIUM';
                                else confLabel = 'LOW';
                            } catch {}
                        }
                    }
                    const badge = recSide ? `<span class="rec-badge ${recSide.toLowerCase()} ${String(confLabel||'').toLowerCase()}" title="${recSide} • ${confLabel||'Confidence N/A'}">${recSide} ${confLabel? '· '+confLabel : ''}</span>` : '';
                    return `
                        <div class="prop-row" data-side="${teamSide}" data-stat="${stat}" data-rec="${recSide||''}" data-conf="${confLabel||''}">
                            <div class="meta">
                                <span class="stat-label"><strong>${label}</strong></span>
                                ${badge}
                                <span class="line">Line: ${lineFmt}</span>
                                <span class="proj">Proj: ${projFmt}</span>
                                <span class="edge">${edge(proj, line)}</span>
                                <span class="odds">${oddsStr(lineObj)}</span>
                            </div>
                            <div class="bar"><div class="fill" id="${eid}-bar"></div></div>
                            <div class="current"><span id="${eid}-cur">—</span><span class="target">/ ${lineFmt}</span><span class="hit-badge" id="${eid}-hit">HIT</span></div>
                        </div>
                    `;
                };
                const awayName = (away && away.pitcher_name) || (game.away_pitcher && game.away_pitcher !== 'TBD' ? game.away_pitcher : null);
                const homeName = (home && home.pitcher_name) || (game.home_pitcher && game.home_pitcher !== 'TBD' ? game.home_pitcher : null);
        const fmtInt = (x) => (x==null||x==='') ? '—' : parseInt(x, 10);
        const pitchHdr = (p, side) => {
            const projPC = p.projected_pitch_count;
            return `<div class="pitcher-col-subhdr" id="${panelId}-${side}-pc">PC: ${fmtInt(projPC)}<span class="live-pc" id="${panelId}-${side}-pc-live"></span></div>`;
        };
        const awayBlock = awayName ? `
                    <div class="pitcher-column" data-side="away">
            <div class="pitcher-col-header"><span class="name">${awayName}</span><span class="team">${game.away_team}</span></div>
            ${pitchHdr(away, 'away')}
                        ${hasAnyLines(away) ? `<div class="props-table">
                            ${row('away', away, 'strikeouts', 'K', 'projected_strikeouts')}
                            ${row('away', away, 'outs', 'Outs', 'projected_outs')}
                            ${row('away', away, 'earned_runs', 'ER', 'projected_earned_runs')}
                            ${row('away', away, 'hits_allowed', 'Hits', 'projected_hits_allowed')}
                            ${row('away', away, 'walks', 'BB', 'projected_walks')}
                        </div>` : `<div class="props-table"><div class="prop-row"><div class="meta"><span class="stat-label"><strong>No market</strong></span><span style="opacity:0.8;">Awaiting lines</span></div></div></div>`}
                    </div>` : '';
        const homeBlock = homeName ? `
                    <div class="pitcher-column" data-side="home">
            <div class="pitcher-col-header"><span class="name">${homeName}</span><span class="team">${game.home_team}</span></div>
            ${pitchHdr(home, 'home')}
                        ${hasAnyLines(home) ? `<div class="props-table">
                            ${row('home', home, 'strikeouts', 'K', 'projected_strikeouts')}
                            ${row('home', home, 'outs', 'Outs', 'projected_outs')}
                            ${row('home', home, 'earned_runs', 'ER', 'projected_earned_runs')}
                            ${row('home', home, 'hits_allowed', 'Hits', 'projected_hits_allowed')}
                            ${row('home', home, 'walks', 'BB', 'projected_walks')}
                        </div>` : `<div class="props-table"><div class="prop-row"><div class="meta"><span class="stat-label"><strong>No market</strong></span><span style=\"opacity:0.8;\">Awaiting lines</span></div></div></div>`}
                    </div>` : '';
                const dataAttrs = `data-away-pitcher="${(away.pitcher_name||'').replace(/"/g,'&quot;')}" data-home-pitcher="${(home.pitcher_name||'').replace(/"/g,'&quot;')}"`;
                return `<div id="${panelId}" class="pitcher-props-panel" ${dataAttrs}>${awayBlock}${homeBlock}</div>`;
            } catch (e) {
                console.warn('createPitcherPropsPanelHtml failed', e);
                return '';
            }
        }

        function createFinalScoreHtml(liveStatus, game, awayColors = null, homeColors = null) {
            if (liveStatus.away_score == null && liveStatus.home_score == null) {
                return '';
            }
            
            // Default colors if not provided
            const defaultAwayColors = awayColors || { primary: '#333333', secondary: '#666666', text: '#FFFFFF' };
            const defaultHomeColors = homeColors || { primary: '#444444', secondary: '#777777', text: '#FFFFFF' };
            
            // Use game data directly as it contains prediction info
            const predictedAwayScore = game.predicted_away_score || 0;
            const predictedHomeScore = game.predicted_home_score || 0;
            const predictedTotalRuns = game.predicted_total_runs || (predictedAwayScore + predictedHomeScore);
            
            // Debug: Check what's happening with predicted total runs
            console.log(`🐛 DEBUGGING Total Runs for ${game.away_team} @ ${game.home_team}:`);
            console.log(`  - game.predicted_total_runs: ${game.predicted_total_runs}`);
            console.log(`  - predictedAwayScore: ${predictedAwayScore}`);
            console.log(`  - predictedHomeScore: ${predictedHomeScore}`);
            console.log(`  - calculated predictedTotalRuns: ${predictedTotalRuns}`);
            
            const actualAwayScore = liveStatus.away_score || 0;
            const actualHomeScore = liveStatus.home_score || 0;
            const actualTotalRuns = actualAwayScore + actualHomeScore;
            
            // Winner prediction accuracy
            const predictedWinner = predictedAwayScore > predictedHomeScore ? 'away' : 'home';
            const actualWinner = actualAwayScore > actualHomeScore ? 'away' : 'home';
            const winnerCorrect = predictedWinner === actualWinner;
            
            // Score difference analysis
            const awayScoreDiff = Math.abs(actualAwayScore - predictedAwayScore);
            const homeScoreDiff = Math.abs(actualHomeScore - predictedHomeScore);
            const avgScoreDiff = (awayScoreDiff + homeScoreDiff) / 2;
            
            // Total runs analysis
            const totalRunsDiff = Math.abs(actualTotalRuns - predictedTotalRuns);
            const totalRunsAccuracy = totalRunsDiff <= 1 ? 'Excellent' : 
                                     totalRunsDiff <= 2 ? 'Good' : 
                                     totalRunsDiff <= 3 ? 'Fair' : 'Poor';
            
            // Use the original bet_grade if available (from enhanced grading), otherwise calculate
            let grade = game.bet_grade || '';
            let gradePoints = 0;
            
            // If no bet_grade available, calculate traditional accuracy grade
            if (!grade) {
                if (winnerCorrect) gradePoints += 50;
                if (avgScoreDiff <= 1) gradePoints += 30;
                else if (avgScoreDiff <= 2) gradePoints += 20;
                else if (avgScoreDiff <= 3) gradePoints += 10;
                if (totalRunsDiff <= 1) gradePoints += 20;
                else if (totalRunsDiff <= 2) gradePoints += 15;
                else if (totalRunsDiff <= 3) gradePoints += 10;
                
                if (gradePoints >= 90) grade = 'A+';
                else if (gradePoints >= 80) grade = 'A';
                else if (gradePoints >= 70) grade = 'B+';
                else if (gradePoints >= 60) grade = 'B';
                else if (gradePoints >= 50) grade = 'C';
                else grade = 'D';
            }
            
            // Betting line analysis (if comprehensive analysis available)
            let bettingAnalysisHtml = '';
            const postGameAnalysis = game.post_game_analysis;
            if (postGameAnalysis && postGameAnalysis.betting_analysis) {
                const bettingAnalysis = postGameAnalysis.betting_analysis;
                
                let marketVsModelHtml = '';
                if (bettingAnalysis.betting_favorite) {
                    const favoriteWon = bettingAnalysis.favorite_won;
                    const modelBeatMarket = bettingAnalysis.model_beat_market;
                    
                    marketVsModelHtml = `
                        <div class="analysis-item ${favoriteWon ? 'analysis-correct' : 'analysis-incorrect'}">
                            <strong>Market Favorite:</strong> ${favoriteWon ? '✅ Won' : '❌ Lost'}
                        </div>
                        <div class="analysis-item ${modelBeatMarket ? 'analysis-correct' : 'analysis-incorrect'}">
                            <strong>Model vs Market:</strong> ${modelBeatMarket ? '✅ Beat Market' : '❌ Followed Market'}
                        </div>
                    `;
                }
                
                let totalBetHtml = '';
                if (bettingAnalysis.total_analysis) {
                    const totalAnalysis = bettingAnalysis.total_analysis;
                    const modelCorrectTotal = totalAnalysis.model_correct_total;
                    
                    totalBetHtml = `
                        <div class="analysis-item ${modelCorrectTotal ? 'analysis-correct' : 'analysis-incorrect'}">
                            <strong>Total Bet:</strong> ${modelCorrectTotal ? '✅ Correct' : '❌ Incorrect'} (Line: ${totalAnalysis.line})
                        </div>
                    `;
                }
                
                if (marketVsModelHtml || totalBetHtml) {
                    bettingAnalysisHtml = `
                        <div class="betting-comparison">
                            <h6>📈 Model vs Market Performance</h6>
                            <div class="betting-grid">
                                ${marketVsModelHtml}
                                ${totalBetHtml}
                            </div>
                        </div>
                    `;
                }
            }
            
            return `
                <div class="live-score">
                    <div>
                        <span style="color: #ff6b6b;">${liveStatus.away_team ? liveStatus.away_team.substring(0, 3) : 'AWAY'}</span>
                        <span class="team-score">${actualAwayScore}</span>
                    </div>
                    <div style="color: #28a745; font-weight: bold;">FINAL</div>
                    <div>
                        <span style="color: #4ecdc4;">${liveStatus.home_team ? liveStatus.home_team.substring(0, 3) : 'HOME'}</span>
                        <span class="team-score">${actualHomeScore}</span>
                    </div>
                </div>
                <div class="final-analysis">
                    <h5>📊 Prediction Analysis (Grade: ${grade})</h5>
                    <div class="analysis-grid">
                        <div class="analysis-item ${winnerCorrect ? 'analysis-correct' : 'analysis-incorrect'}">
                            <strong>Winner:</strong> ${winnerCorrect ? '✅ Correct' : '❌ Incorrect'}
                        </div>
                        <div class="analysis-item">
                            <strong>Score Error:</strong> ±${avgScoreDiff.toFixed(2)} runs
                        </div>
                        <div class="analysis-item">
                            <strong>Total Runs:</strong> ${actualTotalRuns} (predicted ${predictedTotalRuns})
                        </div>
                        <div class="analysis-item">
                            <strong>Total Accuracy:</strong> ±${totalRunsDiff} runs (${totalRunsAccuracy})
                        </div>
                    </div>
                    ${bettingAnalysisHtml}
                </div>
            `;
        }

        async function loadQuickPrediction(awayTeam, homeTeam, date, gameId) {
            try {
                const response = await fetch(`/api/prediction/${awayTeam}/${homeTeam}?date=${date}`);
                const data = await response.json();
                
                if (data.success) {
                    const pred = data.prediction;  // data is directly in prediction object
                    const meta = data.prediction.meta;
                    
                    const summaryElement = document.getElementById(`summary-${gameId}`);
                    if (summaryElement) {
                        // Get pitcher information for display
                        const awayPitcher = pred.away_pitcher || 'TBD';
                        const homePitcher = pred.home_pitcher || 'TBD';
                        
                        summaryElement.innerHTML = `
                            <div class="prediction-item">
                                <div class="value">${pred.predicted_away_score}</div>
                                <div class="label">${awayTeam.split(' ').pop()}</div>
                            </div>
                            <div class="prediction-item">
                                <div class="value">${pred.predicted_home_score}</div>
                                <div class="label">${homeTeam.split(' ').pop()}</div>
                            </div>
                            <div class="prediction-item">
                                <div class="value">${pred.home_win_probability.toFixed(2)}%</div>
                                <div class="label">Home Win</div>
                            </div>
                        `;
                        
                        // Add quick betting tip if available
                        const bettingRecs = data.betting_recommendations;  // Get from top level of data object
                        if (bettingRecs && bettingRecs.best_bet) {
                            const bestBet = bettingRecs.best_bet;
                            const icon = bestBet.edge_rating || '🎯';
                            summaryElement.innerHTML += `
                                <div class="prediction-item betting-tip" style="background: rgba(79, 209, 199, 0.2); border-left: 2px solid #4fd1c7;">
                                    <div class="value" style="font-size: 0.8em;">${icon} ${bestBet.recommendation || bestBet.bet || 'Value Bet'}</div>
                                    <div class="label" style="font-size: 0.7em;">Best Bet</div>
                                </div>
                            `;
                        }
                        
                        // Betting recommendations are now included in initial load, no need to add dynamically
                        // This prevents double display issues
                    }
                    
                    // Update betting lines if available (only if not already present)
                    const bettingData = data.prediction.betting_data;
                    if (bettingData) {
                        const gameCard = document.querySelector(`#summary-${gameId}`).closest('.game-card');
                        const existingLines = gameCard.querySelector('.betting-lines');
                        
                        if (gameCard && !existingLines) {
                            updateGameCardBetting(gameId, bettingData, awayTeam, homeTeam);
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading quick prediction:', error);
            }
        }

        function updateGameCardBetting(gameId, bettingData, awayTeam, homeTeam) {
            // Find the game card and check if it already has betting lines
            const gameCard = document.querySelector(`#summary-${gameId}`).closest('.game-card');
            
            // Double-check if betting lines already exist to prevent duplicates
            if (!gameCard || gameCard.querySelector('.betting-lines')) {
                return; // Already has betting lines or can't find game card
            }
            
            const moneyline = bettingData.moneyline || {};
            const total = bettingData.total || {};
            const spread = bettingData.spread || {};
            
            const bettingLinesHtml = `
                <div class="betting-lines">
                    <h4>Betting Lines</h4>
                    <div class="betting-grid">
                        <div class="betting-item">
                            <div class="line-label">Moneyline</div>
                            <div class="line-value">
                                <div class="moneyline-away">${awayTeam.substring(0, 3)}: ${moneyline.away || 'N/A'}</div>
                                <div class="moneyline-home">${homeTeam.substring(0, 3)}: ${moneyline.home || 'N/A'}</div>
                            </div>
                        </div>
                        <div class="betting-item">
                            <div class="line-label">Total</div>
                            <div class="line-value">
                                ${total.line ? `O/U ${total.line}` : 'N/A'}
                            </div>
                        </div>
                        <div class="betting-item">
                            <div class="line-label">Spread</div>
                            <div class="line-value">
                                ${spread.line ? `${spread.line > 0 ? '+' : ''}${spread.line}` : 'N/A'}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Insert betting lines after the prediction summary
            const summaryElement = document.getElementById(`summary-${gameId}`);
            summaryElement.insertAdjacentHTML('afterend', bettingLinesHtml);
        }

        function createBettingRecommendationsHtml(bettingRecs, awayTeam, homeTeam) {
            if (!bettingRecs || (!bettingRecs.value_bets && !bettingRecs.recommendations)) {
                return '';
            }

            let html = '<div class="betting-recommendations" data-added="true">';
            html += '<h4>💰 Betting Recommendations</h4>';
            
            // Add summary if available
            if (bettingRecs.summary) {
                html += `<div style="font-size: 0.9em; color: #888; margin-bottom: 10px;">${bettingRecs.summary}</div>`;
            }

            // Handle new enhanced format with value_bets array
            if (bettingRecs.value_bets && bettingRecs.value_bets.length > 0) {
                bettingRecs.value_bets.forEach(bet => {
                    const confidenceClass = bet.confidence === 'HIGH' ? 'high-confidence' : 
                                          bet.confidence === 'MEDIUM' ? 'medium-confidence' : 'low-confidence';
                    
                    // Add positive EV class if applicable
                    const isPositiveEV = bet.expected_value && bet.expected_value > 0;
                    const cssClasses = isPositiveEV ? `${confidenceClass} positive-ev` : confidenceClass;
                    
                    const icon = bet.edge_rating || (bet.confidence === 'HIGH' ? '🔥' : 
                               bet.confidence === 'MEDIUM' ? '⚡' : '💡');
                    
                    // Display the recommendation with enhanced formatting
                    const recommendation = bet.recommendation || `${bet.direction?.toUpperCase()} ${bet.line}`;
                    const edgeText = typeof bet.edge === 'number' ? `${bet.edge.toFixed(2)}% edge` : 
                                    bet.edge ? bet.edge : 
                                    bet.confidence ? `${bet.confidence} CONFIDENCE` : 'Value Bet';
                    
                    // Format Expected Value display - LIMITED TO 2 DECIMAL PLACES MAX
                    let evDisplay = '';
                    let evBadge = '';
                    if (bet.expected_value !== undefined && bet.expected_value !== null) {
                        const evPercent = (bet.expected_value * 100).toFixed(2);
                        const evColor = bet.expected_value > 0 ? '#4fd1c7' : '#ff6b6b';
                        const evSign = bet.expected_value > 0 ? '+' : '';
                        evDisplay = `<span style="color: ${evColor}; font-weight: bold;">EV: ${evSign}${evPercent}%</span>`;
                        
                        // Add +EV badge for positive expected value
                        if (bet.expected_value > 0) {
                            evBadge = `<span class="positive-ev-badge">+EV</span>`;
                        }
                    }
                    
                    html += `
                        <div class="value-bet ${cssClasses}" title="${bet.reasoning || 'No details available'}">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 5px;">
                                    <span>${icon}</span>
                                    <strong>${recommendation}</strong>
                                    ${evBadge}
                                </div>
                                <div style="display: flex; flex-direction: column; align-items: flex-end; font-size: 0.8em;">
                                    <span style="color: #4fd1c7;">${edgeText}</span>
                                    ${evDisplay ? `<div>${evDisplay}</div>` : ''}
                                    ${bet.estimated_odds && bet.estimated_odds !== 'N/A' ? `<span style="color: #888;">${bet.estimated_odds}</span>` : ''}
                                </div>
                            </div>
                            <div style="font-size: 0.85em; color: #ccc; margin-top: 3px; line-height: 1.2;">
                                ${bet.reasoning}
                            </div>
                        </div>
                    `;
                });
            }
            // Handle legacy format
            else if (bettingRecs.recommendations && bettingRecs.recommendations.length > 0) {
                bettingRecs.recommendations.forEach(rec => {
                    if (rec !== "No significant value bets identified") {
                        html += `<div class="value-bet medium-confidence">⚡ ${rec}</div>`;
                    }
                });
            }

            // If no value bets found
            if ((!bettingRecs.value_bets || bettingRecs.value_bets.length === 0) && 
                (!bettingRecs.recommendations || bettingRecs.recommendations.every(r => r.includes("No significant")))) {
                html += '<div class="no-value-bet">💡 No significant value bets identified - consider live betting opportunities</div>';
            }

            // Add best bet highlight if available
            if (bettingRecs.best_bet) {
                html += `
                    <div style="margin-top: 10px; padding: 8px; background: rgba(79, 209, 199, 0.2); border-left: 3px solid #4fd1c7; border-radius: 4px;">
                        <strong>🎯 Best Bet:</strong> ${bettingRecs.best_bet.recommendation}
                    </div>
                `;
            }

            html += '</div>';
            return html;
        }

    // Modal code removed
    </script>
    
    <!-- Monitoring Widget -->
    <script src="{{ url_for('static', filename='js/monitoring-widget.js') }}"></script>
</body>
</html>
